### YamlMime:JavaType
uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient"
fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient"
name: "AppendBlobAsyncClient"
nameWithType: "AppendBlobAsyncClient"
summary: "Client to an append blob."
inheritances:
- "<xref href=\"java.lang.Object?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"com.azure.storage.blob.specialized.BlobAsyncClientBase?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.abortCopyFromUrl(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.abortCopyFromUrlWithResponse(java.lang.String,java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.beginCopy(com.azure.storage.blob.options.BlobBeginCopyOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.beginCopy(java.lang.String,java.time.Duration)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.beginCopy(java.lang.String,java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.AccessTier,com.azure.storage.blob.models.RehydratePriority,com.azure.core.http.RequestConditions,com.azure.storage.blob.models.BlobRequestConditions,java.time.Duration)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.copyFromUrl(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.copyFromUrlWithResponse(com.azure.storage.blob.options.BlobCopyFromUrlOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.copyFromUrlWithResponse(java.lang.String,java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.AccessTier,com.azure.core.http.RequestConditions,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.createSnapshot()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.createSnapshotWithResponse(java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.delete()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteIfExists()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteIfExistsWithResponse(com.azure.storage.blob.models.DeleteSnapshotsOptionType,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteImmutabilityPolicy()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteImmutabilityPolicyWithResponse()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteWithResponse(com.azure.storage.blob.models.DeleteSnapshotsOptionType,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.download()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadContent()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadContentWithResponse(com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadStream()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadStreamWithResponse(com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFile(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFile(java.lang.String,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFileWithResponse(com.azure.storage.blob.options.BlobDownloadToFileOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFileWithResponse(java.lang.String,com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.ParallelTransferOptions,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFileWithResponse(java.lang.String,com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.ParallelTransferOptions,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean,java.util.Set<java.nio.file.OpenOption>)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadWithResponse(com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.exists()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.existsWithResponse()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues,com.azure.core.util.Context)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateUserDelegationSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues,com.azure.storage.blob.models.UserDelegationKey)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateUserDelegationSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues,com.azure.storage.blob.models.UserDelegationKey,java.lang.String,com.azure.core.util.Context)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountInfo()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountInfoWithResponse()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountName()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountUrl()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getBlobName()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getBlobUrl()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getContainerAsyncClient()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getContainerName()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getCustomerProvidedKey()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getCustomerProvidedKeyAsyncClient(com.azure.storage.blob.models.CustomerProvidedKey)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getEncryptionScope()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getEncryptionScopeAsyncClient(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getHttpPipeline()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getProperties()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getPropertiesWithResponse(com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getServiceVersion()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getSnapshotClient(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getSnapshotId()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getTags()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getTagsWithResponse(com.azure.storage.blob.options.BlobGetTagsOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getVersionClient(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getVersionId()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.isSnapshot()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.query(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.queryWithResponse(com.azure.storage.blob.options.BlobQueryOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setAccessTier(com.azure.storage.blob.models.AccessTier)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setAccessTierWithResponse(com.azure.storage.blob.models.AccessTier,com.azure.storage.blob.models.RehydratePriority,java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setAccessTierWithResponse(com.azure.storage.blob.options.BlobSetAccessTierOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setHttpHeaders(com.azure.storage.blob.models.BlobHttpHeaders)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setHttpHeadersWithResponse(com.azure.storage.blob.models.BlobHttpHeaders,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setImmutabilityPolicy(com.azure.storage.blob.models.BlobImmutabilityPolicy)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setImmutabilityPolicyWithResponse(com.azure.storage.blob.models.BlobImmutabilityPolicy,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setLegalHold(boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setLegalHoldWithResponse(boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setMetadata(java.util.Map<java.lang.String,java.lang.String>)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setMetadataWithResponse(java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setTags(java.util.Map<java.lang.String,java.lang.String>)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setTagsWithResponse(com.azure.storage.blob.options.BlobSetTagsOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.undelete()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.undeleteWithResponse()"
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
syntax: "public final class AppendBlobAsyncClient extends BlobAsyncClientBase"
fields:
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.MAX_APPEND_BLOCK_BYTES"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.MAX_APPEND_BLOCK_BYTES"
  name: "MAX_APPEND_BLOCK_BYTES"
  nameWithType: "AppendBlobAsyncClient.MAX_APPEND_BLOCK_BYTES"
  summary: "Indicates the maximum number of bytes that can be sent in a call to append<wbr>Block."
  modifiers:
  - "static"
  - "final"
  field:
    value: "4194304"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final int MAX_APPEND_BLOCK_BYTES"
  desc: "Indicates the maximum number of bytes that can be sent in a call to appendBlock."
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.MAX_BLOCKS"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.MAX_BLOCKS"
  name: "MAX_BLOCKS"
  nameWithType: "AppendBlobAsyncClient.MAX_BLOCKS"
  summary: "Indicates the maximum number of blocks allowed in an append blob."
  modifiers:
  - "static"
  - "final"
  field:
    value: "50000"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final int MAX_BLOCKS"
  desc: "Indicates the maximum number of blocks allowed in an append blob."
methods:
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.appendBlock(reactor.core.publisher.Flux<java.nio.ByteBuffer>,long)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.appendBlock(Flux<ByteBuffer> data, long length)"
  name: "appendBlock(Flux<ByteBuffer> data, long length)"
  nameWithType: "AppendBlobAsyncClient.appendBlock(Flux<ByteBuffer> data, long length)"
  summary: "Commits a new block of data to the end of the existing append blob."
  parameters:
  - description: "The data to write to the blob. Note that this <code>Flux</code> must be replayable if retries are enabled\n (the default). In other words, the Flux must produce the same data each time it is subscribed to."
    name: "data"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "The exact length of the data. It is important that this value match precisely the length of the\n data emitted by the <code>Flux</code>."
    name: "length"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<AppendBlobItem> appendBlock(Flux<ByteBuffer> data, long length)"
  desc: "Commits a new block of data to the end of the existing append blob.\n\nNote that the data passed must be replayable if retries are enabled (the default). In other words, the `Flux` must produce the same data each time it is subscribed to.\n\n**Code Samples**\n\n```java\nclient.appendBlock(data, length).subscribe(response ->\n     System.out.printf(\"AppendBlob has %d committed blocks%n\", response.getBlobCommittedBlockCount()));\n```"
  returns:
    description: "<xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> containing the information of the append blob operation."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.AppendBlobItem?alt=com.azure.storage.blob.models.AppendBlobItem&text=AppendBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.appendBlockFromUrl(java.lang.String,com.azure.storage.blob.models.BlobRange)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.appendBlockFromUrl(String sourceUrl, BlobRange sourceRange)"
  name: "appendBlockFromUrl(String sourceUrl, BlobRange sourceRange)"
  nameWithType: "AppendBlobAsyncClient.appendBlockFromUrl(String sourceUrl, BlobRange sourceRange)"
  summary: "Commits a new block of data from another blob to the end of this append blob."
  parameters:
  - description: "The url to the blob that will be the source of the copy.  A source blob in the same storage\n account can be authenticated via Shared Key. However, if the source is a blob in another account, the source blob\n must either be public or must be authenticated via a shared access signature. If the source blob is public, no\n authentication is required to perform the operation."
    name: "sourceUrl"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The source <xref uid=\"com.azure.storage.blob.models.BlobRange\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRange\"></xref> to copy."
    name: "sourceRange"
    type: "<xref href=\"com.azure.storage.blob.models.BlobRange?alt=com.azure.storage.blob.models.BlobRange&text=BlobRange\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<AppendBlobItem> appendBlockFromUrl(String sourceUrl, BlobRange sourceRange)"
  desc: "Commits a new block of data from another blob to the end of this append blob.\n\n**Code Samples**\n\n```java\nclient.appendBlockFromUrl(sourceUrl, new BlobRange(offset, count)).subscribe(response ->\n     System.out.printf(\"AppendBlob has %d committed blocks%n\", response.getBlobCommittedBlockCount()));\n```"
  returns:
    description: "<xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> containing the information of the append blob operation."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.AppendBlobItem?alt=com.azure.storage.blob.models.AppendBlobItem&text=AppendBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.appendBlockFromUrlWithResponse(com.azure.storage.blob.options.AppendBlobAppendBlockFromUrlOptions)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.appendBlockFromUrlWithResponse(AppendBlobAppendBlockFromUrlOptions options)"
  name: "appendBlockFromUrlWithResponse(AppendBlobAppendBlockFromUrlOptions options)"
  nameWithType: "AppendBlobAsyncClient.appendBlockFromUrlWithResponse(AppendBlobAppendBlockFromUrlOptions options)"
  summary: "Commits a new block of data from another blob to the end of this append blob."
  parameters:
  - description: "Parameters for the operation."
    name: "options"
    type: "<xref href=\"com.azure.storage.blob.options.AppendBlobAppendBlockFromUrlOptions?alt=com.azure.storage.blob.options.AppendBlobAppendBlockFromUrlOptions&text=AppendBlobAppendBlockFromUrlOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<AppendBlobItem>> appendBlockFromUrlWithResponse(AppendBlobAppendBlockFromUrlOptions options)"
  desc: "Commits a new block of data from another blob to the end of this append blob.\n\n**Code Samples**\n\n```java\nAppendBlobRequestConditions appendBlobRequestConditions = new AppendBlobRequestConditions()\n     .setAppendPosition(POSITION)\n     .setMaxSize(maxSize);\n\n BlobRequestConditions modifiedRequestConditions = new BlobRequestConditions()\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.appendBlockFromUrlWithResponse(new AppendBlobAppendBlockFromUrlOptions(sourceUrl)\n     .setSourceRange(new BlobRange(offset, count))\n     .setDestinationRequestConditions(appendBlobRequestConditions)\n     .setSourceRequestConditions(modifiedRequestConditions)).subscribe(response ->\n     System.out.printf(\"AppendBlob has %d committed blocks%n\", response.getValue().getBlobCommittedBlockCount()));\n```"
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> containing <xref uid=\"com.azure.core.http.rest.Response\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Response\"></xref> whose <xref uid=\"com.azure.core.http.rest.Response.getValue*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"value\"></xref> contains the append\n blob operation."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.AppendBlobItem?alt=com.azure.storage.blob.models.AppendBlobItem&text=AppendBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.appendBlockFromUrlWithResponse(java.lang.String,com.azure.storage.blob.models.BlobRange,byte[],com.azure.storage.blob.models.AppendBlobRequestConditions,com.azure.storage.blob.models.BlobRequestConditions)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.appendBlockFromUrlWithResponse(String sourceUrl, BlobRange sourceRange, byte[] sourceContentMD5, AppendBlobRequestConditions destRequestConditions, BlobRequestConditions sourceRequestConditions)"
  name: "appendBlockFromUrlWithResponse(String sourceUrl, BlobRange sourceRange, byte[] sourceContentMD5, AppendBlobRequestConditions destRequestConditions, BlobRequestConditions sourceRequestConditions)"
  nameWithType: "AppendBlobAsyncClient.appendBlockFromUrlWithResponse(String sourceUrl, BlobRange sourceRange, byte[] sourceContentMD5, AppendBlobRequestConditions destRequestConditions, BlobRequestConditions sourceRequestConditions)"
  summary: "Commits a new block of data from another blob to the end of this append blob."
  parameters:
  - description: "The url to the blob that will be the source of the copy.  A source blob in the same storage\n account can be authenticated via Shared Key. However, if the source is a blob in another account, the source blob\n must either be public or must be authenticated via a shared access signature. If the source blob is public, no\n authentication is required to perform the operation."
    name: "sourceUrl"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobRange\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRange\"></xref>"
    name: "sourceRange"
    type: "<xref href=\"com.azure.storage.blob.models.BlobRange?alt=com.azure.storage.blob.models.BlobRange&text=BlobRange\" data-throw-if-not-resolved=\"False\" />"
  - description: "An MD5 hash of the block content from the source blob. If specified, the service will\n calculate the MD5 of the received data and fail the request if it does not match the provided MD5."
    name: "sourceContentMD5"
    type: "<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]"
  - description: "<xref uid=\"com.azure.storage.blob.models.AppendBlobRequestConditions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobRequestConditions\"></xref>"
    name: "destRequestConditions"
    type: "<xref href=\"com.azure.storage.blob.models.AppendBlobRequestConditions?alt=com.azure.storage.blob.models.AppendBlobRequestConditions&text=AppendBlobRequestConditions\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobRequestConditions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions\"></xref>"
    name: "sourceRequestConditions"
    type: "<xref href=\"com.azure.storage.blob.models.BlobRequestConditions?alt=com.azure.storage.blob.models.BlobRequestConditions&text=BlobRequestConditions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<AppendBlobItem>> appendBlockFromUrlWithResponse(String sourceUrl, BlobRange sourceRange, byte[] sourceContentMD5, AppendBlobRequestConditions destRequestConditions, BlobRequestConditions sourceRequestConditions)"
  desc: "Commits a new block of data from another blob to the end of this append blob.\n\n**Code Samples**\n\n```java\nAppendBlobRequestConditions appendBlobRequestConditions = new AppendBlobRequestConditions()\n     .setAppendPosition(POSITION)\n     .setMaxSize(maxSize);\n\n BlobRequestConditions modifiedRequestConditions = new BlobRequestConditions()\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.appendBlockFromUrlWithResponse(sourceUrl, new BlobRange(offset, count), null,\n     appendBlobRequestConditions, modifiedRequestConditions).subscribe(response ->\n     System.out.printf(\"AppendBlob has %d committed blocks%n\", response.getValue().getBlobCommittedBlockCount()));\n```"
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> containing <xref uid=\"com.azure.core.http.rest.Response\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Response\"></xref> whose <xref uid=\"com.azure.core.http.rest.Response.getValue*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"value\"></xref> contains the append\n blob operation."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.AppendBlobItem?alt=com.azure.storage.blob.models.AppendBlobItem&text=AppendBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.appendBlockWithResponse(reactor.core.publisher.Flux<java.nio.ByteBuffer>,long,byte[],com.azure.storage.blob.models.AppendBlobRequestConditions)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.appendBlockWithResponse(Flux<ByteBuffer> data, long length, byte[] contentMd5, AppendBlobRequestConditions appendBlobRequestConditions)"
  name: "appendBlockWithResponse(Flux<ByteBuffer> data, long length, byte[] contentMd5, AppendBlobRequestConditions appendBlobRequestConditions)"
  nameWithType: "AppendBlobAsyncClient.appendBlockWithResponse(Flux<ByteBuffer> data, long length, byte[] contentMd5, AppendBlobRequestConditions appendBlobRequestConditions)"
  summary: "Commits a new block of data to the end of the existing append blob."
  parameters:
  - description: "The data to write to the blob. Note that this <code>Flux</code> must be replayable if retries are enabled\n (the default). In other words, the Flux must produce the same data each time it is subscribed to."
    name: "data"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "The exact length of the data. It is important that this value match precisely the length of the\n data emitted by the <code>Flux</code>."
    name: "length"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  - description: "An MD5 hash of the block content. This hash is used to verify the integrity of the block during\n transport. When this header is specified, the storage service compares the hash of the content that has arrived\n with this header value. Note that this MD5 hash is not stored with the blob. If the two hashes do not match, the\n operation will fail."
    name: "contentMd5"
    type: "<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]"
  - description: "<xref uid=\"com.azure.storage.blob.models.AppendBlobRequestConditions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobRequestConditions\"></xref>"
    name: "appendBlobRequestConditions"
    type: "<xref href=\"com.azure.storage.blob.models.AppendBlobRequestConditions?alt=com.azure.storage.blob.models.AppendBlobRequestConditions&text=AppendBlobRequestConditions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<AppendBlobItem>> appendBlockWithResponse(Flux<ByteBuffer> data, long length, byte[] contentMd5, AppendBlobRequestConditions appendBlobRequestConditions)"
  desc: "Commits a new block of data to the end of the existing append blob.\n\nNote that the data passed must be replayable if retries are enabled (the default). In other words, the `Flux` must produce the same data each time it is subscribed to.\n\n**Code Samples**\n\n```java\nbyte[] md5 = MessageDigest.getInstance(\"MD5\").digest(\"data\".getBytes(StandardCharsets.UTF_8));\n AppendBlobRequestConditions requestConditions = new AppendBlobRequestConditions()\n     .setAppendPosition(POSITION)\n     .setMaxSize(maxSize);\n\n client.appendBlockWithResponse(data, length, md5, requestConditions).subscribe(response ->\n     System.out.printf(\"AppendBlob has %d committed blocks%n\", response.getValue().getBlobCommittedBlockCount()));\n```"
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> containing <xref uid=\"com.azure.core.http.rest.Response\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Response\"></xref> whose <xref uid=\"com.azure.core.http.rest.Response.getValue*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"value\"></xref> contains the append\n blob operation."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.AppendBlobItem?alt=com.azure.storage.blob.models.AppendBlobItem&text=AppendBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.create()"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.create()"
  name: "create()"
  nameWithType: "AppendBlobAsyncClient.create()"
  summary: "Creates a 0-length append blob."
  syntax: "public Mono<AppendBlobItem> create()"
  desc: "Creates a 0-length append blob. Call appendBlock to append data to an append blob. By default this method will not overwrite an existing blob.\n\n**Code Samples**\n\n```java\nclient.create().subscribe(response ->\n     System.out.printf(\"Created AppendBlob at %s%n\", response.getLastModified()));\n```"
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> containing the information of the created appended blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.AppendBlobItem?alt=com.azure.storage.blob.models.AppendBlobItem&text=AppendBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.create(boolean)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.create(boolean overwrite)"
  name: "create(boolean overwrite)"
  nameWithType: "AppendBlobAsyncClient.create(boolean overwrite)"
  summary: "Creates a 0-length append blob."
  parameters:
  - description: "Whether to overwrite, should data exist on the blob."
    name: "overwrite"
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<AppendBlobItem> create(boolean overwrite)"
  desc: "Creates a 0-length append blob. Call appendBlock to append data to an append blob.\n\n**Code Samples**\n\n```java\nboolean overwrite = false; // Default behavior\n client.create(overwrite).subscribe(response ->\n     System.out.printf(\"Created AppendBlob at %s%n\", response.getLastModified()));\n```"
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> containing the information of the created appended blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.AppendBlobItem?alt=com.azure.storage.blob.models.AppendBlobItem&text=AppendBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.createIfNotExists()"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.createIfNotExists()"
  name: "createIfNotExists()"
  nameWithType: "AppendBlobAsyncClient.createIfNotExists()"
  summary: "Creates a 0-length append blob if it does not exist."
  syntax: "public Mono<AppendBlobItem> createIfNotExists()"
  desc: "Creates a 0-length append blob if it does not exist. Call appendBlock to append data to an append blob.\n\n**Code Samples**\n\n```java\nclient.createIfNotExists().subscribe(response ->\n     System.out.printf(\"Created AppendBlob at %s%n\", response.getLastModified()));\n```"
  returns:
    description: "A reactive response <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> signaling completion. <xref uid=\"com.azure.storage.blob.models.AppendBlobItem\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobItem\"></xref> contains the information of\n the created appended blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.AppendBlobItem?alt=com.azure.storage.blob.models.AppendBlobItem&text=AppendBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.createIfNotExistsWithResponse(com.azure.storage.blob.options.AppendBlobCreateOptions)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.createIfNotExistsWithResponse(AppendBlobCreateOptions options)"
  name: "createIfNotExistsWithResponse(AppendBlobCreateOptions options)"
  nameWithType: "AppendBlobAsyncClient.createIfNotExistsWithResponse(AppendBlobCreateOptions options)"
  summary: "Creates a 0-length append blob if it does not exist."
  parameters:
  - description: "<xref uid=\"com.azure.storage.blob.options.AppendBlobCreateOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobCreateOptions\"></xref>"
    name: "options"
    type: "<xref href=\"com.azure.storage.blob.options.AppendBlobCreateOptions?alt=com.azure.storage.blob.options.AppendBlobCreateOptions&text=AppendBlobCreateOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<AppendBlobItem>> createIfNotExistsWithResponse(AppendBlobCreateOptions options)"
  desc: "Creates a 0-length append blob if it does not exist. Call appendBlock to append data to an append blob.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentType(\"binary\")\n     .setContentLanguage(\"en-US\");\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n Map<String, String> tags = Collections.singletonMap(\"tag\", \"value\");\n\n client.createIfNotExistsWithResponse(new AppendBlobCreateOptions().setHeaders(headers)\n     .setMetadata(metadata).setTags(tags)).subscribe(response -> {\n         if (response.getStatusCode() == 409) {\n             System.out.println(\"Already exists.\");\n         } else {\n             System.out.println(\"successfully created.\");\n         }\n     });\n```"
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> containing <xref uid=\"com.azure.core.http.rest.Response\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Response\"></xref> signaling completion, whose <xref uid=\"com.azure.core.http.rest.Response.getValue*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"value\"></xref>\n contains a <xref uid=\"com.azure.storage.blob.models.AppendBlobItem\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobItem\"></xref> containing information about the append blob. If <xref uid=\"com.azure.core.http.rest.Response\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Response\"></xref>'s status code\n is 201, a new page blob was successfully created. If status code is 409, an append blob already existed at this\n location."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.AppendBlobItem?alt=com.azure.storage.blob.models.AppendBlobItem&text=AppendBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.createWithResponse(com.azure.storage.blob.models.BlobHttpHeaders,java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.BlobRequestConditions)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.createWithResponse(BlobHttpHeaders headers, Map<String,String> metadata, BlobRequestConditions requestConditions)"
  name: "createWithResponse(BlobHttpHeaders headers, Map<String,String> metadata, BlobRequestConditions requestConditions)"
  nameWithType: "AppendBlobAsyncClient.createWithResponse(BlobHttpHeaders headers, Map<String,String> metadata, BlobRequestConditions requestConditions)"
  summary: "Creates a 0-length append blob."
  parameters:
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobHttpHeaders\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobHttpHeaders\"></xref>"
    name: "headers"
    type: "<xref href=\"com.azure.storage.blob.models.BlobHttpHeaders?alt=com.azure.storage.blob.models.BlobHttpHeaders&text=BlobHttpHeaders\" data-throw-if-not-resolved=\"False\" />"
  - description: "Metadata to associate with the blob. If there is leading or trailing whitespace in any\n metadata key or value, it must be removed or encoded."
    name: "metadata"
    type: "<xref href=\"java.util.Map?alt=java.util.Map&text=Map\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />,<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobRequestConditions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions\"></xref>"
    name: "requestConditions"
    type: "<xref href=\"com.azure.storage.blob.models.BlobRequestConditions?alt=com.azure.storage.blob.models.BlobRequestConditions&text=BlobRequestConditions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<AppendBlobItem>> createWithResponse(BlobHttpHeaders headers, Map<String,String> metadata, BlobRequestConditions requestConditions)"
  desc: "Creates a 0-length append blob. Call appendBlock to append data to an append blob.\n\nTo avoid overwriting, pass \"\\*\" to <xref uid=\"com.azure.storage.blob.models.BlobRequestConditions.setIfNoneMatch(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions#setIfNoneMatch(String)\"></xref>.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentType(\"binary\")\n     .setContentLanguage(\"en-US\");\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n BlobRequestConditions requestConditions = new BlobRequestConditions().setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.createWithResponse(headers, metadata, requestConditions).subscribe(response ->\n     System.out.printf(\"Created AppendBlob at %s%n\", response.getValue().getLastModified()));\n```"
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> containing <xref uid=\"com.azure.core.http.rest.Response\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Response\"></xref> whose <xref uid=\"com.azure.core.http.rest.Response.getValue*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"value\"></xref> contains the created\n appended blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.AppendBlobItem?alt=com.azure.storage.blob.models.AppendBlobItem&text=AppendBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.createWithResponse(com.azure.storage.blob.options.AppendBlobCreateOptions)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.createWithResponse(AppendBlobCreateOptions options)"
  name: "createWithResponse(AppendBlobCreateOptions options)"
  nameWithType: "AppendBlobAsyncClient.createWithResponse(AppendBlobCreateOptions options)"
  summary: "Creates a 0-length append blob."
  parameters:
  - description: "<xref uid=\"com.azure.storage.blob.options.AppendBlobCreateOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobCreateOptions\"></xref>"
    name: "options"
    type: "<xref href=\"com.azure.storage.blob.options.AppendBlobCreateOptions?alt=com.azure.storage.blob.options.AppendBlobCreateOptions&text=AppendBlobCreateOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<AppendBlobItem>> createWithResponse(AppendBlobCreateOptions options)"
  desc: "Creates a 0-length append blob. Call appendBlock to append data to an append blob.\n\nTo avoid overwriting, pass \"\\*\" to <xref uid=\"com.azure.storage.blob.models.BlobRequestConditions.setIfNoneMatch(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions#setIfNoneMatch(String)\"></xref>.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentType(\"binary\")\n     .setContentLanguage(\"en-US\");\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n Map<String, String> tags = Collections.singletonMap(\"tag\", \"value\");\n BlobRequestConditions requestConditions = new BlobRequestConditions().setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.createWithResponse(new AppendBlobCreateOptions().setHeaders(headers).setMetadata(metadata)\n     .setTags(tags).setRequestConditions(requestConditions)).subscribe(response ->\n     System.out.printf(\"Created AppendBlob at %s%n\", response.getValue().getLastModified()));\n```"
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> containing <xref uid=\"com.azure.core.http.rest.Response\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Response\"></xref> whose <xref uid=\"com.azure.core.http.rest.Response.getValue*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"value\"></xref> contains the created\n appended blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.AppendBlobItem?alt=com.azure.storage.blob.models.AppendBlobItem&text=AppendBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.getCustomerProvidedKeyAsyncClient(com.azure.storage.blob.models.CustomerProvidedKey)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  name: "getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  nameWithType: "AppendBlobAsyncClient.getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  summary: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobAsyncClient\"></xref> with the specified `customerProvidedKey`."
  overridden: "com.azure.storage.blob.specialized.BlobAsyncClientBase.getCustomerProvidedKeyAsyncClient(com.azure.storage.blob.models.CustomerProvidedKey)"
  parameters:
  - description: "the <xref uid=\"com.azure.storage.blob.models.CustomerProvidedKey\" data-throw-if-not-resolved=\"false\" data-raw-source=\"CustomerProvidedKey\"></xref> for the blob,\n pass <code>null</code> to use no customer provided key."
    name: "customerProvidedKey"
    type: "<xref href=\"com.azure.storage.blob.models.CustomerProvidedKey?alt=com.azure.storage.blob.models.CustomerProvidedKey&text=CustomerProvidedKey\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public AppendBlobAsyncClient getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  desc: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobAsyncClient\"></xref> with the specified `customerProvidedKey`."
  returns:
    description: "a <xref uid=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobAsyncClient\"></xref> with the specified <code>customerProvidedKey</code>."
    type: "<xref href=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient?alt=com.azure.storage.blob.specialized.AppendBlobAsyncClient&text=AppendBlobAsyncClient\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.getEncryptionScopeAsyncClient(java.lang.String)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.getEncryptionScopeAsyncClient(String encryptionScope)"
  name: "getEncryptionScopeAsyncClient(String encryptionScope)"
  nameWithType: "AppendBlobAsyncClient.getEncryptionScopeAsyncClient(String encryptionScope)"
  summary: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobAsyncClient\"></xref> with the specified `encryptionScope`."
  overridden: "com.azure.storage.blob.specialized.BlobAsyncClientBase.getEncryptionScopeAsyncClient(java.lang.String)"
  parameters:
  - description: "the encryption scope for the blob, pass <code>null</code> to use no encryption scope."
    name: "encryptionScope"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public AppendBlobAsyncClient getEncryptionScopeAsyncClient(String encryptionScope)"
  desc: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobAsyncClient\"></xref> with the specified `encryptionScope`."
  returns:
    description: "a <xref uid=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobAsyncClient\"></xref> with the specified <code>encryptionScope</code>."
    type: "<xref href=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient?alt=com.azure.storage.blob.specialized.AppendBlobAsyncClient&text=AppendBlobAsyncClient\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.seal()"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.seal()"
  name: "seal()"
  nameWithType: "AppendBlobAsyncClient.seal()"
  summary: "Seals an append blob, making it read only."
  syntax: "public Mono<Void> seal()"
  desc: "Seals an append blob, making it read only. Any subsequent appends will fail.\n\n**Code Samples**\n\n```java\nclient.seal().subscribe(response -> System.out.println(\"Sealed AppendBlob\"));\n```"
  returns:
    description: "A reactive response signalling completion."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.sealWithResponse(com.azure.storage.blob.options.AppendBlobSealOptions)"
  fullName: "com.azure.storage.blob.specialized.AppendBlobAsyncClient.sealWithResponse(AppendBlobSealOptions options)"
  name: "sealWithResponse(AppendBlobSealOptions options)"
  nameWithType: "AppendBlobAsyncClient.sealWithResponse(AppendBlobSealOptions options)"
  summary: "Seals an append blob, making it read only."
  parameters:
  - description: "<xref uid=\"com.azure.storage.blob.options.AppendBlobSealOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobSealOptions\"></xref>"
    name: "options"
    type: "<xref href=\"com.azure.storage.blob.options.AppendBlobSealOptions?alt=com.azure.storage.blob.options.AppendBlobSealOptions&text=AppendBlobSealOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<Void>> sealWithResponse(AppendBlobSealOptions options)"
  desc: "Seals an append blob, making it read only. Any subsequent appends will fail.\n\n**Code Samples**\n\n```java\nAppendBlobRequestConditions requestConditions = new AppendBlobRequestConditions().setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.sealWithResponse(new AppendBlobSealOptions().setRequestConditions(requestConditions))\n     .subscribe(response -> System.out.println(\"Sealed AppendBlob\"));\n```"
  returns:
    description: "A reactive response signalling completion."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
type: "class"
desc: "Client to an append blob. It may only be instantiated through a <xref uid=\"com.azure.storage.blob.specialized.SpecializedBlobClientBuilder.buildAppendBlobAsyncClient()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SpecializedBlobClientBuilder#buildAppendBlobAsyncClient()\"></xref> or via the method <xref uid=\"com.azure.storage.blob.BlobAsyncClient.getAppendBlobAsyncClient()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient#getAppendBlobAsyncClient()\"></xref>. This class does not hold any state about a particular blob, but is instead a convenient way of sending appropriate requests to the resource on the service.\n\nThis client contains operations on a blob. Operations on a container are available on <xref uid=\"com.azure.storage.blob.BlobContainerAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobContainerAsyncClient\"></xref>, and operations on the service are available on <xref uid=\"com.azure.storage.blob.BlobServiceAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobServiceAsyncClient\"></xref>.\n\nPlease refer to the [Azure Docs][] for more information.\n\nNote this client is an async client that returns reactive responses from Spring Reactor Core project (https://projectreactor.io/). Calling the methods in this client will **NOT** start the actual network operation, until `.subscribe()` is called on the reactive response. You can simply convert one of these responses to a <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"java.util.concurrent.CompletableFuture\"></xref> object through <xref uid=\"reactor.core.publisher.Mono.toFuture*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono#toFuture()\"></xref>.\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs"
metadata: {}
package: "com.azure.storage.blob.specialized"
artifact: com.azure:azure-storage-blob:12.19.0
