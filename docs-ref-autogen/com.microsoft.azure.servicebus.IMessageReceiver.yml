### YamlMime:ManagedReference
items:
- uid: com.microsoft.azure.servicebus.IMessageReceiver
  id: IMessageReceiver
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus
  children:
  - com.microsoft.azure.servicebus.IMessageReceiver.abandon(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageReceiver.abandon(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageReceiver.abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.complete(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageReceiver.complete(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.completeAsync(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageReceiver.completeAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.lang.String,java.lang.String)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.defer(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageReceiver.defer(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.defer(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageReceiver.defer(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageReceiver.getPrefetchCount()
  - com.microsoft.azure.servicebus.IMessageReceiver.getReceiveMode()
  - com.microsoft.azure.servicebus.IMessageReceiver.receive()
  - com.microsoft.azure.servicebus.IMessageReceiver.receive(java.time.Duration)
  - com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync()
  - com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync(java.time.Duration)
  - com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch(int)
  - com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch(int,java.time.Duration)
  - com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync(int)
  - com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync(int,java.time.Duration)
  - com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessage(long)
  - com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageAsync(long)
  - com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatch(java.util.Collection<java.lang.Long>)
  - com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatchAsync(java.util.Collection<java.lang.Long>)
  - com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock(com.microsoft.azure.servicebus.IMessage)
  - com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync(com.microsoft.azure.servicebus.IMessage)
  - com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageReceiver.setPrefetchCount(int)
  langs:
  - java
  name: IMessageReceiver
  nameWithType: IMessageReceiver
  fullName: com.microsoft.azure.servicebus.IMessageReceiver
  type: Interface
  package: com.microsoft.azure.servicebus
  summary: Defines message receiver interface. The MessageReceiver can be used to receive messages from Queues and Subscriptions and acknowledge them.
  syntax:
    content: public interface IMessageReceiver extends IMessageEntityClient, IMessageBrowser
  implements:
  - com.microsoft.azure.servicebus.IMessageEntityClient
  - com.microsoft.azure.servicebus.IMessageBrowser
- uid: com.microsoft.azure.servicebus.IMessageReceiver.abandon(java.util.UUID)
  id: abandon(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: abandon(UUID lockToken)
  nameWithType: IMessageReceiver.abandon(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.abandon*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message
  syntax:
    content: public abstract void abandon(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.abandon(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: abandon(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: abandon(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.abandon(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.abandon*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message
  syntax:
    content: public abstract void abandon(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  id: abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: abandon(UUID lockToken, Map<String,Object> propertiesToModify)
  nameWithType: IMessageReceiver.abandon(UUID lockToken, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID lockToken, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.abandon*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message
  syntax:
    content: public abstract void abandon(UUID lockToken, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: abandon(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.abandon(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.abandon*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message
  syntax:
    content: public abstract void abandon(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(java.util.UUID)
  id: abandonAsync(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: abandonAsync(UUID lockToken)
  nameWithType: IMessageReceiver.abandonAsync(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.
  syntax:
    content: public abstract CompletableFuture<Void> abandonAsync(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending abandon.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: abandonAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: abandonAsync(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.abandonAsync(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.
  syntax:
    content: public abstract CompletableFuture<Void> abandonAsync(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending abandon.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  id: abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  nameWithType: IMessageReceiver.abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.
  syntax:
    content: public abstract CompletableFuture<Void> abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending abandon.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.
  syntax:
    content: public abstract CompletableFuture<Void> abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending abandon.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.complete(java.util.UUID)
  id: complete(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: complete(UUID lockToken)
  nameWithType: IMessageReceiver.complete(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.complete(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.complete*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will delete the message from the service.
  syntax:
    content: public abstract void complete(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.complete(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: complete(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: complete(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.complete(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.complete(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.complete*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will delete the message from the service.
  syntax:
    content: public abstract void complete(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync(java.util.UUID)
  id: completeAsync(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: completeAsync(UUID lockToken)
  nameWithType: IMessageReceiver.completeAsync(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will delete the message from the service.
  syntax:
    content: public abstract CompletableFuture<Void> completeAsync(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending complete.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: completeAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: completeAsync(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.completeAsync(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will delete the message from the service.
  syntax:
    content: public abstract CompletableFuture<Void> completeAsync(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending complete.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID)
  id: deadLetter(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetter(UUID lockToken)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue.
  syntax:
    content: public abstract void deadLetter(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetter(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetter(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.lang.String,java.lang.String)
  id: deadLetter(java.util.UUID,java.lang.String,java.lang.String)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetter(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  id: deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  id: deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetter(UUID lockToken, Map<String,Object> propertiesToModify)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with modified message properties.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetter(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with modified message properties.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID)
  id: deadLetterAsync(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetterAsync(UUID lockToken)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetterAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String)
  id: deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  id: deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  id: deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with modified properties.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with modified properties.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.defer(java.util.UUID)
  id: defer(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: defer(UUID lockToken)
  nameWithType: IMessageReceiver.defer(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.defer*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will move message into deferred subqueue.
  syntax:
    content: public abstract void defer(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.defer(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: defer(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: defer(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.defer(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.defer*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will move message into deferred subqueue.
  syntax:
    content: public abstract void defer(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.defer(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  id: defer(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: defer(UUID lockToken, Map<String,Object> propertiesToModify)
  nameWithType: IMessageReceiver.defer(UUID lockToken, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID lockToken, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.defer*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token with modified message property. This will move message into deferred subqueue.
  syntax:
    content: public abstract void defer(UUID lockToken, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.defer(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: defer(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: defer(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.defer(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.defer*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token with modified message property. This will move message into deferred subqueue.
  syntax:
    content: public abstract void defer(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(java.util.UUID)
  id: deferAsync(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deferAsync(UUID lockToken)
  nameWithType: IMessageReceiver.deferAsync(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will move message into deferred subqueue.
  syntax:
    content: public abstract CompletableFuture<Void> deferAsync(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending defer.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: deferAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deferAsync(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.deferAsync(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will move message into deferred subqueue.
  syntax:
    content: public abstract CompletableFuture<Void> deferAsync(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending defer.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  id: deferAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deferAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  nameWithType: IMessageReceiver.deferAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token with modified message propert. This will move message into deferred subqueue.
  syntax:
    content: public abstract CompletableFuture<Void> deferAsync(UUID lockToken, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending defer.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: deferAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: deferAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.deferAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token with modified message propert. This will move message into deferred subqueue.
  syntax:
    content: public abstract CompletableFuture<Void> deferAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending defer.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.getPrefetchCount()
  id: getPrefetchCount()
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: getPrefetchCount()
  nameWithType: IMessageReceiver.getPrefetchCount()
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.getPrefetchCount()
  overload: com.microsoft.azure.servicebus.IMessageReceiver.getPrefetchCount*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Get the prefetch value set.
  syntax:
    content: public abstract int getPrefetchCount()
    return:
      type: int
      description: The set prefetch count value.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.getReceiveMode()
  id: getReceiveMode()
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: getReceiveMode()
  nameWithType: IMessageReceiver.getReceiveMode()
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.getReceiveMode()
  overload: com.microsoft.azure.servicebus.IMessageReceiver.getReceiveMode*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Get current receiver's <xref uid="com.microsoft.azure.servicebus.ReceiveMode" data-throw-if-not-resolved="false">ReceiveMode</xref>.
  syntax:
    content: public abstract ReceiveMode getReceiveMode()
    return:
      type: com.microsoft.azure.servicebus.ReceiveMode
      description: <xref uid="com.microsoft.azure.servicebus.ReceiveMode" data-throw-if-not-resolved="false">ReceiveMode</xref>
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receive()
  id: receive()
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receive()
  nameWithType: IMessageReceiver.receive()
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receive()
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receive*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receives a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with default server wait time.
  syntax:
    content: public abstract IMessage receive()
    return:
      type: com.microsoft.azure.servicebus.IMessage
      description: The received <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> or null if there is no message.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receive(java.time.Duration)
  id: receive(java.time.Duration)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receive(Duration serverWaitTime)
  nameWithType: IMessageReceiver.receive(Duration serverWaitTime)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receive(Duration serverWaitTime)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receive*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receives a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with specified server wait time.
  syntax:
    content: public abstract IMessage receive(Duration serverWaitTime)
    parameters:
    - id: serverWaitTime
      type: java.time.Duration
      description: The server wait time
    return:
      type: com.microsoft.azure.servicebus.IMessage
      description: The received <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> or null if there is no message.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync()
  id: receiveAsync()
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receiveAsync()
  nameWithType: IMessageReceiver.receiveAsync()
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync()
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receives a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> from Azure Service Bus.
  syntax:
    content: public abstract CompletableFuture<IMessage> receiveAsync()
    return:
      type: java.util.concurrent.CompletableFuture<com.microsoft.azure.servicebus.IMessage>
      description: The message received. Returns null if no message is found
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync(java.time.Duration)
  id: receiveAsync(java.time.Duration)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receiveAsync(Duration serverWaitTime)
  nameWithType: IMessageReceiver.receiveAsync(Duration serverWaitTime)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync(Duration serverWaitTime)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receives a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> from Azure Service Bus with server wait time.
  syntax:
    content: public abstract CompletableFuture<IMessage> receiveAsync(Duration serverWaitTime)
    parameters:
    - id: serverWaitTime
      type: java.time.Duration
      description: The time the client waits for receiving a message before it times out.
    return:
      type: java.util.concurrent.CompletableFuture<com.microsoft.azure.servicebus.IMessage>
      description: The message received. Returns null if no message is found
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch(int)
  id: receiveBatch(int)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receiveBatch(int maxMessageCount)
  nameWithType: IMessageReceiver.receiveBatch(int maxMessageCount)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch(int maxMessageCount)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receives a maximum of maxMessageCount <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> from Azure Service Bus.
  syntax:
    content: public abstract Collection<IMessage> receiveBatch(int maxMessageCount)
    parameters:
    - id: maxMessageCount
      type: int
      description: The maximum number of messages that will be received.
    return:
      type: java.util.Collection<com.microsoft.azure.servicebus.IMessage>
      description: List of messages received. Returns null if no message is found.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch(int,java.time.Duration)
  id: receiveBatch(int,java.time.Duration)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receiveBatch(int maxMessageCount, Duration serverWaitTime)
  nameWithType: IMessageReceiver.receiveBatch(int maxMessageCount, Duration serverWaitTime)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch(int maxMessageCount, Duration serverWaitTime)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receives a maximum of maxMessageCount <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> from Azure Service Bus with server wait time.
  syntax:
    content: public abstract Collection<IMessage> receiveBatch(int maxMessageCount, Duration serverWaitTime)
    parameters:
    - id: maxMessageCount
      type: int
      description: The maximum number of messages that will be received.
    - id: serverWaitTime
      type: java.time.Duration
      description: The time the client waits for receiving a message before it times out.
    return:
      type: java.util.Collection<com.microsoft.azure.servicebus.IMessage>
      description: List of messages received. Returns null if no message is found.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync(int)
  id: receiveBatchAsync(int)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receiveBatchAsync(int maxMessageCount)
  nameWithType: IMessageReceiver.receiveBatchAsync(int maxMessageCount)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync(int maxMessageCount)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously receives a maximum of maxMessageCount <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> from the entity.
  syntax:
    content: public abstract CompletableFuture<Collection<IMessage>> receiveBatchAsync(int maxMessageCount)
    parameters:
    - id: maxMessageCount
      type: int
      description: The maximum number of messages that will be received.
    return:
      type: java.util.concurrent.CompletableFuture<java.util.Collection<com.microsoft.azure.servicebus.IMessage>>
      description: a CompletableFuture representing the pending receive.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync(int,java.time.Duration)
  id: receiveBatchAsync(int,java.time.Duration)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receiveBatchAsync(int maxMessageCount, Duration serverWaitTime)
  nameWithType: IMessageReceiver.receiveBatchAsync(int maxMessageCount, Duration serverWaitTime)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync(int maxMessageCount, Duration serverWaitTime)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously receives a maximum of maxMessageCount <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> from Azure Service Bus with server wait time.
  syntax:
    content: public abstract CompletableFuture<Collection<IMessage>> receiveBatchAsync(int maxMessageCount, Duration serverWaitTime)
    parameters:
    - id: maxMessageCount
      type: int
      description: The maximum number of messages that will be received.
    - id: serverWaitTime
      type: java.time.Duration
      description: The time the client waits for receiving a message before it times out.
    return:
      type: java.util.concurrent.CompletableFuture<java.util.Collection<com.microsoft.azure.servicebus.IMessage>>
      description: a CompletableFuture representing the pending receive.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessage(long)
  id: receiveDeferredMessage(long)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receiveDeferredMessage(long sequenceNumber)
  nameWithType: IMessageReceiver.receiveDeferredMessage(long sequenceNumber)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessage(long sequenceNumber)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessage*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receives a deferred <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref>. Deferred messages can only be received by using sequence number.
  syntax:
    content: public abstract IMessage receiveDeferredMessage(long sequenceNumber)
    parameters:
    - id: sequenceNumber
      type: long
      description: The <xref uid="com.microsoft.azure.servicebus.Message.getSequenceNumber()" data-throw-if-not-resolved="false">Message#getSequenceNumber()</xref>.
    return:
      type: com.microsoft.azure.servicebus.IMessage
      description: The received <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> or null if there is no message for given sequence number.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageAsync(long)
  id: receiveDeferredMessageAsync(long)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receiveDeferredMessageAsync(long sequenceNumber)
  nameWithType: IMessageReceiver.receiveDeferredMessageAsync(long sequenceNumber)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageAsync(long sequenceNumber)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously receives a specific deferred <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> identified by sequence number.
  syntax:
    content: public abstract CompletableFuture<IMessage> receiveDeferredMessageAsync(long sequenceNumber)
    parameters:
    - id: sequenceNumber
      type: long
      description: The sequence number of the message that will be received.
    return:
      type: java.util.concurrent.CompletableFuture<com.microsoft.azure.servicebus.IMessage>
      description: a CompletableFuture representing the pending receive.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatch(java.util.Collection<java.lang.Long>)
  id: receiveDeferredMessageBatch(java.util.Collection<java.lang.Long>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receiveDeferredMessageBatch(Collection<Long> sequenceNumbers)
  nameWithType: IMessageReceiver.receiveDeferredMessageBatch(Collection<Long> sequenceNumbers)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatch(Collection<Long> sequenceNumbers)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatch*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receives a batch of deferred <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref>.
  syntax:
    content: public abstract Collection<IMessage> receiveDeferredMessageBatch(Collection<Long> sequenceNumbers)
    parameters:
    - id: sequenceNumbers
      type: java.util.Collection<java.lang.Long>
      description: The sequence numbers of desired deferred messages.
    return:
      type: java.util.Collection<com.microsoft.azure.servicebus.IMessage>
      description: List of messages received. Returns null if no message is found.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatchAsync(java.util.Collection<java.lang.Long>)
  id: receiveDeferredMessageBatchAsync(java.util.Collection<java.lang.Long>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: receiveDeferredMessageBatchAsync(Collection<Long> sequenceNumbers)
  nameWithType: IMessageReceiver.receiveDeferredMessageBatchAsync(Collection<Long> sequenceNumbers)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatchAsync(Collection<Long> sequenceNumbers)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatchAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously receives a set of deferred <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> from the entity.
  syntax:
    content: public abstract CompletableFuture<Collection<IMessage>> receiveDeferredMessageBatchAsync(Collection<Long> sequenceNumbers)
    parameters:
    - id: sequenceNumbers
      type: java.util.Collection<java.lang.Long>
      description: The sequence numbers of the message that will be received.
    return:
      type: java.util.concurrent.CompletableFuture<java.util.Collection<com.microsoft.azure.servicebus.IMessage>>
      description: a CompletableFuture representing the pending receive.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock(com.microsoft.azure.servicebus.IMessage)
  id: renewMessageLock(com.microsoft.azure.servicebus.IMessage)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: renewMessageLock(IMessage message)
  nameWithType: IMessageReceiver.renewMessageLock(IMessage message)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock(IMessage message)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Renews the lock on the message specified by the lock token. The lock will be renewed based on the setting specified on the entity. When a message is received in <xref uid="com.microsoft.azure.servicebus.ReceiveMode.PEEKLOCK" data-throw-if-not-resolved="false">ReceiveMode#PEEKLOCK</xref> mode, the message is locked on the server for this receiver instance for a duration as specified during the Queue/Subscription creation (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to the entity's LockDuration value.
  syntax:
    content: public abstract Instant renewMessageLock(IMessage message)
    parameters:
    - id: message
      type: com.microsoft.azure.servicebus.IMessage
      description: The <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to be renewed
    return:
      type: java.time.Instant
      description: The new locked until UTC time.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock(java.util.UUID)
  id: renewMessageLock(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: renewMessageLock(UUID lockToken)
  nameWithType: IMessageReceiver.renewMessageLock(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Renews the lock on the message specified by the lock token. The lock will be renewed based on the setting specified on the entity. When a message is received in <xref uid="com.microsoft.azure.servicebus.ReceiveMode.PEEKLOCK" data-throw-if-not-resolved="false">ReceiveMode#PEEKLOCK</xref> mode, the message is locked on the server for this receiver instance for a duration as specified during the Queue/Subscription creation (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to the entity's LockDuration value. Note - calling this will not update <xref uid="com.microsoft.azure.servicebus.Message.getLockedUntilUtc()" data-throw-if-not-resolved="false">Message#getLockedUntilUtc()</xref> and updated lockedUntilUtc must be tracked by the application.
  syntax:
    content: public abstract Instant renewMessageLock(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    return:
      type: java.time.Instant
      description: The new locked until UTC time.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync(com.microsoft.azure.servicebus.IMessage)
  id: renewMessageLockAsync(com.microsoft.azure.servicebus.IMessage)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: renewMessageLockAsync(IMessage message)
  nameWithType: IMessageReceiver.renewMessageLockAsync(IMessage message)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync(IMessage message)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously renews the lock on the message specified by the lock token. The lock will be renewed based on the setting specified on the entity. When a message is received in <xref uid="com.microsoft.azure.servicebus.ReceiveMode.PEEKLOCK" data-throw-if-not-resolved="false">ReceiveMode#PEEKLOCK</xref> mode, the message is locked on the server for this receiver instance for a duration as specified during the Queue/Subscription creation (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to the entity's LockDuration value.
  syntax:
    content: public abstract CompletableFuture<Instant> renewMessageLockAsync(IMessage message)
    parameters:
    - id: message
      type: com.microsoft.azure.servicebus.IMessage
      description: The <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to be renewed
    return:
      type: java.util.concurrent.CompletableFuture<java.time.Instant>
      description: a CompletableFuture representing the pending renew.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync(java.util.UUID)
  id: renewMessageLockAsync(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: renewMessageLockAsync(UUID lockToken)
  nameWithType: IMessageReceiver.renewMessageLockAsync(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Renews the lock on the message specified by the lock token. The lock will be renewed based on the setting specified on the entity. When a message is received in <xref uid="com.microsoft.azure.servicebus.ReceiveMode.PEEKLOCK" data-throw-if-not-resolved="false">ReceiveMode#PEEKLOCK</xref> mode, the message is locked on the server for this receiver instance for a duration as specified during the Queue/Subscription creation (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to the entity's LockDuration value. Note - calling this will not update <xref uid="com.microsoft.azure.servicebus.Message.getLockedUntilUtc()" data-throw-if-not-resolved="false">Message#getLockedUntilUtc()</xref> and updated lockedUntilUtc must be tracked by the application.
  syntax:
    content: public abstract CompletableFuture<Instant> renewMessageLockAsync(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    return:
      type: java.util.concurrent.CompletableFuture<java.time.Instant>
      description: a CompletableFuture representing the pending renew.
- uid: com.microsoft.azure.servicebus.IMessageReceiver.setPrefetchCount(int)
  id: setPrefetchCount(int)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageReceiver
  langs:
  - java
  name: setPrefetchCount(int prefetchCount)
  nameWithType: IMessageReceiver.setPrefetchCount(int prefetchCount)
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.setPrefetchCount(int prefetchCount)
  overload: com.microsoft.azure.servicebus.IMessageReceiver.setPrefetchCount*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: >-
    Set the prefetch count of the receiver. Prefetch speeds up the message flow by aiming to have a message readily available for local retrieval when and before the application asks for one using Receive. Setting a non-zero value prefetches PrefetchCount number of messages. Setting the value to zero turns prefetch off. For both PEEKLOCK mode and RECEIVEANDDELETE mode, the default value is 0.


    The value cannot be set until the receiver is created.
  syntax:
    content: public abstract void setPrefetchCount(int prefetchCount)
    parameters:
    - id: prefetchCount
      type: int
      description: The desired prefetch count.
  exceptions:
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if sets the value failed
references:
- uid: com.microsoft.azure.servicebus.ReceiveMode
  name: ReceiveMode
  nameWithType: ReceiveMode
  fullName: com.microsoft.azure.servicebus.ReceiveMode
- uid: com.microsoft.azure.servicebus.IMessageReceiver.getReceiveMode*
  name: getReceiveMode
  nameWithType: IMessageReceiver.getReceiveMode
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.getReceiveMode
  package: com.microsoft.azure.servicebus
- uid: java.lang.InterruptedException
  spec.java:
  - uid: java.lang.InterruptedException
    name: InterruptedException
    fullName: java.lang.InterruptedException
- uid: com.microsoft.azure.servicebus.primitives.ServiceBusException
  name: ServiceBusException
  nameWithType: ServiceBusException
  fullName: com.microsoft.azure.servicebus.primitives.ServiceBusException
- uid: java.util.UUID
  spec.java:
  - uid: java.util.UUID
    name: UUID
    fullName: java.util.UUID
- uid: com.microsoft.azure.servicebus.IMessageReceiver.abandon*
  name: abandon
  nameWithType: IMessageReceiver.abandon
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandon
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.TransactionContext
  name: TransactionContext
  nameWithType: TransactionContext
  fullName: com.microsoft.azure.servicebus.TransactionContext
- uid: java.util.Map<java.lang.String,java.lang.Object>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: java.lang.String
    name: String
    fullName: java.lang.String
  - name: ','
    fullName: ','
  - uid: java.lang.Object
    name: Object
    fullName: java.lang.Object
  - name: '>'
    fullName: '>'
- uid: java.util.concurrent.CompletableFuture<java.lang.Void>
  spec.java:
  - uid: java.util.concurrent.CompletableFuture
    name: CompletableFuture
    fullName: java.util.concurrent.CompletableFuture
  - name: <
    fullName: <
  - uid: java.lang.Void
    name: Void
    fullName: java.lang.Void
  - name: '>'
    fullName: '>'
- uid: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync*
  name: abandonAsync
  nameWithType: IMessageReceiver.abandonAsync
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageReceiver.complete*
  name: complete
  nameWithType: IMessageReceiver.complete
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.complete
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync*
  name: completeAsync
  nameWithType: IMessageReceiver.completeAsync
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageReceiver.defer*
  name: defer
  nameWithType: IMessageReceiver.defer
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.defer
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync*
  name: deferAsync
  nameWithType: IMessageReceiver.deferAsync
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter*
  name: deadLetter
  nameWithType: IMessageReceiver.deadLetter
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter
  package: com.microsoft.azure.servicebus
- uid: java.lang.String
  spec.java:
  - uid: java.lang.String
    name: String
    fullName: java.lang.String
- uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync*
  name: deadLetterAsync
  nameWithType: IMessageReceiver.deadLetterAsync
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessage
  name: IMessage
  nameWithType: IMessage
  fullName: com.microsoft.azure.servicebus.IMessage
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receive*
  name: receive
  nameWithType: IMessageReceiver.receive
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receive
  package: com.microsoft.azure.servicebus
- uid: java.time.Duration
  spec.java:
  - uid: java.time.Duration
    name: Duration
    fullName: java.time.Duration
- uid: long
  spec.java:
  - uid: long
    name: long
    fullName: long
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessage*
  name: receiveDeferredMessage
  nameWithType: IMessageReceiver.receiveDeferredMessage
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessage
  package: com.microsoft.azure.servicebus
- uid: int
  spec.java:
  - uid: int
    name: int
    fullName: int
- uid: java.util.Collection<com.microsoft.azure.servicebus.IMessage>
  spec.java:
  - uid: java.util.Collection
    name: Collection
    fullName: java.util.Collection
  - name: <
    fullName: <
  - uid: com.microsoft.azure.servicebus.IMessage
    name: IMessage
    fullName: com.microsoft.azure.servicebus.IMessage
  - name: '>'
    fullName: '>'
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch*
  name: receiveBatch
  nameWithType: IMessageReceiver.receiveBatch
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch
  package: com.microsoft.azure.servicebus
- uid: java.util.Collection<java.lang.Long>
  spec.java:
  - uid: java.util.Collection
    name: Collection
    fullName: java.util.Collection
  - name: <
    fullName: <
  - uid: java.lang.Long
    name: Long
    fullName: java.lang.Long
  - name: '>'
    fullName: '>'
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatch*
  name: receiveDeferredMessageBatch
  nameWithType: IMessageReceiver.receiveDeferredMessageBatch
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatch
  package: com.microsoft.azure.servicebus
- uid: java.util.concurrent.CompletableFuture<com.microsoft.azure.servicebus.IMessage>
  spec.java:
  - uid: java.util.concurrent.CompletableFuture
    name: CompletableFuture
    fullName: java.util.concurrent.CompletableFuture
  - name: <
    fullName: <
  - uid: com.microsoft.azure.servicebus.IMessage
    name: IMessage
    fullName: com.microsoft.azure.servicebus.IMessage
  - name: '>'
    fullName: '>'
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync*
  name: receiveAsync
  nameWithType: IMessageReceiver.receiveAsync
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageAsync*
  name: receiveDeferredMessageAsync
  nameWithType: IMessageReceiver.receiveDeferredMessageAsync
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageAsync
  package: com.microsoft.azure.servicebus
- uid: java.util.concurrent.CompletableFuture<java.util.Collection<com.microsoft.azure.servicebus.IMessage>>
  spec.java:
  - uid: java.util.concurrent.CompletableFuture
    name: CompletableFuture
    fullName: java.util.concurrent.CompletableFuture
  - name: <
    fullName: <
  - uid: java.util.Collection
    name: Collection
    fullName: java.util.Collection
  - name: <
    fullName: <
  - uid: com.microsoft.azure.servicebus.IMessage
    name: IMessage
    fullName: com.microsoft.azure.servicebus.IMessage
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync*
  name: receiveBatchAsync
  nameWithType: IMessageReceiver.receiveBatchAsync
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatchAsync*
  name: receiveDeferredMessageBatchAsync
  nameWithType: IMessageReceiver.receiveDeferredMessageBatchAsync
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatchAsync
  package: com.microsoft.azure.servicebus
- uid: java.util.concurrent.CompletableFuture<java.time.Instant>
  spec.java:
  - uid: java.util.concurrent.CompletableFuture
    name: CompletableFuture
    fullName: java.util.concurrent.CompletableFuture
  - name: <
    fullName: <
  - uid: java.time.Instant
    name: Instant
    fullName: java.time.Instant
  - name: '>'
    fullName: '>'
- uid: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync*
  name: renewMessageLockAsync
  nameWithType: IMessageReceiver.renewMessageLockAsync
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync
  package: com.microsoft.azure.servicebus
- uid: java.time.Instant
  spec.java:
  - uid: java.time.Instant
    name: Instant
    fullName: java.time.Instant
- uid: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock*
  name: renewMessageLock
  nameWithType: IMessageReceiver.renewMessageLock
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageReceiver.getPrefetchCount*
  name: getPrefetchCount
  nameWithType: IMessageReceiver.getPrefetchCount
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.getPrefetchCount
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageReceiver.setPrefetchCount*
  name: setPrefetchCount
  nameWithType: IMessageReceiver.setPrefetchCount
  fullName: com.microsoft.azure.servicebus.IMessageReceiver.setPrefetchCount
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageEntityClient
  name: IMessageEntityClient
  nameWithType: IMessageEntityClient
  fullName: com.microsoft.azure.servicebus.IMessageEntityClient
- uid: com.microsoft.azure.servicebus.IMessageBrowser
  name: IMessageBrowser
  nameWithType: IMessageBrowser
  fullName: com.microsoft.azure.servicebus.IMessageBrowser
- uid: java.lang.String,java.lang.Object
  name: String,Object
  nameWithType: String,Object
  fullName: java.lang.String,java.lang.Object
- uid: java.util.Map
  name: Map
  nameWithType: Map
  fullName: java.util.Map
- uid: java.lang.Void
  name: Void
  nameWithType: Void
  fullName: java.lang.Void
- uid: java.util.concurrent.CompletableFuture
  name: CompletableFuture
  nameWithType: CompletableFuture
  fullName: java.util.concurrent.CompletableFuture
- uid: java.util.Collection
  name: Collection
  nameWithType: Collection
  fullName: java.util.Collection
- uid: java.lang.Long
  name: Long
  nameWithType: Long
  fullName: java.lang.Long
