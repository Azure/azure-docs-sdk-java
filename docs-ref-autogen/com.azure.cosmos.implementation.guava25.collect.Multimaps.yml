### YamlMime:ManagedReference
items:
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps
  id: Multimaps
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect
  children:
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V,M>invertFrom(com.azure.cosmos.implementation.guava25.collect.Multimap<? extends V,? extends K>,M)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformEntries(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformEntries(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformValues(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformValues(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterEntries(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterEntries(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterValues(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterValues(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>forMap(java.util.Map<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>index(java.lang.Iterable<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>index(java.util.Iterator<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newListMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.List<V>>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.Collection<V>>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newSetMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.Set<V>>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newSortedSetMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.SortedSet<V>>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedListMultimap(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedMultimap(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedSetMultimap(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedSortedSetMultimap(com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableListMultimap(com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableListMultimap(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableMultimap(com.azure.cosmos.implementation.guava25.collect.ImmutableMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableMultimap(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableSetMultimap(com.azure.cosmos.implementation.guava25.collect.ImmutableSetMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableSetMultimap(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableSortedSetMultimap(com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<T,K,V,M>flatteningToMultimap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends java.util.stream.Stream<? extends V>>,java.util.function.Supplier<M>)
  - com.azure.cosmos.implementation.guava25.collect.Multimaps.<T,K,V,M>toMultimap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>,java.util.function.Supplier<M>)
  langs:
  - java
  name: Multimaps
  nameWithType: Multimaps
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps
  type: Class
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Provides static methods acting on or generating a `Multimap`.


    See the Guava User Guide article on [ `Multimaps`][_Multimaps].



    [_Multimaps]: https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multimaps
  syntax:
    content: public final class Multimaps
  inheritance:
  - java.lang.Object
  inheritedMembers:
  - java.lang.Object.clone()
  - java.lang.Object.equals(java.lang.Object)
  - java.lang.Object.finalize()
  - java.lang.Object.getClass()
  - java.lang.Object.hashCode()
  - java.lang.Object.notify()
  - java.lang.Object.notifyAll()
  - java.lang.Object.toString()
  - java.lang.Object.wait()
  - java.lang.Object.wait(long)
  - java.lang.Object.wait(long,int)
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V,M>invertFrom(com.azure.cosmos.implementation.guava25.collect.Multimap<? extends V,? extends K>,M)
  id: <K,V,M>invertFrom(com.azure.cosmos.implementation.guava25.collect.Multimap<? extends V,? extends K>,M)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V,M>invertFrom(Multimap<? extends V,? extends K> source, M dest)
  nameWithType: Multimaps.<K,V,M>invertFrom(Multimap<? extends V,? extends K> source, M dest)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V,M>invertFrom(Multimap<? extends V,? extends K> source, M dest)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.invertFrom*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Copies each key-value mapping in `source` into `dest`, with its key and value reversed.


    If `source` is an <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableMultimap" data-throw-if-not-resolved="false">ImmutableMultimap</xref>, consider using <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableMultimap.inverse" data-throw-if-not-resolved="false">ImmutableMultimap#inverse</xref> instead.
  syntax:
    content: public static M <K,V,M>invertFrom(Multimap<? extends V,? extends K> source, M dest)
    parameters:
    - id: source
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<? extends V,? extends K>
      description: any multimap
    - id: dest
      type: M
      description: the multimap to copy into; usually empty
    return:
      type: M
      description: <code>dest</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformEntries(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  id: <K,V1,V2>transformEntries(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V1,V2>transformEntries(ListMultimap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  nameWithType: Multimaps.<K,V1,V2>transformEntries(ListMultimap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformEntries(ListMultimap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.transformEntries*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of a `ListMultimap` whose values are derived from the original multimap's entries. In contrast to <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.&lt;K,V1,V2&gt;transformValues(com.azure.cosmos.implementation.guava25.collect.ListMultimap&lt;K,V1&gt;,com.azure.cosmos.implementation.guava25.base.Function&lt;? super V1,V2&gt;)" data-throw-if-not-resolved="false">#transformValues(ListMultimap, Function)</xref>, this method's entry-transformation logic may depend on the key as well as the value.


    All other properties of the transformed multimap, such as iteration order, are left intact. For example, the code:


    ```java

    Multimap multimap =
         ImmutableMultimap.of("a", 1, "a", 4, "b", 6);
     EntryTransformer transformer =
         new EntryTransformer() {
           public String transformEntry(String key, Integer value) {
             return key + value;
           }
         };
     Multimap transformed =
         Multimaps.transformEntries(multimap, transformer);
     System.out.println(transformed);
    ```


    ... prints `{"a"=["a1", "a4"], "b"=["b6"]}`.


    Changes in the underlying multimap are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying multimap.


    It's acceptable for the underlying multimap to contain null keys and null values provided that the transformer is capable of accepting null inputs. The transformed multimap might contain null values if the transformer sometimes gives a null result.


    The returned multimap is not thread-safe or serializable, even if the underlying multimap is.


    The transformer is applied lazily, invoked when needed. This is necessary for the returned multimap to be a view, but it means that the transformer will be applied many times for bulk operations like <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.containsValue" data-throw-if-not-resolved="false">Multimap#containsValue</xref> and <xref uid="java.lang.Object.toString" data-throw-if-not-resolved="false">Object#toString</xref>. For this to perform well, `transformer` should be fast. To avoid lazy evaluation when the returned multimap doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.


    **Warning:** This method assumes that for any instance `k` of `EntryTransformer` key type `K`, `k.equals(k2)` implies that `k2` is also of type `K`. Using an `EntryTransformer` key type for which this may not hold, such as `ArrayList`, may risk a `ClassCastException` when calling methods on the transformed multimap.
  syntax:
    content: public static ListMultimap<K,V2> <K,V1,V2>transformEntries(ListMultimap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
    parameters:
    - id: fromMap
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V1>
    - id: transformer
      type: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V2>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformEntries(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  id: <K,V1,V2>transformEntries(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V1,V2>transformEntries(Multimap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  nameWithType: Multimaps.<K,V1,V2>transformEntries(Multimap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformEntries(Multimap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.transformEntries*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of a multimap whose values are derived from the original multimap's entries. In contrast to <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.transformValues" data-throw-if-not-resolved="false">#transformValues</xref>, this method's entry-transformation logic may depend on the key as well as the value.


    All other properties of the transformed multimap, such as iteration order, are left intact. For example, the code:


    ```java

    SetMultimap multimap =
         ImmutableSetMultimap.of("a", 1, "a", 4, "b", -6);
     EntryTransformer transformer =
         new EntryTransformer() {
           public String transformEntry(String key, Integer value) {
              return (value >= 0) ? key : "no" + key;
           }
         };
     Multimap transformed =
         Multimaps.transformEntries(multimap, transformer);
     System.out.println(transformed);
    ```


    ... prints `{a=[a, a], b=[nob]}`.


    Changes in the underlying multimap are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying multimap.


    It's acceptable for the underlying multimap to contain null keys and null values provided that the transformer is capable of accepting null inputs. The transformed multimap might contain null values if the transformer sometimes gives a null result.


    The returned multimap is not thread-safe or serializable, even if the underlying multimap is. The `equals` and `hashCode` methods of the returned multimap are meaningless, since there is not a definition of `equals` or `hashCode` for general collections, and `get()` will return a general `Collection` as opposed to a `List` or a `Set`.


    The transformer is applied lazily, invoked when needed. This is necessary for the returned multimap to be a view, but it means that the transformer will be applied many times for bulk operations like <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.containsValue" data-throw-if-not-resolved="false">Multimap#containsValue</xref> and <xref uid="java.lang.Object.toString" data-throw-if-not-resolved="false">Object#toString</xref>. For this to perform well, `transformer` should be fast. To avoid lazy evaluation when the returned multimap doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.


    **Warning:** This method assumes that for any instance `k` of `EntryTransformer` key type `K`, `k.equals(k2)` implies that `k2` is also of type `K`. Using an `EntryTransformer` key type for which this may not hold, such as `ArrayList`, may risk a `ClassCastException` when calling methods on the transformed multimap.
  syntax:
    content: public static Multimap<K,V2> <K,V1,V2>transformEntries(Multimap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
    parameters:
    - id: fromMap
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V1>
    - id: transformer
      type: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V2>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformValues(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  id: <K,V1,V2>transformValues(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V1,V2>transformValues(ListMultimap<K,V1> fromMultimap, Function<? super V1,V2> function)
  nameWithType: Multimaps.<K,V1,V2>transformValues(ListMultimap<K,V1> fromMultimap, Function<? super V1,V2> function)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformValues(ListMultimap<K,V1> fromMultimap, Function<? super V1,V2> function)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.transformValues*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of a `ListMultimap` where each value is transformed by a function. All other properties of the multimap, such as iteration order, are left intact. For example, the code:


    ```java

    ListMultimap multimap
          = ImmutableListMultimap.of("a", 4, "a", 16, "b", 9);
     Function sqrt =
         new Function() {
           public Double apply(Integer in) {
             return Math.sqrt((int) in);
           }
         };
     ListMultimap transformed = Multimaps.transformValues(map,
         sqrt);
     System.out.println(transformed);
    ```


    ... prints `{a=[2.0, 4.0], b=[3.0]}`.


    Changes in the underlying multimap are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying multimap.


    It's acceptable for the underlying multimap to contain null keys, and even null values provided that the function is capable of accepting null input. The transformed multimap might contain null values, if the function sometimes gives a null result.


    The returned multimap is not thread-safe or serializable, even if the underlying multimap is.


    The function is applied lazily, invoked when needed. This is necessary for the returned multimap to be a view, but it means that the function will be applied many times for bulk operations like <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.containsValue" data-throw-if-not-resolved="false">Multimap#containsValue</xref> and `Multimap.toString()`. For this to perform well, `function` should be fast. To avoid lazy evaluation when the returned multimap doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.
  syntax:
    content: public static ListMultimap<K,V2> <K,V1,V2>transformValues(ListMultimap<K,V1> fromMultimap, Function<? super V1,V2> function)
    parameters:
    - id: fromMultimap
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V1>
    - id: function
      type: com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V2>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformValues(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  id: <K,V1,V2>transformValues(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V1,V2>transformValues(Multimap<K,V1> fromMultimap, Function<? super V1,V2> function)
  nameWithType: Multimaps.<K,V1,V2>transformValues(Multimap<K,V1> fromMultimap, Function<? super V1,V2> function)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformValues(Multimap<K,V1> fromMultimap, Function<? super V1,V2> function)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.transformValues*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of a multimap where each value is transformed by a function. All other properties of the multimap, such as iteration order, are left intact. For example, the code:


    ```java

    Multimap multimap =
         ImmutableSetMultimap.of("a", 2, "b", -3, "b", -3, "a", 4, "c", 6);
     Function square = new Function() {
         public String apply(Integer in) {
           return Integer.toString(in * in);
         }
     };
     Multimap transformed =
         Multimaps.transformValues(multimap, square);
       System.out.println(transformed);
    ```


    ... prints `{a=[4, 16], b=[9, 9], c=[36]}`.


    Changes in the underlying multimap are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying multimap.


    It's acceptable for the underlying multimap to contain null keys, and even null values provided that the function is capable of accepting null input. The transformed multimap might contain null values, if the function sometimes gives a null result.


    The returned multimap is not thread-safe or serializable, even if the underlying multimap is. The `equals` and `hashCode` methods of the returned multimap are meaningless, since there is not a definition of `equals` or `hashCode` for general collections, and `get()` will return a general `Collection` as opposed to a `List` or a `Set`.


    The function is applied lazily, invoked when needed. This is necessary for the returned multimap to be a view, but it means that the function will be applied many times for bulk operations like <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.containsValue" data-throw-if-not-resolved="false">Multimap#containsValue</xref> and `Multimap.toString()`. For this to perform well, `function` should be fast. To avoid lazy evaluation when the returned multimap doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.
  syntax:
    content: public static Multimap<K,V2> <K,V1,V2>transformValues(Multimap<K,V1> fromMultimap, Function<? super V1,V2> function)
    parameters:
    - id: fromMultimap
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V1>
    - id: function
      type: com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V2>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>)
  id: <K,V>asMap(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>asMap(ListMultimap<K,V> multimap)
  nameWithType: Multimaps.<K,V>asMap(ListMultimap<K,V> multimap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(ListMultimap<K,V> multimap)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.asMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Returns <xref uid="com.azure.cosmos.implementation.guava25.collect.ListMultimap.asMap" data-throw-if-not-resolved="false">multimap.asMap()</xref>, with its type corrected from `Map>` to `Map>`.
  syntax:
    content: public static Map<K,List<V>> <K,V>asMap(ListMultimap<K,V> multimap)
    parameters:
    - id: multimap
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>
    return:
      type: java.util.Map<K,java.util.List<V>>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>)
  id: <K,V>asMap(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>asMap(Multimap<K,V> multimap)
  nameWithType: Multimaps.<K,V>asMap(Multimap<K,V> multimap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(Multimap<K,V> multimap)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.asMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Returns <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.asMap" data-throw-if-not-resolved="false">multimap.asMap()</xref>. This is provided for parity with the other more strongly-typed `asMap()` implementations.
  syntax:
    content: public static Map<K,Collection<V>> <K,V>asMap(Multimap<K,V> multimap)
    parameters:
    - id: multimap
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
    return:
      type: java.util.Map<K,java.util.Collection<V>>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>)
  id: <K,V>asMap(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>asMap(SetMultimap<K,V> multimap)
  nameWithType: Multimaps.<K,V>asMap(SetMultimap<K,V> multimap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(SetMultimap<K,V> multimap)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.asMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Returns <xref uid="com.azure.cosmos.implementation.guava25.collect.SetMultimap.asMap" data-throw-if-not-resolved="false">multimap.asMap()</xref>, with its type corrected from `Map>` to `Map>`.
  syntax:
    content: public static Map<K,Set<V>> <K,V>asMap(SetMultimap<K,V> multimap)
    parameters:
    - id: multimap
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
    return:
      type: java.util.Map<K,java.util.Set<V>>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>)
  id: <K,V>asMap(com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>asMap(SortedSetMultimap<K,V> multimap)
  nameWithType: Multimaps.<K,V>asMap(SortedSetMultimap<K,V> multimap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap(SortedSetMultimap<K,V> multimap)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.asMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Returns <xref uid="com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap.asMap" data-throw-if-not-resolved="false">multimap.asMap()</xref>, with its type corrected from `Map>` to `Map>`.
  syntax:
    content: public static Map<K,SortedSet<V>> <K,V>asMap(SortedSetMultimap<K,V> multimap)
    parameters:
    - id: multimap
      type: com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>
    return:
      type: java.util.Map<K,java.util.SortedSet<V>>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterEntries(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  id: <K,V>filterEntries(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>filterEntries(Multimap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  nameWithType: Multimaps.<K,V>filterEntries(Multimap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterEntries(Multimap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.filterEntries*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a multimap containing the mappings in `unfiltered` that satisfy a predicate. The returned multimap is a live view of `unfiltered`; changes to one affect the other.


    The resulting multimap's views have iterators that don't support `remove()`, but all other methods are supported by the multimap and its views. When adding a key/value pair that doesn't satisfy the predicate, multimap's `put()`, `putAll()`, and `replaceValues()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap.


    The returned multimap isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered multimap's methods, such as `size()`, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered multimap and use the copy.


    **Warning:** `entryPredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>.
  syntax:
    content: public static Multimap<K,V> <K,V>filterEntries(Multimap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
    parameters:
    - id: unfiltered
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
    - id: entryPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterEntries(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  id: <K,V>filterEntries(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>filterEntries(SetMultimap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  nameWithType: Multimaps.<K,V>filterEntries(SetMultimap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterEntries(SetMultimap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.filterEntries*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a multimap containing the mappings in `unfiltered` that satisfy a predicate. The returned multimap is a live view of `unfiltered`; changes to one affect the other.


    The resulting multimap's views have iterators that don't support `remove()`, but all other methods are supported by the multimap and its views. When adding a key/value pair that doesn't satisfy the predicate, multimap's `put()`, `putAll()`, and `replaceValues()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap.


    The returned multimap isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered multimap's methods, such as `size()`, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered multimap and use the copy.


    **Warning:** `entryPredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>.
  syntax:
    content: public static SetMultimap<K,V> <K,V>filterEntries(SetMultimap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
    parameters:
    - id: unfiltered
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
    - id: entryPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  id: <K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>filterKeys(ListMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  nameWithType: Multimaps.<K,V>filterKeys(ListMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(ListMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.filterKeys*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a multimap containing the mappings in `unfiltered` whose keys satisfy a predicate. The returned multimap is a live view of `unfiltered`; changes to one affect the other.


    The resulting multimap's views have iterators that don't support `remove()`, but all other methods are supported by the multimap and its views. When adding a key that doesn't satisfy the predicate, the multimap's `put()`, `putAll()`, and `replaceValues()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap.


    The returned multimap isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered multimap's methods, such as `size()`, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered multimap and use the copy.


    **Warning:** `keyPredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals.
  syntax:
    content: public static ListMultimap<K,V> <K,V>filterKeys(ListMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
    parameters:
    - id: unfiltered
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>
    - id: keyPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super K>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  id: <K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>filterKeys(Multimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  nameWithType: Multimaps.<K,V>filterKeys(Multimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(Multimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.filterKeys*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a multimap containing the mappings in `unfiltered` whose keys satisfy a predicate. The returned multimap is a live view of `unfiltered`; changes to one affect the other.


    The resulting multimap's views have iterators that don't support `remove()`, but all other methods are supported by the multimap and its views. When adding a key that doesn't satisfy the predicate, the multimap's `put()`, `putAll()`, and `replaceValues()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap.


    The returned multimap isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered multimap's methods, such as `size()`, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered multimap and use the copy.


    **Warning:** `keyPredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals.
  syntax:
    content: public static Multimap<K,V> <K,V>filterKeys(Multimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
    parameters:
    - id: unfiltered
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
    - id: keyPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super K>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  id: <K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>filterKeys(SetMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  nameWithType: Multimaps.<K,V>filterKeys(SetMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(SetMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.filterKeys*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a multimap containing the mappings in `unfiltered` whose keys satisfy a predicate. The returned multimap is a live view of `unfiltered`; changes to one affect the other.


    The resulting multimap's views have iterators that don't support `remove()`, but all other methods are supported by the multimap and its views. When adding a key that doesn't satisfy the predicate, the multimap's `put()`, `putAll()`, and `replaceValues()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap.


    The returned multimap isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered multimap's methods, such as `size()`, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered multimap and use the copy.


    **Warning:** `keyPredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals.
  syntax:
    content: public static SetMultimap<K,V> <K,V>filterKeys(SetMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)
    parameters:
    - id: unfiltered
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
    - id: keyPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super K>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterValues(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  id: <K,V>filterValues(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>filterValues(Multimap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  nameWithType: Multimaps.<K,V>filterValues(Multimap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterValues(Multimap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.filterValues*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a multimap containing the mappings in `unfiltered` whose values satisfy a predicate. The returned multimap is a live view of `unfiltered`; changes to one affect the other.


    The resulting multimap's views have iterators that don't support `remove()`, but all other methods are supported by the multimap and its views. When adding a value that doesn't satisfy the predicate, the multimap's `put()`, `putAll()`, and `replaceValues()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered multimap or its views, only mappings whose value satisfy the filter will be removed from the underlying multimap.


    The returned multimap isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered multimap's methods, such as `size()`, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered multimap and use the copy.


    **Warning:** `valuePredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals.
  syntax:
    content: public static Multimap<K,V> <K,V>filterValues(Multimap<K,V> unfiltered, Predicate<? super V> valuePredicate)
    parameters:
    - id: unfiltered
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
    - id: valuePredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super V>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterValues(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  id: <K,V>filterValues(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>filterValues(SetMultimap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  nameWithType: Multimaps.<K,V>filterValues(SetMultimap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterValues(SetMultimap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.filterValues*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a multimap containing the mappings in `unfiltered` whose values satisfy a predicate. The returned multimap is a live view of `unfiltered`; changes to one affect the other.


    The resulting multimap's views have iterators that don't support `remove()`, but all other methods are supported by the multimap and its views. When adding a value that doesn't satisfy the predicate, the multimap's `put()`, `putAll()`, and `replaceValues()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered multimap or its views, only mappings whose value satisfy the filter will be removed from the underlying multimap.


    The returned multimap isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered multimap's methods, such as `size()`, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered multimap and use the copy.


    **Warning:** `valuePredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals.
  syntax:
    content: public static SetMultimap<K,V> <K,V>filterValues(SetMultimap<K,V> unfiltered, Predicate<? super V> valuePredicate)
    parameters:
    - id: unfiltered
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
    - id: valuePredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super V>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>forMap(java.util.Map<K,V>)
  id: <K,V>forMap(java.util.Map<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>forMap(Map<K,V> map)
  nameWithType: Multimaps.<K,V>forMap(Map<K,V> map)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>forMap(Map<K,V> map)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.forMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a multimap view of the specified map. The multimap is backed by the map, so changes to the map are reflected in the multimap, and vice versa. If the map is modified while an iteration over one of the multimap's collection views is in progress (except through the iterator's own `remove` operation, or through the `setValue` operation on a map entry returned by the iterator), the results of the iteration are undefined.


    The multimap supports mapping removal, which removes the corresponding mapping from the map. It does not support any operations which might add mappings, such as `put`, `putAll` or `replaceValues`.


    The returned multimap will be serializable if the specified map is serializable.
  syntax:
    content: public static SetMultimap<K,V> <K,V>forMap(Map<K,V> map)
    parameters:
    - id: map
      type: java.util.Map<K,V>
      description: the backing map for the returned multimap view
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>index(java.lang.Iterable<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  id: <K,V>index(java.lang.Iterable<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>index(Iterable<V> values, Function<? super V,K> keyFunction)
  nameWithType: Multimaps.<K,V>index(Iterable<V> values, Function<? super V,K> keyFunction)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>index(Iterable<V> values, Function<? super V,K> keyFunction)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.index*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates an index `ImmutableListMultimap` that contains the results of applying a specified function to each item in an `Iterable` of values. Each value will be stored as a value in the resulting multimap, yielding a multimap with the same size as the input iterable. The key used to store that value in the multimap will be the result of calling the function on that value. The resulting multimap is created as an immutable snapshot. In the returned multimap, keys appear in the order they are first encountered, and the values corresponding to each key appear in the same order as they are encountered.


    For example,


    ```java

    List badGuys =
         Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");
     Function stringLengthFunction = ...;
     Multimap index =
         Multimaps.index(badGuys, stringLengthFunction);
     System.out.println(index);
    ```


    prints


    ```java

    {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}

    ```


    The returned multimap is serializable if its keys and values are all serializable.
  syntax:
    content: public static ImmutableListMultimap<K,V> <K,V>index(Iterable<V> values, Function<? super V,K> keyFunction)
    parameters:
    - id: values
      type: java.lang.Iterable<V>
      description: the values to use when constructing the <code>ImmutableListMultimap</code>
    - id: keyFunction
      type: com.azure.cosmos.implementation.guava25.base.Function<? super V,K>
      description: the function used to produce the key for each value
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap<K,V>
      description: >-
        <code>ImmutableListMultimap</code> mapping the result of evaluating the function <code>
             keyFunction</code> on each value in the input collection to that value
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>index(java.util.Iterator<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  id: <K,V>index(java.util.Iterator<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>index(Iterator<V> values, Function<? super V,K> keyFunction)
  nameWithType: Multimaps.<K,V>index(Iterator<V> values, Function<? super V,K> keyFunction)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>index(Iterator<V> values, Function<? super V,K> keyFunction)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.index*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates an index `ImmutableListMultimap` that contains the results of applying a specified function to each item in an `Iterator` of values. Each value will be stored as a value in the resulting multimap, yielding a multimap with the same size as the input iterator. The key used to store that value in the multimap will be the result of calling the function on that value. The resulting multimap is created as an immutable snapshot. In the returned multimap, keys appear in the order they are first encountered, and the values corresponding to each key appear in the same order as they are encountered.


    For example,


    ```java

    List badGuys =
         Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");
     Function stringLengthFunction = ...;
     Multimap index =
         Multimaps.index(badGuys.iterator(), stringLengthFunction);
     System.out.println(index);
    ```


    prints


    ```java

    {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}

    ```


    The returned multimap is serializable if its keys and values are all serializable.
  syntax:
    content: public static ImmutableListMultimap<K,V> <K,V>index(Iterator<V> values, Function<? super V,K> keyFunction)
    parameters:
    - id: values
      type: java.util.Iterator<V>
      description: the values to use when constructing the <code>ImmutableListMultimap</code>
    - id: keyFunction
      type: com.azure.cosmos.implementation.guava25.base.Function<? super V,K>
      description: the function used to produce the key for each value
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap<K,V>
      description: >-
        <code>ImmutableListMultimap</code> mapping the result of evaluating the function <code>
             keyFunction</code> on each value in the input collection to that value
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newListMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.List<V>>)
  id: <K,V>newListMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.List<V>>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>newListMultimap(Map<K,Collection<V>> map, Supplier<? extends List<V>> factory)
  nameWithType: Multimaps.<K,V>newListMultimap(Map<K,Collection<V>> map, Supplier<? extends List<V>> factory)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newListMultimap(Map<K,Collection<V>> map, Supplier<? extends List<V>> factory)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.newListMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a new `ListMultimap` that uses the provided map and factory. It can generate a multimap based on arbitrary <xref uid="java.util.Map" data-throw-if-not-resolved="false">Map</xref> and <xref uid="java.util.List" data-throw-if-not-resolved="false">List</xref> classes.


    The `factory`\-generated and `map` classes determine the multimap iteration order. They also specify the behavior of the `equals`, `hashCode`, and `toString` methods for the multimap and its returned views. The multimap's `get`, `removeAll`, and `replaceValues` methods return `RandomAccess` lists if the factory does. However, the multimap's `get` method returns instances of a different class than does `factory.get()`.


    The multimap is serializable if `map`, `factory`, the lists generated by `factory`, and the multimap contents are all serializable.


    The multimap is not threadsafe when any concurrent operations update the multimap, even if `map` and the instances generated by `factory` are. Concurrent read operations will work correctly. To allow concurrent update operations, wrap the multimap with a call to <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedListMultimap" data-throw-if-not-resolved="false">#synchronizedListMultimap</xref>.


    Call this method only when the simpler methods <xref uid="com.azure.cosmos.implementation.guava25.collect.ArrayListMultimap.&lt;K,V&gt;create()" data-throw-if-not-resolved="false">ArrayListMultimap#create()</xref> and <xref uid="com.azure.cosmos.implementation.guava25.collect.LinkedListMultimap.&lt;K,V&gt;create()" data-throw-if-not-resolved="false">LinkedListMultimap#create()</xref> won't suffice.


    Note: the multimap assumes complete ownership over of `map` and the lists returned by `factory`. Those objects should not be manually updated, they should be empty when provided, and they should not use soft, weak, or phantom references.
  syntax:
    content: public static ListMultimap<K,V> <K,V>newListMultimap(Map<K,Collection<V>> map, Supplier<? extends List<V>> factory)
    parameters:
    - id: map
      type: java.util.Map<K,java.util.Collection<V>>
      description: place to store the mapping from each key to its corresponding values
    - id: factory
      type: com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.List<V>>
      description: supplier of new, empty lists that will each hold all values for a given key
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.Collection<V>>)
  id: <K,V>newMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.Collection<V>>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>newMultimap(Map<K,Collection<V>> map, Supplier<? extends Collection<V>> factory)
  nameWithType: Multimaps.<K,V>newMultimap(Map<K,Collection<V>> map, Supplier<? extends Collection<V>> factory)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newMultimap(Map<K,Collection<V>> map, Supplier<? extends Collection<V>> factory)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.newMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a new `Multimap` backed by `map`, whose internal value collections are generated by `factory`.


    **Warning: do not use** this method when the collections returned by `factory` implement either <xref uid="java.util.List" data-throw-if-not-resolved="false">List</xref> or `Set`! Use the more specific method <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.newListMultimap" data-throw-if-not-resolved="false">#newListMultimap</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.newSetMultimap" data-throw-if-not-resolved="false">#newSetMultimap</xref> or <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.newSortedSetMultimap" data-throw-if-not-resolved="false">#newSortedSetMultimap</xref> instead, to avoid very surprising behavior from <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.equals" data-throw-if-not-resolved="false">Multimap#equals</xref>.


    The `factory`\-generated and `map` classes determine the multimap iteration order. They also specify the behavior of the `equals`, `hashCode`, and `toString` methods for the multimap and its returned views. However, the multimap's `get` method returns instances of a different class than `factory.get()` does.


    The multimap is serializable if `map`, `factory`, the collections generated by `factory`, and the multimap contents are all serializable.


    The multimap is not threadsafe when any concurrent operations update the multimap, even if `map` and the instances generated by `factory` are. Concurrent read operations will work correctly. To allow concurrent update operations, wrap the multimap with a call to <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedMultimap" data-throw-if-not-resolved="false">#synchronizedMultimap</xref>.


    Call this method only when the simpler methods <xref uid="com.azure.cosmos.implementation.guava25.collect.ArrayListMultimap.&lt;K,V&gt;create()" data-throw-if-not-resolved="false">ArrayListMultimap#create()</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.HashMultimap.&lt;K,V&gt;create()" data-throw-if-not-resolved="false">HashMultimap#create()</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.LinkedHashMultimap.&lt;K,V&gt;create()" data-throw-if-not-resolved="false">LinkedHashMultimap#create()</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.LinkedListMultimap.&lt;K,V&gt;create()" data-throw-if-not-resolved="false">LinkedListMultimap#create()</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.TreeMultimap.&lt;K,V&gt;create()" data-throw-if-not-resolved="false">TreeMultimap#create()</xref>, and <xref uid="com.azure.cosmos.implementation.guava25.collect.TreeMultimap.&lt;K,V&gt;create(java.util.Comparator&lt;? super K&gt;,java.util.Comparator&lt;? super V&gt;)" data-throw-if-not-resolved="false">TreeMultimap#create(Comparator, Comparator)</xref> won't suffice.


    Note: the multimap assumes complete ownership over of `map` and the collections returned by `factory`. Those objects should not be manually updated and they should not use soft, weak, or phantom references.
  syntax:
    content: public static Multimap<K,V> <K,V>newMultimap(Map<K,Collection<V>> map, Supplier<? extends Collection<V>> factory)
    parameters:
    - id: map
      type: java.util.Map<K,java.util.Collection<V>>
      description: place to store the mapping from each key to its corresponding values
    - id: factory
      type: com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.Collection<V>>
      description: >-
        supplier of new, empty collections that will each hold all values for a given
             key
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newSetMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.Set<V>>)
  id: <K,V>newSetMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.Set<V>>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>newSetMultimap(Map<K,Collection<V>> map, Supplier<? extends Set<V>> factory)
  nameWithType: Multimaps.<K,V>newSetMultimap(Map<K,Collection<V>> map, Supplier<? extends Set<V>> factory)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newSetMultimap(Map<K,Collection<V>> map, Supplier<? extends Set<V>> factory)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.newSetMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a new `SetMultimap` that uses the provided map and factory. It can generate a multimap based on arbitrary <xref uid="java.util.Map" data-throw-if-not-resolved="false">Map</xref> and <xref uid="java.util.Set" data-throw-if-not-resolved="false">Set</xref> classes.


    The `factory`\-generated and `map` classes determine the multimap iteration order. They also specify the behavior of the `equals`, `hashCode`, and `toString` methods for the multimap and its returned views. However, the multimap's `get` method returns instances of a different class than `factory.get()` does.


    The multimap is serializable if `map`, `factory`, the sets generated by `factory`, and the multimap contents are all serializable.


    The multimap is not threadsafe when any concurrent operations update the multimap, even if `map` and the instances generated by `factory` are. Concurrent read operations will work correctly. To allow concurrent update operations, wrap the multimap with a call to <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedSetMultimap" data-throw-if-not-resolved="false">#synchronizedSetMultimap</xref>.


    Call this method only when the simpler methods <xref uid="com.azure.cosmos.implementation.guava25.collect.HashMultimap.&lt;K,V&gt;create()" data-throw-if-not-resolved="false">HashMultimap#create()</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.LinkedHashMultimap.&lt;K,V&gt;create()" data-throw-if-not-resolved="false">LinkedHashMultimap#create()</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.TreeMultimap.&lt;K,V&gt;create()" data-throw-if-not-resolved="false">TreeMultimap#create()</xref>, and <xref uid="com.azure.cosmos.implementation.guava25.collect.TreeMultimap.&lt;K,V&gt;create(java.util.Comparator&lt;? super K&gt;,java.util.Comparator&lt;? super V&gt;)" data-throw-if-not-resolved="false">TreeMultimap#create(Comparator, Comparator)</xref> won't suffice.


    Note: the multimap assumes complete ownership over of `map` and the sets returned by `factory`. Those objects should not be manually updated and they should not use soft, weak, or phantom references.
  syntax:
    content: public static SetMultimap<K,V> <K,V>newSetMultimap(Map<K,Collection<V>> map, Supplier<? extends Set<V>> factory)
    parameters:
    - id: map
      type: java.util.Map<K,java.util.Collection<V>>
      description: place to store the mapping from each key to its corresponding values
    - id: factory
      type: com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.Set<V>>
      description: supplier of new, empty sets that will each hold all values for a given key
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newSortedSetMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.SortedSet<V>>)
  id: <K,V>newSortedSetMultimap(java.util.Map<K,java.util.Collection<V>>,com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.SortedSet<V>>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>newSortedSetMultimap(Map<K,Collection<V>> map, Supplier<? extends SortedSet<V>> factory)
  nameWithType: Multimaps.<K,V>newSortedSetMultimap(Map<K,Collection<V>> map, Supplier<? extends SortedSet<V>> factory)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newSortedSetMultimap(Map<K,Collection<V>> map, Supplier<? extends SortedSet<V>> factory)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.newSortedSetMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a new `SortedSetMultimap` that uses the provided map and factory. It can generate a multimap based on arbitrary <xref uid="java.util.Map" data-throw-if-not-resolved="false">Map</xref> and <xref uid="java.util.SortedSet" data-throw-if-not-resolved="false">SortedSet</xref> classes.


    The `factory`\-generated and `map` classes determine the multimap iteration order. They also specify the behavior of the `equals`, `hashCode`, and `toString` methods for the multimap and its returned views. However, the multimap's `get` method returns instances of a different class than `factory.get()` does.


    The multimap is serializable if `map`, `factory`, the sets generated by `factory`, and the multimap contents are all serializable.


    The multimap is not threadsafe when any concurrent operations update the multimap, even if `map` and the instances generated by `factory` are. Concurrent read operations will work correctly. To allow concurrent update operations, wrap the multimap with a call to <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedSortedSetMultimap" data-throw-if-not-resolved="false">#synchronizedSortedSetMultimap</xref>.


    Call this method only when the simpler methods <xref uid="com.azure.cosmos.implementation.guava25.collect.TreeMultimap.&lt;K,V&gt;create()" data-throw-if-not-resolved="false">TreeMultimap#create()</xref> and <xref uid="com.azure.cosmos.implementation.guava25.collect.TreeMultimap.&lt;K,V&gt;create(java.util.Comparator&lt;? super K&gt;,java.util.Comparator&lt;? super V&gt;)" data-throw-if-not-resolved="false">TreeMultimap#create(Comparator, Comparator)</xref> won't suffice.


    Note: the multimap assumes complete ownership over of `map` and the sets returned by `factory`. Those objects should not be manually updated and they should not use soft, weak, or phantom references.
  syntax:
    content: public static SortedSetMultimap<K,V> <K,V>newSortedSetMultimap(Map<K,Collection<V>> map, Supplier<? extends SortedSet<V>> factory)
    parameters:
    - id: map
      type: java.util.Map<K,java.util.Collection<V>>
      description: place to store the mapping from each key to its corresponding values
    - id: factory
      type: com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.SortedSet<V>>
      description: >-
        supplier of new, empty sorted sets that will each hold all values for a given
             key
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedListMultimap(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>)
  id: <K,V>synchronizedListMultimap(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>synchronizedListMultimap(ListMultimap<K,V> multimap)
  nameWithType: Multimaps.<K,V>synchronizedListMultimap(ListMultimap<K,V> multimap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedListMultimap(ListMultimap<K,V> multimap)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedListMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a synchronized (thread-safe) `ListMultimap` backed by the specified multimap.


    You must follow the warnings described in <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedMultimap" data-throw-if-not-resolved="false">#synchronizedMultimap</xref>.
  syntax:
    content: public static ListMultimap<K,V> <K,V>synchronizedListMultimap(ListMultimap<K,V> multimap)
    parameters:
    - id: multimap
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>
      description: the multimap to be wrapped
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>
      description: a synchronized view of the specified multimap
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedMultimap(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>)
  id: <K,V>synchronizedMultimap(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>synchronizedMultimap(Multimap<K,V> multimap)
  nameWithType: Multimaps.<K,V>synchronizedMultimap(Multimap<K,V> multimap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedMultimap(Multimap<K,V> multimap)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a synchronized (thread-safe) multimap backed by the specified multimap. In order to guarantee serial access, it is critical that **all** access to the backing multimap is accomplished through the returned multimap.


    It is imperative that the user manually synchronize on the returned multimap when accessing any of its collection views:


    ```java

    Multimap multimap = Multimaps.synchronizedMultimap(
         HashMultimap.create());
     ...
     Collection values = multimap.get(key);  // Needn't be in synchronized block
     ...
     synchronized (multimap) {  // Synchronizing on multimap, not values!
       Iterator i = values.iterator(); // Must be in synchronized block
       while (i.hasNext()) {
         foo(i.next());
       }
     }
    ```


    Failure to follow this advice may result in non-deterministic behavior.


    Note that the generated multimap's <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.removeAll" data-throw-if-not-resolved="false">Multimap#removeAll</xref> and <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.replaceValues" data-throw-if-not-resolved="false">Multimap#replaceValues</xref> methods return collections that aren't synchronized.


    The returned multimap will be serializable if the specified multimap is serializable.
  syntax:
    content: public static Multimap<K,V> <K,V>synchronizedMultimap(Multimap<K,V> multimap)
    parameters:
    - id: multimap
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
      description: the multimap to be wrapped in a synchronized view
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
      description: a synchronized view of the specified multimap
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedSetMultimap(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>)
  id: <K,V>synchronizedSetMultimap(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>synchronizedSetMultimap(SetMultimap<K,V> multimap)
  nameWithType: Multimaps.<K,V>synchronizedSetMultimap(SetMultimap<K,V> multimap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedSetMultimap(SetMultimap<K,V> multimap)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedSetMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a synchronized (thread-safe) `SetMultimap` backed by the specified multimap.


    You must follow the warnings described in <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedMultimap" data-throw-if-not-resolved="false">#synchronizedMultimap</xref>.


    The returned multimap will be serializable if the specified multimap is serializable.
  syntax:
    content: public static SetMultimap<K,V> <K,V>synchronizedSetMultimap(SetMultimap<K,V> multimap)
    parameters:
    - id: multimap
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
      description: the multimap to be wrapped
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
      description: a synchronized view of the specified multimap
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedSortedSetMultimap(com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>)
  id: <K,V>synchronizedSortedSetMultimap(com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>synchronizedSortedSetMultimap(SortedSetMultimap<K,V> multimap)
  nameWithType: Multimaps.<K,V>synchronizedSortedSetMultimap(SortedSetMultimap<K,V> multimap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedSortedSetMultimap(SortedSetMultimap<K,V> multimap)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedSortedSetMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a synchronized (thread-safe) `SortedSetMultimap` backed by the specified multimap.


    You must follow the warnings described in <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedMultimap" data-throw-if-not-resolved="false">#synchronizedMultimap</xref>.


    The returned multimap will be serializable if the specified multimap is serializable.
  syntax:
    content: public static SortedSetMultimap<K,V> <K,V>synchronizedSortedSetMultimap(SortedSetMultimap<K,V> multimap)
    parameters:
    - id: multimap
      type: com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>
      description: the multimap to be wrapped
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>
      description: a synchronized view of the specified multimap
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableListMultimap(com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap<K,V>)
  id: <K,V>unmodifiableListMultimap(com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>unmodifiableListMultimap(ImmutableListMultimap<K,V> delegate)
  nameWithType: Multimaps.<K,V>unmodifiableListMultimap(ImmutableListMultimap<K,V> delegate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableListMultimap(ImmutableListMultimap<K,V> delegate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.unmodifiableListMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Simply returns its argument.
  syntax:
    content: public static ListMultimap<K,V> <K,V>unmodifiableListMultimap(ImmutableListMultimap<K,V> delegate)
    parameters:
    - id: delegate
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap<K,V>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableListMultimap(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>)
  id: <K,V>unmodifiableListMultimap(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>unmodifiableListMultimap(ListMultimap<K,V> delegate)
  nameWithType: Multimaps.<K,V>unmodifiableListMultimap(ListMultimap<K,V> delegate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableListMultimap(ListMultimap<K,V> delegate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.unmodifiableListMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an unmodifiable view of the specified `ListMultimap`. Query operations on the returned multimap "read through" to the specified multimap, and attempts to modify the returned multimap, either directly or through the multimap's views, result in an `UnsupportedOperationException`.


    Note that the generated multimap's <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.removeAll" data-throw-if-not-resolved="false">Multimap#removeAll</xref> and <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.replaceValues" data-throw-if-not-resolved="false">Multimap#replaceValues</xref> methods return collections that are modifiable.


    The returned multimap will be serializable if the specified multimap is serializable.
  syntax:
    content: public static ListMultimap<K,V> <K,V>unmodifiableListMultimap(ListMultimap<K,V> delegate)
    parameters:
    - id: delegate
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>
      description: the multimap for which an unmodifiable view is to be returned
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>
      description: an unmodifiable view of the specified multimap
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableMultimap(com.azure.cosmos.implementation.guava25.collect.ImmutableMultimap<K,V>)
  id: <K,V>unmodifiableMultimap(com.azure.cosmos.implementation.guava25.collect.ImmutableMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>unmodifiableMultimap(ImmutableMultimap<K,V> delegate)
  nameWithType: Multimaps.<K,V>unmodifiableMultimap(ImmutableMultimap<K,V> delegate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableMultimap(ImmutableMultimap<K,V> delegate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.unmodifiableMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Simply returns its argument.
  syntax:
    content: public static Multimap<K,V> <K,V>unmodifiableMultimap(ImmutableMultimap<K,V> delegate)
    parameters:
    - id: delegate
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableMultimap<K,V>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableMultimap(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>)
  id: <K,V>unmodifiableMultimap(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>unmodifiableMultimap(Multimap<K,V> delegate)
  nameWithType: Multimaps.<K,V>unmodifiableMultimap(Multimap<K,V> delegate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableMultimap(Multimap<K,V> delegate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.unmodifiableMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an unmodifiable view of the specified multimap. Query operations on the returned multimap "read through" to the specified multimap, and attempts to modify the returned multimap, either directly or through the multimap's views, result in an `UnsupportedOperationException`.


    Note that the generated multimap's <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.removeAll" data-throw-if-not-resolved="false">Multimap#removeAll</xref> and <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.replaceValues" data-throw-if-not-resolved="false">Multimap#replaceValues</xref> methods return collections that are modifiable.


    The returned multimap will be serializable if the specified multimap is serializable.
  syntax:
    content: public static Multimap<K,V> <K,V>unmodifiableMultimap(Multimap<K,V> delegate)
    parameters:
    - id: delegate
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
      description: the multimap for which an unmodifiable view is to be returned
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
      description: an unmodifiable view of the specified multimap
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableSetMultimap(com.azure.cosmos.implementation.guava25.collect.ImmutableSetMultimap<K,V>)
  id: <K,V>unmodifiableSetMultimap(com.azure.cosmos.implementation.guava25.collect.ImmutableSetMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>unmodifiableSetMultimap(ImmutableSetMultimap<K,V> delegate)
  nameWithType: Multimaps.<K,V>unmodifiableSetMultimap(ImmutableSetMultimap<K,V> delegate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableSetMultimap(ImmutableSetMultimap<K,V> delegate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.unmodifiableSetMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Simply returns its argument.
  syntax:
    content: public static SetMultimap<K,V> <K,V>unmodifiableSetMultimap(ImmutableSetMultimap<K,V> delegate)
    parameters:
    - id: delegate
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableSetMultimap<K,V>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableSetMultimap(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>)
  id: <K,V>unmodifiableSetMultimap(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>unmodifiableSetMultimap(SetMultimap<K,V> delegate)
  nameWithType: Multimaps.<K,V>unmodifiableSetMultimap(SetMultimap<K,V> delegate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableSetMultimap(SetMultimap<K,V> delegate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.unmodifiableSetMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an unmodifiable view of the specified `SetMultimap`. Query operations on the returned multimap "read through" to the specified multimap, and attempts to modify the returned multimap, either directly or through the multimap's views, result in an `UnsupportedOperationException`.


    Note that the generated multimap's <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.removeAll" data-throw-if-not-resolved="false">Multimap#removeAll</xref> and <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.replaceValues" data-throw-if-not-resolved="false">Multimap#replaceValues</xref> methods return collections that are modifiable.


    The returned multimap will be serializable if the specified multimap is serializable.
  syntax:
    content: public static SetMultimap<K,V> <K,V>unmodifiableSetMultimap(SetMultimap<K,V> delegate)
    parameters:
    - id: delegate
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
      description: the multimap for which an unmodifiable view is to be returned
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
      description: an unmodifiable view of the specified multimap
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableSortedSetMultimap(com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>)
  id: <K,V>unmodifiableSortedSetMultimap(com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <K,V>unmodifiableSortedSetMultimap(SortedSetMultimap<K,V> delegate)
  nameWithType: Multimaps.<K,V>unmodifiableSortedSetMultimap(SortedSetMultimap<K,V> delegate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableSortedSetMultimap(SortedSetMultimap<K,V> delegate)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.unmodifiableSortedSetMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an unmodifiable view of the specified `SortedSetMultimap`. Query operations on the returned multimap "read through" to the specified multimap, and attempts to modify the returned multimap, either directly or through the multimap's views, result in an `UnsupportedOperationException`.


    Note that the generated multimap's <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.removeAll" data-throw-if-not-resolved="false">Multimap#removeAll</xref> and <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimap.replaceValues" data-throw-if-not-resolved="false">Multimap#replaceValues</xref> methods return collections that are modifiable.


    The returned multimap will be serializable if the specified multimap is serializable.
  syntax:
    content: public static SortedSetMultimap<K,V> <K,V>unmodifiableSortedSetMultimap(SortedSetMultimap<K,V> delegate)
    parameters:
    - id: delegate
      type: com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>
      description: the multimap for which an unmodifiable view is to be returned
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>
      description: an unmodifiable view of the specified multimap
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<T,K,V,M>flatteningToMultimap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends java.util.stream.Stream<? extends V>>,java.util.function.Supplier<M>)
  id: <T,K,V,M>flatteningToMultimap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends java.util.stream.Stream<? extends V>>,java.util.function.Supplier<M>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <T,K,V,M>flatteningToMultimap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends Stream<? extends V>> valueFunction, Supplier<M> multimapSupplier)
  nameWithType: Multimaps.<T,K,V,M>flatteningToMultimap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends Stream<? extends V>> valueFunction, Supplier<M> multimapSupplier)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<T,K,V,M>flatteningToMultimap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends Stream<? extends V>> valueFunction, Supplier<M> multimapSupplier)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.flatteningToMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a `Collector` accumulating entries into a `Multimap` generated from the specified supplier. Each input element is mapped to a key and a stream of values, each of which are put into the resulting `Multimap`, in the encounter order of the stream and the encounter order of the streams of values.


    Example:


    ```java

    static final ListMultimap FIRST_LETTER_MULTIMAP =
         Stream.of("banana", "apple", "carrot", "asparagus", "cherry")
             .collect(
                 flatteningToMultimap(
                      str -> str.charAt(0),
                      str -> str.substring(1).chars().mapToObj(c -> (char) c),
                      MultimapBuilder.linkedHashKeys().arrayListValues()::build));

     // is equivalent to

     static final ListMultimap FIRST_LETTER_MULTIMAP;

     static {
         FIRST_LETTER_MULTIMAP = MultimapBuilder.linkedHashKeys().arrayListValues().build();
         FIRST_LETTER_MULTIMAP.putAll('b', Arrays.asList('a', 'n', 'a', 'n', 'a'));
         FIRST_LETTER_MULTIMAP.putAll('a', Arrays.asList('p', 'p', 'l', 'e'));
         FIRST_LETTER_MULTIMAP.putAll('c', Arrays.asList('a', 'r', 'r', 'o', 't'));
         FIRST_LETTER_MULTIMAP.putAll('a', Arrays.asList('s', 'p', 'a', 'r', 'a', 'g', 'u', 's'));
         FIRST_LETTER_MULTIMAP.putAll('c', Arrays.asList('h', 'e', 'r', 'r', 'y'));
     }
    ```
  syntax:
    content: public static Collector<T,?,M> <T,K,V,M>flatteningToMultimap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends Stream<? extends V>> valueFunction, Supplier<M> multimapSupplier)
    parameters:
    - id: keyFunction
      type: java.util.function.Function<? super T,? extends K>
    - id: valueFunction
      type: java.util.function.Function<? super T,? extends java.util.stream.Stream<? extends V>>
    - id: multimapSupplier
      type: java.util.function.Supplier<M>
    return:
      type: java.util.stream.Collector<T,?,M>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.<T,K,V,M>toMultimap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>,java.util.function.Supplier<M>)
  id: <T,K,V,M>toMultimap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>,java.util.function.Supplier<M>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: <T,K,V,M>toMultimap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction, Supplier<M> multimapSupplier)
  nameWithType: Multimaps.<T,K,V,M>toMultimap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction, Supplier<M> multimapSupplier)
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<T,K,V,M>toMultimap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction, Supplier<M> multimapSupplier)
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.toMultimap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a `Collector` accumulating entries into a `Multimap` generated from the specified supplier. The keys and values of the entries are the result of applying the provided mapping functions to the input elements, accumulated in the encounter order of the stream.


    Example:


    ```java

    static final ListMultimap FIRST_LETTER_MULTIMAP =
         Stream.of("banana", "apple", "carrot", "asparagus", "cherry")
             .collect(
                 toMultimap(
                      str -> str.charAt(0),
                      str -> str.substring(1),
                      MultimapBuilder.treeKeys().arrayListValues()::build));

     // is equivalent to

     static final ListMultimap FIRST_LETTER_MULTIMAP;

     static {
         FIRST_LETTER_MULTIMAP = MultimapBuilder.treeKeys().arrayListValues().build();
         FIRST_LETTER_MULTIMAP.put('b', "anana");
         FIRST_LETTER_MULTIMAP.put('a', "pple");
         FIRST_LETTER_MULTIMAP.put('a', "sparagus");
         FIRST_LETTER_MULTIMAP.put('c', "arrot");
         FIRST_LETTER_MULTIMAP.put('c', "herry");
     }
    ```
  syntax:
    content: public static Collector<T,?,M> <T,K,V,M>toMultimap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction, Supplier<M> multimapSupplier)
    parameters:
    - id: keyFunction
      type: java.util.function.Function<? super T,? extends K>
    - id: valueFunction
      type: java.util.function.Function<? super T,? extends V>
    - id: multimapSupplier
      type: java.util.function.Supplier<M>
    return:
      type: java.util.stream.Collector<T,?,M>
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.Multimaps()
  id: Multimaps()
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Multimaps
  langs:
  - java
  name: Multimaps()
  nameWithType: Multimaps.Multimaps()
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.Multimaps()
  overload: com.azure.cosmos.implementation.guava25.collect.Multimaps.Multimaps*
  type: Constructor
  package: com.azure.cosmos.implementation.guava25.collect
  syntax:
    content: private Multimaps()
references:
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.Multimaps*
  name: Multimaps
  nameWithType: Multimaps.Multimaps
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.Multimaps
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.function.Function<? super T,? extends K>
  spec.java:
  - uid: java.util.function.Function
    name: Function
    fullName: java.util.function.Function
  - name: <
    fullName: <
  - uid: '? super T'
    name: '? super T'
    fullName: '? super T'
  - name: ','
    fullName: ','
  - uid: '? extends K'
    name: '? extends K'
    fullName: '? extends K'
  - name: '>'
    fullName: '>'
- uid: java.util.function.Function<? super T,? extends V>
  spec.java:
  - uid: java.util.function.Function
    name: Function
    fullName: java.util.function.Function
  - name: <
    fullName: <
  - uid: '? super T'
    name: '? super T'
    fullName: '? super T'
  - name: ','
    fullName: ','
  - uid: '? extends V'
    name: '? extends V'
    fullName: '? extends V'
  - name: '>'
    fullName: '>'
- uid: java.util.function.Supplier<M>
  spec.java:
  - uid: java.util.function.Supplier
    name: Supplier
    fullName: java.util.function.Supplier
  - name: <
    fullName: <
  - uid: M
    name: M
    fullName: M
  - name: '>'
    fullName: '>'
- uid: java.util.stream.Collector<T,?,M>
  spec.java:
  - uid: java.util.stream.Collector
    name: Collector
    fullName: java.util.stream.Collector
  - name: <
    fullName: <
  - uid: T
    name: T
    fullName: T
  - name: ','
    fullName: ','
  - uid: '?'
    name: '?'
    fullName: '?'
  - name: ','
    fullName: ','
  - uid: M
    name: M
    fullName: M
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.toMultimap*
  name: <T,K,V,M>toMultimap
  nameWithType: Multimaps.<T,K,V,M>toMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<T,K,V,M>toMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.function.Function<? super T,? extends java.util.stream.Stream<? extends V>>
  spec.java:
  - uid: java.util.function.Function
    name: Function
    fullName: java.util.function.Function
  - name: <
    fullName: <
  - uid: '? super T'
    name: '? super T'
    fullName: '? super T'
  - name: ','
    fullName: ','
  - uid: '? extends java.util.stream.Stream'
    name: Stream
    fullName: '? extends java.util.stream.Stream'
  - name: <
    fullName: <
  - uid: '? extends V'
    name: '? extends V'
    fullName: '? extends V'
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.flatteningToMultimap*
  name: <T,K,V,M>flatteningToMultimap
  nameWithType: Multimaps.<T,K,V,M>flatteningToMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<T,K,V,M>flatteningToMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Map<K,java.util.Collection<V>>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: java.util.Collection
    name: Collection
    fullName: java.util.Collection
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.Collection<V>>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Supplier
    name: Supplier
    fullName: com.azure.cosmos.implementation.guava25.base.Supplier
  - name: <
    fullName: <
  - uid: '? extends java.util.Collection'
    name: Collection
    fullName: '? extends java.util.Collection'
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.Multimap
    name: Multimap
    fullName: com.azure.cosmos.implementation.guava25.collect.Multimap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.newMultimap*
  name: <K,V>newMultimap
  nameWithType: Multimaps.<K,V>newMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.List<V>>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Supplier
    name: Supplier
    fullName: com.azure.cosmos.implementation.guava25.base.Supplier
  - name: <
    fullName: <
  - uid: '? extends java.util.List'
    name: List
    fullName: '? extends java.util.List'
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.ListMultimap
    name: ListMultimap
    fullName: com.azure.cosmos.implementation.guava25.collect.ListMultimap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.newListMultimap*
  name: <K,V>newListMultimap
  nameWithType: Multimaps.<K,V>newListMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newListMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.Set<V>>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Supplier
    name: Supplier
    fullName: com.azure.cosmos.implementation.guava25.base.Supplier
  - name: <
    fullName: <
  - uid: '? extends java.util.Set'
    name: Set
    fullName: '? extends java.util.Set'
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.SetMultimap
    name: SetMultimap
    fullName: com.azure.cosmos.implementation.guava25.collect.SetMultimap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.newSetMultimap*
  name: <K,V>newSetMultimap
  nameWithType: Multimaps.<K,V>newSetMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newSetMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.base.Supplier<? extends java.util.SortedSet<V>>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Supplier
    name: Supplier
    fullName: com.azure.cosmos.implementation.guava25.base.Supplier
  - name: <
    fullName: <
  - uid: '? extends java.util.SortedSet'
    name: SortedSet
    fullName: '? extends java.util.SortedSet'
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap<K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap
    name: SortedSetMultimap
    fullName: com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.newSortedSetMultimap*
  name: <K,V>newSortedSetMultimap
  nameWithType: Multimaps.<K,V>newSortedSetMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>newSortedSetMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Multimap<? extends V,? extends K>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.Multimap
    name: Multimap
    fullName: com.azure.cosmos.implementation.guava25.collect.Multimap
  - name: <
    fullName: <
  - uid: '? extends V'
    name: '? extends V'
    fullName: '? extends V'
  - name: ','
    fullName: ','
  - uid: '? extends K'
    name: '? extends K'
    fullName: '? extends K'
  - name: '>'
    fullName: '>'
- uid: M
  spec.java:
  - uid: M
    name: M
    fullName: M
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.invertFrom*
  name: <K,V,M>invertFrom
  nameWithType: Multimaps.<K,V,M>invertFrom
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V,M>invertFrom
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedMultimap*
  name: <K,V>synchronizedMultimap
  nameWithType: Multimaps.<K,V>synchronizedMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.unmodifiableMultimap*
  name: <K,V>unmodifiableMultimap
  nameWithType: Multimaps.<K,V>unmodifiableMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.ImmutableMultimap<K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.ImmutableMultimap
    name: ImmutableMultimap
    fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableMultimap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedSetMultimap*
  name: <K,V>synchronizedSetMultimap
  nameWithType: Multimaps.<K,V>synchronizedSetMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedSetMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.unmodifiableSetMultimap*
  name: <K,V>unmodifiableSetMultimap
  nameWithType: Multimaps.<K,V>unmodifiableSetMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableSetMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.ImmutableSetMultimap<K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.ImmutableSetMultimap
    name: ImmutableSetMultimap
    fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableSetMultimap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedSortedSetMultimap*
  name: <K,V>synchronizedSortedSetMultimap
  nameWithType: Multimaps.<K,V>synchronizedSortedSetMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedSortedSetMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.unmodifiableSortedSetMultimap*
  name: <K,V>unmodifiableSortedSetMultimap
  nameWithType: Multimaps.<K,V>unmodifiableSortedSetMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableSortedSetMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.synchronizedListMultimap*
  name: <K,V>synchronizedListMultimap
  nameWithType: Multimaps.<K,V>synchronizedListMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>synchronizedListMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.unmodifiableListMultimap*
  name: <K,V>unmodifiableListMultimap
  nameWithType: Multimaps.<K,V>unmodifiableListMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>unmodifiableListMultimap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap<K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap
    name: ImmutableListMultimap
    fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: java.util.Map<K,java.util.List<V>>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: java.util.List
    name: List
    fullName: java.util.List
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.asMap*
  name: <K,V>asMap
  nameWithType: Multimaps.<K,V>asMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>asMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Map<K,java.util.Set<V>>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: java.util.Set
    name: Set
    fullName: java.util.Set
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: java.util.Map<K,java.util.SortedSet<V>>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: java.util.SortedSet
    name: SortedSet
    fullName: java.util.SortedSet
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: java.util.Map<K,V>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.forMap*
  name: <K,V>forMap
  nameWithType: Multimaps.<K,V>forMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>forMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V1>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.Multimap
    name: Multimap
    fullName: com.azure.cosmos.implementation.guava25.collect.Multimap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V1
    name: V1
    fullName: V1
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Function
    name: Function
    fullName: com.azure.cosmos.implementation.guava25.base.Function
  - name: <
    fullName: <
  - uid: '? super V1'
    name: '? super V1'
    fullName: '? super V1'
  - name: ','
    fullName: ','
  - uid: V2
    name: V2
    fullName: V2
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimap<K,V2>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.Multimap
    name: Multimap
    fullName: com.azure.cosmos.implementation.guava25.collect.Multimap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V2
    name: V2
    fullName: V2
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.transformValues*
  name: <K,V1,V2>transformValues
  nameWithType: Multimaps.<K,V1,V2>transformValues
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformValues
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V1>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.ListMultimap
    name: ListMultimap
    fullName: com.azure.cosmos.implementation.guava25.collect.ListMultimap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V1
    name: V1
    fullName: V1
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V2>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.ListMultimap
    name: ListMultimap
    fullName: com.azure.cosmos.implementation.guava25.collect.ListMultimap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V2
    name: V2
    fullName: V2
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer
    name: EntryTransformer
    fullName: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer
  - name: <
    fullName: <
  - uid: '? super K'
    name: '? super K'
    fullName: '? super K'
  - name: ','
    fullName: ','
  - uid: '? super V1'
    name: '? super V1'
    fullName: '? super V1'
  - name: ','
    fullName: ','
  - uid: V2
    name: V2
    fullName: V2
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.transformEntries*
  name: <K,V1,V2>transformEntries
  nameWithType: Multimaps.<K,V1,V2>transformEntries
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V1,V2>transformEntries
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.lang.Iterable<V>
  spec.java:
  - uid: java.lang.Iterable
    name: Iterable
    fullName: java.lang.Iterable
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.base.Function<? super V,K>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Function
    name: Function
    fullName: com.azure.cosmos.implementation.guava25.base.Function
  - name: <
    fullName: <
  - uid: '? super V'
    name: '? super V'
    fullName: '? super V'
  - name: ','
    fullName: ','
  - uid: K
    name: K
    fullName: K
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.index*
  name: <K,V>index
  nameWithType: Multimaps.<K,V>index
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>index
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Iterator<V>
  spec.java:
  - uid: java.util.Iterator
    name: Iterator
    fullName: java.util.Iterator
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.base.Predicate<? super K>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Predicate
    name: Predicate
    fullName: com.azure.cosmos.implementation.guava25.base.Predicate
  - name: <
    fullName: <
  - uid: '? super K'
    name: '? super K'
    fullName: '? super K'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.filterKeys*
  name: <K,V>filterKeys
  nameWithType: Multimaps.<K,V>filterKeys
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.base.Predicate<? super V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Predicate
    name: Predicate
    fullName: com.azure.cosmos.implementation.guava25.base.Predicate
  - name: <
    fullName: <
  - uid: '? super V'
    name: '? super V'
    fullName: '? super V'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.filterValues*
  name: <K,V>filterValues
  nameWithType: Multimaps.<K,V>filterValues
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterValues
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Predicate
    name: Predicate
    fullName: com.azure.cosmos.implementation.guava25.base.Predicate
  - name: <
    fullName: <
  - uid: '? super java.util.Map.Entry'
    name: Entry
    fullName: '? super java.util.Map.Entry'
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Multimaps.filterEntries*
  name: <K,V>filterEntries
  nameWithType: Multimaps.<K,V>filterEntries
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterEntries
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.lang.Object.notify()
  name: Object.notify()
  nameWithType: Object.notify()
  fullName: java.lang.Object.notify()
- uid: java.lang.Object.wait()
  name: Object.wait()
  nameWithType: Object.wait()
  fullName: java.lang.Object.wait()
- uid: java.lang.Object.finalize()
  name: Object.finalize()
  nameWithType: Object.finalize()
  fullName: java.lang.Object.finalize()
- uid: java.lang.Object.clone()
  name: Object.clone()
  nameWithType: Object.clone()
  fullName: java.lang.Object.clone()
- uid: java.lang.Object.notifyAll()
  name: Object.notifyAll()
  nameWithType: Object.notifyAll()
  fullName: java.lang.Object.notifyAll()
- uid: java.lang.Object.equals(java.lang.Object)
  name: Object.equals(Object)
  nameWithType: Object.equals(Object)
  fullName: java.lang.Object.equals(java.lang.Object)
- uid: java.lang.Object.getClass()
  name: Object.getClass()
  nameWithType: Object.getClass()
  fullName: java.lang.Object.getClass()
- uid: java.lang.Object.wait(long)
  name: Object.wait(long)
  nameWithType: Object.wait(long)
  fullName: java.lang.Object.wait(long)
- uid: java.lang.Object.hashCode()
  name: Object.hashCode()
  nameWithType: Object.hashCode()
  fullName: java.lang.Object.hashCode()
- uid: java.lang.Object.wait(long,int)
  name: Object.wait(long,int)
  nameWithType: Object.wait(long,int)
  fullName: java.lang.Object.wait(long,int)
- uid: java.lang.Object.toString()
  name: Object.toString()
  nameWithType: Object.toString()
  fullName: java.lang.Object.toString()
- uid: '? super T,? extends K'
  name: '? super T,? extends K'
  nameWithType: '? super T,? extends K'
  fullName: '? super T,? extends K'
- uid: java.util.function.Function
  name: Function
  nameWithType: Function
  fullName: java.util.function.Function
- uid: '? super T,? extends V'
  name: '? super T,? extends V'
  nameWithType: '? super T,? extends V'
  fullName: '? super T,? extends V'
- uid: java.util.function.Supplier
  name: Supplier
  nameWithType: Supplier
  fullName: java.util.function.Supplier
- uid: java.util.stream.Collector
  name: Collector
  nameWithType: Collector
  fullName: java.util.stream.Collector
- uid: T,?,M
  name: T,?,M
  nameWithType: T,?,M
  fullName: T,?,M
- uid: '? extends V'
  name: '? extends V'
  nameWithType: '? extends V'
  fullName: '? extends V'
- uid: '? super T,? extends java.util.stream.Stream'
  name: '? super T,? extends Stream'
  nameWithType: '? super T,? extends Stream'
  fullName: '? super T,? extends java.util.stream.Stream'
- uid: V
  name: V
  nameWithType: V
  fullName: V
- uid: java.util.Map
  name: Map
  nameWithType: Map
  fullName: java.util.Map
- uid: K,java.util.Collection
  name: K,Collection
  nameWithType: K,Collection
  fullName: K,java.util.Collection
- uid: com.azure.cosmos.implementation.guava25.base.Supplier
  name: Supplier
  nameWithType: Supplier
  fullName: com.azure.cosmos.implementation.guava25.base.Supplier
- uid: '? extends java.util.Collection'
  name: '? extends Collection'
  nameWithType: '? extends Collection'
  fullName: '? extends java.util.Collection'
- uid: K,V
  name: K,V
  nameWithType: K,V
  fullName: K,V
- uid: com.azure.cosmos.implementation.guava25.collect.Multimap
  name: Multimap
  nameWithType: Multimap
  fullName: com.azure.cosmos.implementation.guava25.collect.Multimap
- uid: '? extends java.util.List'
  name: '? extends List'
  nameWithType: '? extends List'
  fullName: '? extends java.util.List'
- uid: com.azure.cosmos.implementation.guava25.collect.ListMultimap
  name: ListMultimap
  nameWithType: ListMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.ListMultimap
- uid: '? extends java.util.Set'
  name: '? extends Set'
  nameWithType: '? extends Set'
  fullName: '? extends java.util.Set'
- uid: com.azure.cosmos.implementation.guava25.collect.SetMultimap
  name: SetMultimap
  nameWithType: SetMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.SetMultimap
- uid: '? extends java.util.SortedSet'
  name: '? extends SortedSet'
  nameWithType: '? extends SortedSet'
  fullName: '? extends java.util.SortedSet'
- uid: com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap
  name: SortedSetMultimap
  nameWithType: SortedSetMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.SortedSetMultimap
- uid: '? extends V,? extends K'
  name: '? extends V,? extends K'
  nameWithType: '? extends V,? extends K'
  fullName: '? extends V,? extends K'
- uid: com.azure.cosmos.implementation.guava25.collect.ImmutableMultimap
  name: ImmutableMultimap
  nameWithType: ImmutableMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableMultimap
- uid: com.azure.cosmos.implementation.guava25.collect.ImmutableSetMultimap
  name: ImmutableSetMultimap
  nameWithType: ImmutableSetMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableSetMultimap
- uid: com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap
  name: ImmutableListMultimap
  nameWithType: ImmutableListMultimap
  fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap
- uid: K,java.util.List
  name: K,List
  nameWithType: K,List
  fullName: K,java.util.List
- uid: K,java.util.Set
  name: K,Set
  nameWithType: K,Set
  fullName: K,java.util.Set
- uid: K,java.util.SortedSet
  name: K,SortedSet
  nameWithType: K,SortedSet
  fullName: K,java.util.SortedSet
- uid: K,V1
  name: K,V1
  nameWithType: K,V1
  fullName: K,V1
- uid: com.azure.cosmos.implementation.guava25.base.Function
  name: Function
  nameWithType: Function
  fullName: com.azure.cosmos.implementation.guava25.base.Function
- uid: '? super V1,V2'
  name: '? super V1,V2'
  nameWithType: '? super V1,V2'
  fullName: '? super V1,V2'
- uid: K,V2
  name: K,V2
  nameWithType: K,V2
  fullName: K,V2
- uid: '? super K,? super V1,V2'
  name: '? super K,? super V1,V2'
  nameWithType: '? super K,? super V1,V2'
  fullName: '? super K,? super V1,V2'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer
  name: Maps.EntryTransformer
  nameWithType: Maps.EntryTransformer
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer
- uid: java.lang.Iterable
  name: Iterable
  nameWithType: Iterable
  fullName: java.lang.Iterable
- uid: '? super V,K'
  name: '? super V,K'
  nameWithType: '? super V,K'
  fullName: '? super V,K'
- uid: java.util.Iterator
  name: Iterator
  nameWithType: Iterator
  fullName: java.util.Iterator
- uid: com.azure.cosmos.implementation.guava25.base.Predicate
  name: Predicate
  nameWithType: Predicate
  fullName: com.azure.cosmos.implementation.guava25.base.Predicate
- uid: '? super K'
  name: '? super K'
  nameWithType: '? super K'
  fullName: '? super K'
- uid: '? super V'
  name: '? super V'
  nameWithType: '? super V'
  fullName: '? super V'
- uid: '? super java.util.Map.Entry'
  name: '? super Map.Entry'
  nameWithType: '? super Map.Entry'
  fullName: '? super java.util.Map.Entry'
