### YamlMime:JavaType
uid: "com.azure.messaging.eventhubs.EventHubProducerClient"
fullName: "com.azure.messaging.eventhubs.EventHubProducerClient"
name: "EventHubProducerClient"
nameWithType: "EventHubProducerClient"
summary: "A **synchronous** producer responsible for transmitting <xref uid=\"com.azure.messaging.eventhubs.EventData\" data-throw-if-not-resolved=\"false\">EventData</xref> to a specific Event Hub, grouped together in batches. Depending on the <xref uid=\"com.azure.messaging.eventhubs.models.CreateBatchOptions\" data-throw-if-not-resolved=\"false\">options</xref> specified when creating an <xref uid=\"com.azure.messaging.eventhubs.EventDataBatch\" data-throw-if-not-resolved=\"false\">EventDataBatch</xref>, the events may be automatically routed to an available partition or specific to a partition.\n\nAllowing automatic routing of partitions is recommended when:\n\n *  The sending of events needs to be highly available.\n *  The event data should be evenly distributed among all available partitions.\n\nIf no partition id is specified, the following rules are used for automatically selecting one:\n\n1.  Distribute the events equally amongst all available partitions using a round-robin approach.\n2.  If a partition becomes unavailable, the Event Hubs service will automatically detect it and forward the message to another available partition.\n\n**Create a producer and publish events to any partition**\n\n```java\n// The required parameter is a way to authenticate with Event Hubs using credentials.\n // The connectionString provides a way to authenticate with Event Hub.\n EventHubProducerClient producer = new EventHubClientBuilder()\n     .connectionString(\n         \"Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};SharedAccessKey={key}\",\n         \"event-hub-name\")\n     .buildProducerClient();\n List<EventData> events = Arrays.asList(new EventData(\"test-event-1\"), new EventData(\"test-event-2\"));\n \n // Creating a batch without options set, will allow for automatic routing of events to any partition.\n EventDataBatch batch = producer.createBatch();\n for (EventData event : events) {\n     if (batch.tryAdd(event)) {\n         continue;\n     }\n \n     producer.send(batch);\n     batch = producer.createBatch();\n     if (!batch.tryAdd(event)) {\n         throw new IllegalArgumentException(\"Event is too large for an empty batch.\");\n     }\n }\n```\n\n**Publish events to partition \"foo\"**\n\n```java\n// Creating a batch with partitionId set will route all events in that batch to partition `foo`.\n CreateBatchOptions options = new CreateBatchOptions().setPartitionId(\"foo\");\n \n EventDataBatch batch = producer.createBatch(options);\n batch.tryAdd(new EventData(\"data-to-partition-foo\"));\n producer.send(batch);\n```\n\n**Publish events to the same partition, grouped together using partition key**\n\n```java\nList<EventData> events = Arrays.asList(new EventData(\"sourdough\"), new EventData(\"rye\"),\n     new EventData(\"wheat\"));\n \n // Creating a batch with partitionKey set will tell the service to hash the partitionKey and decide which\n // partition to send the events to. Events with the same partitionKey are always routed to the same partition.\n CreateBatchOptions options = new CreateBatchOptions().setPartitionKey(\"bread\");\n EventDataBatch batch = producer.createBatch(options);\n \n events.forEach(event -> batch.tryAdd(event));\n producer.send(batch);\n```\n\n**Publish events using a size-limited <xref uid=\"com.azure.messaging.eventhubs.EventDataBatch\" data-throw-if-not-resolved=\"false\">EventDataBatch</xref>**\n\n```java\nfinal List<EventData> telemetryEvents = Arrays.asList(firstEvent, secondEvent, thirdEvent);\n \n // Setting `setMaximumSizeInBytes` when creating a batch, limits the size of that batch.\n // In this case, all the batches created with these options are limited to 256 bytes.\n final CreateBatchOptions options = new CreateBatchOptions()\n     .setMaximumSizeInBytes(256);\n \n EventDataBatch currentBatch = producer.createBatch(options);\n \n // For each telemetry event, we try to add it to the current batch.\n // When the batch is full, send it then create another batch to add more events to.\n for (EventData event : telemetryEvents) {\n     if (!currentBatch.tryAdd(event)) {\n         producer.send(currentBatch);\n         currentBatch = producer.createBatch(options);\n \n         // Add the event we couldn't before.\n         if (!currentBatch.tryAdd(event)) {\n             throw new IllegalArgumentException(\"Event is too large for an empty batch.\");\n         }\n     }\n }\n```"
inheritances:
- "<xref href=\"java.lang.Object\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
syntax: "public class EventHubProducerClient implements Closeable"
methods:
- "com.azure.messaging.eventhubs.EventHubProducerClient.close()"
- "com.azure.messaging.eventhubs.EventHubProducerClient.createBatch()"
- "com.azure.messaging.eventhubs.EventHubProducerClient.createBatch(com.azure.messaging.eventhubs.models.CreateBatchOptions)"
- "com.azure.messaging.eventhubs.EventHubProducerClient.getEventHubName()"
- "com.azure.messaging.eventhubs.EventHubProducerClient.getEventHubProperties()"
- "com.azure.messaging.eventhubs.EventHubProducerClient.getFullyQualifiedNamespace()"
- "com.azure.messaging.eventhubs.EventHubProducerClient.getPartitionIds()"
- "com.azure.messaging.eventhubs.EventHubProducerClient.getPartitionProperties(java.lang.String)"
- "com.azure.messaging.eventhubs.EventHubProducerClient.send(com.azure.messaging.eventhubs.EventDataBatch)"
- "com.azure.messaging.eventhubs.EventHubProducerClient.send(java.lang.Iterable<com.azure.messaging.eventhubs.EventData>)"
- "com.azure.messaging.eventhubs.EventHubProducerClient.send(java.lang.Iterable<com.azure.messaging.eventhubs.EventData>,com.azure.messaging.eventhubs.models.SendOptions)"
type: "class"
implements:
- "<xref href=\"java.io.Closeable?alt=java.io.Closeable&text=Closeable\" data-throw-if-not-resolved=\"False\" />"
metadata: {}
package: "com.azure.messaging.eventhubs"
artifact: com.azure:azure-messaging-eventhubs:5.3.0
