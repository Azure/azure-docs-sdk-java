### YamlMime:JavaPackage
uid: "com.azure.messaging.eventhubs"
fullName: "com.azure.messaging.eventhubs"
name: "com.azure.messaging.eventhubs"
summary: "<p><a href=\"https://learn.microsoft.com/azure/event-hubs/event-hubs-about\">Azure Event Hubs</a> is a highly scalable\n publish-subscribe service that can ingest millions of events per second and stream them to multiple consumers."
classes:
- "com.azure.messaging.eventhubs.EventData"
- "com.azure.messaging.eventhubs.EventDataBatch"
- "com.azure.messaging.eventhubs.EventHubBufferedProducerAsyncClient"
- "com.azure.messaging.eventhubs.EventHubBufferedProducerClient"
- "com.azure.messaging.eventhubs.EventHubBufferedProducerClientBuilder"
- "com.azure.messaging.eventhubs.EventHubClientBuilder"
- "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient"
- "com.azure.messaging.eventhubs.EventHubConsumerClient"
- "com.azure.messaging.eventhubs.EventHubProducerAsyncClient"
- "com.azure.messaging.eventhubs.EventHubProducerClient"
- "com.azure.messaging.eventhubs.EventHubProperties"
- "com.azure.messaging.eventhubs.EventProcessorClient"
- "com.azure.messaging.eventhubs.EventProcessorClientBuilder"
- "com.azure.messaging.eventhubs.PartitionProperties"
enums:
- "com.azure.messaging.eventhubs.LoadBalancingStrategy"
- "com.azure.messaging.eventhubs.Messages"
interfaces:
- "com.azure.messaging.eventhubs.CheckpointStore"
desc: "<p><a href=\"https://learn.microsoft.com/azure/event-hubs/event-hubs-about\">Azure Event Hubs</a> is a highly scalable\n publish-subscribe service that can ingest millions of events per second and stream them to multiple consumers. This\n lets you process and analyze the massive amounts of data produced by your connected devices and applications. Once\n Event Hubs has collected the data, you can retrieve, transform, and store it by using any real-time analytics\n provider or with batching/storage adapters.</p>\n\n <p>The Azure Event Hubs client library allows Java developers to interact with Azure Event Hubs. It provides a set\n of clients that enable Java developers to publish events to and consume events from an Event Hub.</p>\n\n <h2>Key Concepts</h2>\n\n <ul>\n      <li><strong>Event Hub producer:</strong>  A source of telemetry data, diagnostics information, usage logs, or\n      other data, as part of an embedded device solution, a mobile device application, a game title running on a\n      console or other device, some client or server based business solution, or a website</li>\n\n      <li><strong>Event Hub consumer:</strong>  Fetches events published to an Event Hub and processes it.  Processing\n      may involve aggregation, complex computation, and filtering. Processing may also involve distribution or storage\n      of the information in a raw or transformed fashion. Event Hub consumers are often robust and high-scale platform\n      infrastructure parts with built-in analytics capabilities, like Azure Stream Analytics, Apache Spark, or Apache\n      Storm.</li>\n\n      <li><strong>Partition:</strong>  An ordered sequence of events that is held in an Event Hub. Azure Event Hubs\n      provides message streaming through a partitioned consumer pattern in which each consumer only reads a specific\n      subset, or partition, of the message stream. As newer events arrive, they are added to the end of this sequence.\n      The number of partitions is specified at the time an Event Hub is created and cannot be changed.</li>\n\n      <li><strong>Consumer group:</strong>  A view of an entire Event Hub. Consumer groups enable multiple consuming\n      applications to each have a separate view of the event stream, and to read the stream independently at their own\n      pace and from their own position. There can be at most 5 concurrent readers on a partition per consumer group;\n      however it is recommended that there is only one active consumer for a given partition and consumer group\n      pairing. Each active reader receives the events from its partition; if there are multiple readers on the same\n      partition, then they will receive duplicate events.</li>\n\n      <li><strong>Stream offset:</strong>  The position of an event within an Event Hub partition.  It is a\n      client-side cursor that specifies the point in the stream where the event is located.  The offset of an\n      event can change as events expire from the stream.</li>\n\n      <li><strong>Stream sequence number:</strong> A number assigned to the event when it was enqueued in the\n      associated Event Hub partition. This is unique for every message received in the Event Hub partition.</li>\n\n      <li><strong>Checkpointing:</strong>  A process by which readers mark or commit their position within a\n      partition event sequence. Checkpointing is the responsibility of the consumer and occurs on a per-partition\n      basis within a consumer group. This responsibility means that for each consumer group, each partition reader\n      must keep track of its current position in the event stream, and can inform the service when it considers the\n      data stream complete.</li>\n </ul>\n\n <h2>Getting Started</h2>\n\n <p>Service clients are the point of interaction for developers to use Azure Event Hubs.\n <xref uid=\"com.azure.messaging.eventhubs.EventHubProducerClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubProducerClient\"></xref> and\n <xref uid=\"com.azure.messaging.eventhubs.EventHubProducerAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubProducerAsyncClient\"></xref> are the sync and async clients for publishing\n events to an Event Hub.  Similarly, <xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubConsumerClient\"></xref> and\n <xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient\"></xref> are the sync and async clients for consuming\n events from an Event Hub.  In production scenarios, we recommend users leverage\n <xref uid=\"com.azure.messaging.eventhubs.EventProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventProcessorClient\"></xref> because consumes events from all Event Hub partition, load\n balances work between multiple instances of <xref uid=\"com.azure.messaging.eventhubs.EventProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventProcessorClient\"></xref> and can\n perform checkpointing.</p>\n\n <p>The examples shown in this document use a credential object named DefaultAzureCredential for authentication,\n which is appropriate for most scenarios, including local development and production environments. Additionally, we\n recommend using\n <a href=\"https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/\">managed identity</a>\n for authentication in production environments. You can find more information on different ways of authenticating and\n their corresponding credential types in the\n <a href=\"https://learn.microsoft.com/java/api/overview/azure/identity-readme\">Azure Identity documentation\"</a>.\n </p>\n\n <h3>Publishing events</h3>\n\n <p>This library provides several ways to publish events to Azure Event Hubs.  There is a producer client, that sends\n events immediately to Azure Event Hubs and a buffered producer, that batches events together in the background and\n publishes them later. These two clients have synchronous and asynchronous versions.  The samples below demonstrate\n simple scenarios, more snippets can be found in the class documentation for\n <xref uid=\"com.azure.messaging.eventhubs.EventHubProducerClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubProducerClient\"></xref>,\n <xref uid=\"com.azure.messaging.eventhubs.EventHubProducerAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubProducerAsyncClient\"></xref>,\n <xref uid=\"com.azure.messaging.eventhubs.EventHubBufferedProducerClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubBufferedProducerClient\"></xref>, and\n <xref uid=\"com.azure.messaging.eventhubs.EventHubBufferedProducerAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubBufferedProducerAsyncClient\"></xref>.</p>\n\n <p>In the following snippets, <code>fullyQualifiedNamespace</code> is the Event Hubs Namespace's host name.  It is listed\n under the \"Essentials\" panel after navigating to the Event Hubs Namespace via Azure Portal.  The credential used is\n <code>DefaultAzureCredential</code> because it combines commonly used credentials in deployment and development and\n chooses the credential to used based on its running environment.</p>\n\n <p><strong>Sample: Construct a synchronous producer and publish events</strong></p>\n\n <p>The following code sample demonstrates the creation of the synchronous client\n <xref uid=\"com.azure.messaging.eventhubs.EventHubProducerClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubProducerClient\"></xref>.</p>\n\n <!-- src_embed com.azure.messaging.eventhubs.eventhubproducerclient.createBatch -->\n <pre>\n TokenCredential credential = new DefaultAzureCredentialBuilder&#40;&#41;.build&#40;&#41;;\n\n EventHubProducerClient producer = new EventHubClientBuilder&#40;&#41;\n     .credential&#40;&quot;&lt;&lt;fully-qualified-namespace&gt;&gt;&quot;, &quot;&lt;&lt;event-hub-name&gt;&gt;&quot;,\n         credential&#41;\n     .buildProducerClient&#40;&#41;;\n\n List&lt;EventData&gt; allEvents = Arrays.asList&#40;new EventData&#40;&quot;Foo&quot;&#41;, new EventData&#40;&quot;Bar&quot;&#41;&#41;;\n EventDataBatch eventDataBatch = producer.createBatch&#40;&#41;;\n\n for &#40;EventData eventData : allEvents&#41; &#123;\n     if &#40;!eventDataBatch.tryAdd&#40;eventData&#41;&#41; &#123;\n         producer.send&#40;eventDataBatch&#41;;\n         eventDataBatch = producer.createBatch&#40;&#41;;\n\n         &#47;&#47; Try to add that event that couldn't fit before.\n         if &#40;!eventDataBatch.tryAdd&#40;eventData&#41;&#41; &#123;\n             throw new IllegalArgumentException&#40;&quot;Event is too large for an empty batch. Max size: &quot;\n                 + eventDataBatch.getMaxSizeInBytes&#40;&#41;&#41;;\n         &#125;\n     &#125;\n &#125;\n\n &#47;&#47; send the last batch of remaining events\n if &#40;eventDataBatch.getCount&#40;&#41; &gt; 0&#41; &#123;\n     producer.send&#40;eventDataBatch&#41;;\n &#125;\n\n &#47;&#47; Clients are expected to be long-lived objects.\n &#47;&#47; Dispose of the producer to close any underlying resources when we are finished with it.\n producer.close&#40;&#41;;\n </pre>\n <!-- end com.azure.messaging.eventhubs.eventhubproducerclient.createBatch -->\n\n <p><strong>Sample: Creating an <xref uid=\"com.azure.messaging.eventhubs.EventHubBufferedProducerClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubBufferedProducerClient\"></xref> and enqueuing\n events</strong></p>\n\n <p>The following code sample demonstrates the creation of the synchronous client\n <xref uid=\"com.azure.messaging.eventhubs.EventHubBufferedProducerClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubBufferedProducerClient\"></xref> as well as enqueueing events.  The producer is\n set to publish events every 60 seconds with a buffer size of 1500 events for each partition.</p>\n\n <!-- src_embed com.azure.messaging.eventhubs.eventhubbufferedproducerclient.enqueueEvents-iterable -->\n <pre>\n TokenCredential credential = new DefaultAzureCredentialBuilder&#40;&#41;.build&#40;&#41;;\n\n &#47;&#47; &quot;&lt;&lt;fully-qualified-namespace&gt;&gt;&quot; will look similar to &quot;&#123;your-namespace&#125;.servicebus.windows.net&quot;\n &#47;&#47; &quot;&lt;&lt;event-hub-name&gt;&gt;&quot; will be the name of the Event Hub instance you created inside the Event Hubs namespace.\n EventHubBufferedProducerClient client = new EventHubBufferedProducerClientBuilder&#40;&#41;\n     .credential&#40;&quot;fully-qualified-namespace&quot;, &quot;event-hub-name&quot;, credential&#41;\n     .onSendBatchSucceeded&#40;succeededContext -&gt; &#123;\n         System.out.println&#40;&quot;Successfully published events to: &quot; + succeededContext.getPartitionId&#40;&#41;&#41;;\n     &#125;&#41;\n     .onSendBatchFailed&#40;failedContext -&gt; &#123;\n         System.out.printf&#40;&quot;Failed to published events to %s. Error: %s%n&quot;,\n             failedContext.getPartitionId&#40;&#41;, failedContext.getThrowable&#40;&#41;&#41;;\n     &#125;&#41;\n     .buildClient&#40;&#41;;\n\n List&lt;EventData&gt; events = Arrays.asList&#40;new EventData&#40;&quot;maple&quot;&#41;, new EventData&#40;&quot;aspen&quot;&#41;,\n     new EventData&#40;&quot;oak&quot;&#41;&#41;;\n\n &#47;&#47; Enqueues the events to be published.\n client.enqueueEvents&#40;events&#41;;\n\n &#47;&#47; Seconds later, enqueue another event.\n client.enqueueEvent&#40;new EventData&#40;&quot;bonsai&quot;&#41;&#41;;\n\n &#47;&#47; Causes any buffered events to be flushed before closing underlying connection.\n client.close&#40;&#41;;\n </pre>\n <!-- end com.azure.messaging.eventhubs.eventhubbufferedproducerclient.enqueueEvents-iterable -->\n\n <h3>Consuming events</h3>\n\n <p>This library provides several ways to consume events from Azure Event Hubs.  There are consumer clients,\n <xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubConsumerClient\"></xref> and\n <xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient\"></xref>, which fetches events from either a single\n partition or all partitions in an Event Hub.  For production, we recommend\n <xref uid=\"com.azure.messaging.eventhubs.EventProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventProcessorClient\"></xref> whose checkpoints are backed by a durable storage such as\n Azure Blob Storage.  The samples below demonstrate simple scenarios, more snippets can be found in the class\n documentation for <xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubConsumerClient\"></xref>,\n <xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient\"></xref>, and\n <xref uid=\"com.azure.messaging.eventhubs.EventProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventProcessorClient\"></xref>.</p>\n\n <p>In the following snippets, <code>fullyQualifiedNamespace</code> is the Event Hubs Namespace's host name.  It is listed\n under the \"Essentials\" panel after navigating to the Event Hubs Namespace via Azure Portal.  The credential used is\n <code>DefaultAzureCredential</code> because it combines commonly used credentials in deployment and development and\n chooses the credential to used based on its running environment.  The <code>consumerGroup</code> is found by navigating\n to the Event Hub instance, and selecting \"Consumer groups\" under the \"Entities\" panel. The <code>consumerGroup</code> is\n required for creating consumer clients.</p>\n\n <p>The credential used is <code>DefaultAzureCredential</code> because it combines\n commonly used credentials in deployment and development and chooses the credential to used based on its running\n environment.</p>\n\n <p><strong>Sample: Construct a synchronous consumer and receive events</strong></p>\n\n <p>The following code sample demonstrates the creation of the synchronous client\n <xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventHubConsumerClient\"></xref>.  In addition, it receives the first 100 events that\n were enqueued 12 hours ago.  If there are less than 100 events, the ones fetched within <code>maxWaitTime</code> of 30\n seconds are returned.</p>\n\n <!-- src_embed com.azure.messaging.eventhubs.eventhubconsumerclient.receive#string-int-eventposition-duration -->\n <pre>\n TokenCredential credential = new DefaultAzureCredentialBuilder&#40;&#41;.build&#40;&#41;;\n\n &#47;&#47; &quot;&lt;&lt;fully-qualified-namespace&gt;&gt;&quot; will look similar to &quot;&#123;your-namespace&#125;.servicebus.windows.net&quot;\n &#47;&#47; &quot;&lt;&lt;event-hub-name&gt;&gt;&quot; will be the name of the Event Hub instance you created inside the Event Hubs namespace.\n EventHubConsumerClient consumer = new EventHubClientBuilder&#40;&#41;\n     .credential&#40;&quot;&lt;&lt;fully-qualified-namespace&gt;&gt;&quot;, &quot;&lt;&lt;event-hub-name&gt;&gt;&quot;,\n         credential&#41;\n     .consumerGroup&#40;EventHubClientBuilder.DEFAULT_CONSUMER_GROUP_NAME&#41;\n     .buildConsumerClient&#40;&#41;;\n\n Instant twelveHoursAgo = Instant.now&#40;&#41;.minus&#40;Duration.ofHours&#40;12&#41;&#41;;\n EventPosition startingPosition = EventPosition.fromEnqueuedTime&#40;twelveHoursAgo&#41;;\n String partitionId = &quot;0&quot;;\n\n &#47;&#47; Reads events from partition '0' and returns the first 100 received or until the 30 seconds has elapsed.\n IterableStream&lt;PartitionEvent&gt; events = consumer.receiveFromPartition&#40;partitionId, 100,\n     startingPosition, Duration.ofSeconds&#40;30&#41;&#41;;\n\n Long lastSequenceNumber = -1L;\n for &#40;PartitionEvent partitionEvent : events&#41; &#123;\n     &#47;&#47; For each event, perform some sort of processing.\n     System.out.print&#40;&quot;Event received: &quot; + partitionEvent.getData&#40;&#41;.getSequenceNumber&#40;&#41;&#41;;\n     lastSequenceNumber = partitionEvent.getData&#40;&#41;.getSequenceNumber&#40;&#41;;\n &#125;\n\n &#47;&#47; Figure out what the next EventPosition to receive from is based on last event we processed in the stream.\n &#47;&#47; If lastSequenceNumber is -1L, then we didn't see any events the first time we fetched events from the\n &#47;&#47; partition.\n if &#40;lastSequenceNumber != -1L&#41; &#123;\n     EventPosition nextPosition = EventPosition.fromSequenceNumber&#40;lastSequenceNumber, false&#41;;\n\n     &#47;&#47; Gets the next set of events from partition '0' to consume and process.\n     IterableStream&lt;PartitionEvent&gt; nextEvents = consumer.receiveFromPartition&#40;partitionId, 100,\n         nextPosition, Duration.ofSeconds&#40;30&#41;&#41;;\n &#125;\n </pre>\n <!-- end com.azure.messaging.eventhubs.eventhubconsumerclient.receive#string-int-eventposition-duration -->\n\n <p><strong>Sample: Construct an <xref uid=\"com.azure.messaging.eventhubs.EventProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.EventProcessorClient\"></xref></strong></p>\n\n <p>The following code sample demonstrates the creation of the processor client.  The processor client is recommended\n for production scenarios because it can load balance between multiple running instances, can perform checkpointing,\n and reconnects on transient failures such as network outages.  The sample below uses an in-memory\n <xref uid=\"com.azure.messaging.eventhubs.CheckpointStore\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.eventhubs.CheckpointStore\"></xref> but\n <a href=\"https://central.sonatype.com/artifact/com.azure/azure-messaging-eventhubs-checkpointstore-blob\">\n     azure-messaging-eventhubs-checkpointstore-blob</a> provides a checkpoint store backed by Azure Blob Storage.\n </p>\n\n<!-- src_embed com.azure.messaging.eventhubs.eventprocessorclient.startstop -->\n <pre>\n TokenCredential credential = new DefaultAzureCredentialBuilder&#40;&#41;.build&#40;&#41;;\n\n &#47;&#47; &quot;&lt;&lt;fully-qualified-namespace&gt;&gt;&quot; will look similar to &quot;&#123;your-namespace&#125;.servicebus.windows.net&quot;\n &#47;&#47; &quot;&lt;&lt;event-hub-name&gt;&gt;&quot; will be the name of the Event Hub instance you created inside the Event Hubs namespace.\n EventProcessorClient eventProcessorClient = new EventProcessorClientBuilder&#40;&#41;\n     .consumerGroup&#40;EventHubClientBuilder.DEFAULT_CONSUMER_GROUP_NAME&#41;\n     .credential&#40;&quot;&lt;&lt;fully-qualified-namespace&gt;&gt;&quot;, &quot;&lt;&lt;event-hub-name&gt;&gt;&quot;,\n         credential&#41;\n     .processEvent&#40;eventContext -&gt; &#123;\n         System.out.printf&#40;&quot;Partition id = %s and sequence number of event = %s%n&quot;,\n             eventContext.getPartitionContext&#40;&#41;.getPartitionId&#40;&#41;,\n             eventContext.getEventData&#40;&#41;.getSequenceNumber&#40;&#41;&#41;;\n     &#125;&#41;\n     .processError&#40;errorContext -&gt; &#123;\n         System.out.printf&#40;&quot;Error occurred in partition processor for partition %s, %s%n&quot;,\n             errorContext.getPartitionContext&#40;&#41;.getPartitionId&#40;&#41;,\n             errorContext.getThrowable&#40;&#41;&#41;;\n     &#125;&#41;\n     .checkpointStore&#40;new SampleCheckpointStore&#40;&#41;&#41;\n     .buildEventProcessorClient&#40;&#41;;\n\n eventProcessorClient.start&#40;&#41;;\n\n &#47;&#47; Continue to perform other tasks while the processor is running in the background.\n &#47;&#47;\n &#47;&#47; Finally, stop the processor client when application is finished.\n eventProcessorClient.stop&#40;&#41;;\n </pre>\n<!-- end com.azure.messaging.eventhubs.eventprocessorclient.startstop -->"
metadata: {}
package: "com.azure.messaging.eventhubs"
artifact: com.azure:azure-messaging-eventhubs:5.18.0
