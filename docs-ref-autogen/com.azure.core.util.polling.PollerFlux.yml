### YamlMime:JavaType
uid: "com.azure.core.util.polling.PollerFlux"
fullName: "com.azure.core.util.polling.PollerFlux<T,U>"
name: "PollerFlux<T,U>"
nameWithType: "PollerFlux<T,U>"
summary: "A Flux that simplifies the task of executing long running operations against an Azure service."
inheritances:
- "<xref href=\"java.lang.Object?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"reactor.core.publisher.Flux?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
- "reactor.core.publisher.Flux.<A>reduce(A,java.util.function.BiFunction<A,? super T,A>)"
- "reactor.core.publisher.Flux.<A>reduceWith(java.util.function.Supplier<A>,java.util.function.BiFunction<A,? super T,A>)"
- "reactor.core.publisher.Flux.<A>scan(A,java.util.function.BiFunction<A,? super T,A>)"
- "reactor.core.publisher.Flux.<A>scanWith(java.util.function.Supplier<A>,java.util.function.BiFunction<A,? super T,A>)"
- "reactor.core.publisher.Flux.<C>buffer(int,int,java.util.function.Supplier<C>)"
- "reactor.core.publisher.Flux.<C>buffer(int,java.util.function.Supplier<C>)"
- "reactor.core.publisher.Flux.<C>buffer(org.reactivestreams.Publisher<?>,java.util.function.Supplier<C>)"
- "reactor.core.publisher.Flux.<C>bufferTimeout(int,java.time.Duration,java.util.function.Supplier<C>)"
- "reactor.core.publisher.Flux.<C>bufferTimeout(int,java.time.Duration,reactor.core.scheduler.Scheduler,java.util.function.Supplier<C>)"
- "reactor.core.publisher.Flux.<E>cast(java.lang.Class<E>)"
- "reactor.core.publisher.Flux.<E>collect(java.util.function.Supplier<E>,java.util.function.BiConsumer<E,? super T>)"
- "reactor.core.publisher.Flux.<E>doOnError(java.lang.Class<E>,java.util.function.Consumer<? super E>)"
- "reactor.core.publisher.Flux.<E>onErrorContinue(java.lang.Class<E>,java.util.function.BiConsumer<java.lang.Throwable,java.lang.Object>)"
- "reactor.core.publisher.Flux.<E>onErrorContinue(java.util.function.Predicate<E>,java.util.function.BiConsumer<java.lang.Throwable,java.lang.Object>)"
- "reactor.core.publisher.Flux.<E>onErrorMap(java.lang.Class<E>,java.util.function.Function<? super E,? extends java.lang.Throwable>)"
- "reactor.core.publisher.Flux.<E>onErrorResume(java.lang.Class<E>,java.util.function.Function<? super E,? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Flux.<E>onErrorReturn(java.lang.Class<E>,T)"
- "reactor.core.publisher.Flux.<E>subscribeWith(E)"
- "reactor.core.publisher.Flux.<I,O>zip(java.util.function.Function<? super java.lang.Object[],? extends O>,int,org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I,O>zip(java.util.function.Function<? super java.lang.Object[],? extends O>,org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>first(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends I>>)"
- "reactor.core.publisher.Flux.<I>first(org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>firstWithSignal(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends I>>)"
- "reactor.core.publisher.Flux.<I>firstWithSignal(org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>firstWithValue(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends I>>)"
- "reactor.core.publisher.Flux.<I>firstWithValue(org.reactivestreams.Publisher<? extends I>,org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>index(java.util.function.BiFunction<? super java.lang.Long,? super T,? extends I>)"
- "reactor.core.publisher.Flux.<I>merge(int,org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>merge(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends I>>)"
- "reactor.core.publisher.Flux.<I>merge(org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>mergeComparing(org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>mergeDelayError(int,org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>mergeOrdered(org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>mergeSequential(int,org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>mergeSequential(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends I>>)"
- "reactor.core.publisher.Flux.<I>mergeSequential(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends I>>,int,int)"
- "reactor.core.publisher.Flux.<I>mergeSequential(org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>mergeSequentialDelayError(int,org.reactivestreams.Publisher<? extends I>...)"
- "reactor.core.publisher.Flux.<I>mergeSequentialDelayError(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends I>>,int,int)"
- "reactor.core.publisher.Flux.<K,V>collectMap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>)"
- "reactor.core.publisher.Flux.<K,V>collectMap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>,java.util.function.Supplier<java.util.Map<K,V>>)"
- "reactor.core.publisher.Flux.<K,V>collectMultimap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>)"
- "reactor.core.publisher.Flux.<K,V>collectMultimap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>,java.util.function.Supplier<java.util.Map<K,java.util.Collection<V>>>)"
- "reactor.core.publisher.Flux.<K,V>groupBy(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>)"
- "reactor.core.publisher.Flux.<K,V>groupBy(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>,int)"
- "reactor.core.publisher.Flux.<K>collectMap(java.util.function.Function<? super T,? extends K>)"
- "reactor.core.publisher.Flux.<K>collectMultimap(java.util.function.Function<? super T,? extends K>)"
- "reactor.core.publisher.Flux.<K>groupBy(java.util.function.Function<? super T,? extends K>)"
- "reactor.core.publisher.Flux.<K>groupBy(java.util.function.Function<? super T,? extends K>,int)"
- "reactor.core.publisher.Flux.<O>error(java.lang.Throwable,boolean)"
- "reactor.core.publisher.Flux.<O>zip(java.lang.Iterable<? extends org.reactivestreams.Publisher<?>>,int,java.util.function.Function<? super java.lang.Object[],? extends O>)"
- "reactor.core.publisher.Flux.<O>zip(java.lang.Iterable<? extends org.reactivestreams.Publisher<?>>,java.util.function.Function<? super java.lang.Object[],? extends O>)"
- "reactor.core.publisher.Flux.<P>as(java.util.function.Function<? super reactor.core.publisher.Flux<T>,P>)"
- "reactor.core.publisher.Flux.<R,A>collect(java.util.stream.Collector<? super T,A,? extends R>)"
- "reactor.core.publisher.Flux.<R>concatMapIterable(java.util.function.Function<? super T,? extends java.lang.Iterable<? extends R>>)"
- "reactor.core.publisher.Flux.<R>concatMapIterable(java.util.function.Function<? super T,? extends java.lang.Iterable<? extends R>>,int)"
- "reactor.core.publisher.Flux.<R>doOnDiscard(java.lang.Class<R>,java.util.function.Consumer<? super R>)"
- "reactor.core.publisher.Flux.<R>flatMap(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends R>>)"
- "reactor.core.publisher.Flux.<R>flatMap(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends R>>,java.util.function.Function<? super java.lang.Throwable,? extends org.reactivestreams.Publisher<? extends R>>,java.util.function.Supplier<? extends org.reactivestreams.Publisher<? extends R>>)"
- "reactor.core.publisher.Flux.<R>flatMapIterable(java.util.function.Function<? super T,? extends java.lang.Iterable<? extends R>>)"
- "reactor.core.publisher.Flux.<R>flatMapIterable(java.util.function.Function<? super T,? extends java.lang.Iterable<? extends R>>,int)"
- "reactor.core.publisher.Flux.<R>flatMapSequential(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends R>>)"
- "reactor.core.publisher.Flux.<R>flatMapSequential(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends R>>,int)"
- "reactor.core.publisher.Flux.<R>flatMapSequential(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends R>>,int,int)"
- "reactor.core.publisher.Flux.<R>flatMapSequentialDelayError(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends R>>,int,int)"
- "reactor.core.publisher.Flux.<R>handle(java.util.function.BiConsumer<? super T,reactor.core.publisher.SynchronousSink<R>>)"
- "reactor.core.publisher.Flux.<R>publish(java.util.function.Function<? super reactor.core.publisher.Flux<T>,? extends org.reactivestreams.Publisher<? extends R>>)"
- "reactor.core.publisher.Flux.<R>publish(java.util.function.Function<? super reactor.core.publisher.Flux<T>,? extends org.reactivestreams.Publisher<? extends R>>,int)"
- "reactor.core.publisher.Flux.<T,D>using(java.util.concurrent.Callable<? extends D>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<? extends T>>,java.util.function.Consumer<? super D>)"
- "reactor.core.publisher.Flux.<T,D>using(java.util.concurrent.Callable<? extends D>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<? extends T>>,java.util.function.Consumer<? super D>,boolean)"
- "reactor.core.publisher.Flux.<T,D>usingWhen(org.reactivestreams.Publisher<D>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<? extends T>>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Flux.<T,D>usingWhen(org.reactivestreams.Publisher<D>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<? extends T>>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<?>>,java.util.function.BiFunction<? super D,? super java.lang.Throwable,? extends org.reactivestreams.Publisher<?>>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Flux.<T,S>generate(java.util.concurrent.Callable<S>,java.util.function.BiFunction<S,reactor.core.publisher.SynchronousSink<T>,S>)"
- "reactor.core.publisher.Flux.<T,S>generate(java.util.concurrent.Callable<S>,java.util.function.BiFunction<S,reactor.core.publisher.SynchronousSink<T>,S>,java.util.function.Consumer<? super S>)"
- "reactor.core.publisher.Flux.<T,V>combineLatest(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends T>>,int,java.util.function.Function<java.lang.Object[],V>)"
- "reactor.core.publisher.Flux.<T,V>combineLatest(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends T>>,java.util.function.Function<java.lang.Object[],V>)"
- "reactor.core.publisher.Flux.<T,V>combineLatest(java.util.function.Function<java.lang.Object[],V>,int,org.reactivestreams.Publisher<? extends T>...)"
- "reactor.core.publisher.Flux.<T,V>combineLatest(java.util.function.Function<java.lang.Object[],V>,org.reactivestreams.Publisher<? extends T>...)"
- "reactor.core.publisher.Flux.<T1,T2,O>zip(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,java.util.function.BiFunction<? super T1,? super T2,? extends O>)"
- "reactor.core.publisher.Flux.<T1,T2,T3,T4,T5,T6,T7,T8>zip(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,org.reactivestreams.Publisher<? extends T3>,org.reactivestreams.Publisher<? extends T4>,org.reactivestreams.Publisher<? extends T5>,org.reactivestreams.Publisher<? extends T6>,org.reactivestreams.Publisher<? extends T7>,org.reactivestreams.Publisher<? extends T8>)"
- "reactor.core.publisher.Flux.<T1,T2,T3,T4,T5,T6,T7>zip(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,org.reactivestreams.Publisher<? extends T3>,org.reactivestreams.Publisher<? extends T4>,org.reactivestreams.Publisher<? extends T5>,org.reactivestreams.Publisher<? extends T6>,org.reactivestreams.Publisher<? extends T7>)"
- "reactor.core.publisher.Flux.<T1,T2,T3,T4,T5,T6,V>combineLatest(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,org.reactivestreams.Publisher<? extends T3>,org.reactivestreams.Publisher<? extends T4>,org.reactivestreams.Publisher<? extends T5>,org.reactivestreams.Publisher<? extends T6>,java.util.function.Function<java.lang.Object[],V>)"
- "reactor.core.publisher.Flux.<T1,T2,T3,T4,T5,T6>zip(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,org.reactivestreams.Publisher<? extends T3>,org.reactivestreams.Publisher<? extends T4>,org.reactivestreams.Publisher<? extends T5>,org.reactivestreams.Publisher<? extends T6>)"
- "reactor.core.publisher.Flux.<T1,T2,T3,T4,T5,V>combineLatest(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,org.reactivestreams.Publisher<? extends T3>,org.reactivestreams.Publisher<? extends T4>,org.reactivestreams.Publisher<? extends T5>,java.util.function.Function<java.lang.Object[],V>)"
- "reactor.core.publisher.Flux.<T1,T2,T3,T4,T5>zip(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,org.reactivestreams.Publisher<? extends T3>,org.reactivestreams.Publisher<? extends T4>,org.reactivestreams.Publisher<? extends T5>)"
- "reactor.core.publisher.Flux.<T1,T2,T3,T4,V>combineLatest(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,org.reactivestreams.Publisher<? extends T3>,org.reactivestreams.Publisher<? extends T4>,java.util.function.Function<java.lang.Object[],V>)"
- "reactor.core.publisher.Flux.<T1,T2,T3,T4>zip(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,org.reactivestreams.Publisher<? extends T3>,org.reactivestreams.Publisher<? extends T4>)"
- "reactor.core.publisher.Flux.<T1,T2,T3,V>combineLatest(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,org.reactivestreams.Publisher<? extends T3>,java.util.function.Function<java.lang.Object[],V>)"
- "reactor.core.publisher.Flux.<T1,T2,T3>zip(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,org.reactivestreams.Publisher<? extends T3>)"
- "reactor.core.publisher.Flux.<T1,T2,V>combineLatest(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>,java.util.function.BiFunction<? super T1,? super T2,? extends V>)"
- "reactor.core.publisher.Flux.<T1,T2>zip(org.reactivestreams.Publisher<? extends T1>,org.reactivestreams.Publisher<? extends T2>)"
- "reactor.core.publisher.Flux.<T2,V>zipWith(org.reactivestreams.Publisher<? extends T2>,int,java.util.function.BiFunction<? super T,? super T2,? extends V>)"
- "reactor.core.publisher.Flux.<T2,V>zipWith(org.reactivestreams.Publisher<? extends T2>,java.util.function.BiFunction<? super T,? super T2,? extends V>)"
- "reactor.core.publisher.Flux.<T2,V>zipWithIterable(java.lang.Iterable<? extends T2>,java.util.function.BiFunction<? super T,? super T2,? extends V>)"
- "reactor.core.publisher.Flux.<T2>zipWith(org.reactivestreams.Publisher<? extends T2>)"
- "reactor.core.publisher.Flux.<T2>zipWith(org.reactivestreams.Publisher<? extends T2>,int)"
- "reactor.core.publisher.Flux.<T2>zipWithIterable(java.lang.Iterable<? extends T2>)"
- "reactor.core.publisher.Flux.<T>concat(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Flux.<T>concat(org.reactivestreams.Publisher<? extends T>...)"
- "reactor.core.publisher.Flux.<T>concat(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Flux.<T>concat(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>,int)"
- "reactor.core.publisher.Flux.<T>concatDelayError(org.reactivestreams.Publisher<? extends T>...)"
- "reactor.core.publisher.Flux.<T>concatDelayError(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Flux.<T>concatDelayError(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>,boolean,int)"
- "reactor.core.publisher.Flux.<T>concatDelayError(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>,int)"
- "reactor.core.publisher.Flux.<T>create(java.util.function.Consumer<? super reactor.core.publisher.FluxSink<T>>)"
- "reactor.core.publisher.Flux.<T>create(java.util.function.Consumer<? super reactor.core.publisher.FluxSink<T>>,reactor.core.publisher.FluxSink.OverflowStrategy)"
- "reactor.core.publisher.Flux.<T>defer(java.util.function.Supplier<? extends org.reactivestreams.Publisher<T>>)"
- "reactor.core.publisher.Flux.<T>deferContextual(java.util.function.Function<reactor.util.context.ContextView,? extends org.reactivestreams.Publisher<T>>)"
- "reactor.core.publisher.Flux.<T>deferWithContext(java.util.function.Function<reactor.util.context.Context,? extends org.reactivestreams.Publisher<T>>)"
- "reactor.core.publisher.Flux.<T>empty()"
- "reactor.core.publisher.Flux.<T>error(java.lang.Throwable)"
- "reactor.core.publisher.Flux.<T>error(java.util.function.Supplier<? extends java.lang.Throwable>)"
- "reactor.core.publisher.Flux.<T>from(org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Flux.<T>fromArray(T[])"
- "reactor.core.publisher.Flux.<T>fromIterable(java.lang.Iterable<? extends T>)"
- "reactor.core.publisher.Flux.<T>fromStream(java.util.function.Supplier<java.util.stream.Stream<? extends T>>)"
- "reactor.core.publisher.Flux.<T>fromStream(java.util.stream.Stream<? extends T>)"
- "reactor.core.publisher.Flux.<T>generate(java.util.function.Consumer<reactor.core.publisher.SynchronousSink<T>>)"
- "reactor.core.publisher.Flux.<T>just(T)"
- "reactor.core.publisher.Flux.<T>just(T...)"
- "reactor.core.publisher.Flux.<T>merge(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Flux.<T>merge(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>,int)"
- "reactor.core.publisher.Flux.<T>merge(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>,int,int)"
- "reactor.core.publisher.Flux.<T>mergeComparing(int,java.util.Comparator<? super T>,org.reactivestreams.Publisher<? extends T>...)"
- "reactor.core.publisher.Flux.<T>mergeComparing(java.util.Comparator<? super T>,org.reactivestreams.Publisher<? extends T>...)"
- "reactor.core.publisher.Flux.<T>mergeComparingDelayError(int,java.util.Comparator<? super T>,org.reactivestreams.Publisher<? extends T>...)"
- "reactor.core.publisher.Flux.<T>mergeOrdered(int,java.util.Comparator<? super T>,org.reactivestreams.Publisher<? extends T>...)"
- "reactor.core.publisher.Flux.<T>mergeOrdered(java.util.Comparator<? super T>,org.reactivestreams.Publisher<? extends T>...)"
- "reactor.core.publisher.Flux.<T>mergeSequential(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Flux.<T>mergeSequential(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>,int,int)"
- "reactor.core.publisher.Flux.<T>mergeSequentialDelayError(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>,int,int)"
- "reactor.core.publisher.Flux.<T>never()"
- "reactor.core.publisher.Flux.<T>onAssembly(reactor.core.publisher.ConnectableFlux<T>)"
- "reactor.core.publisher.Flux.<T>onAssembly(reactor.core.publisher.Flux<T>)"
- "reactor.core.publisher.Flux.<T>push(java.util.function.Consumer<? super reactor.core.publisher.FluxSink<T>>)"
- "reactor.core.publisher.Flux.<T>push(java.util.function.Consumer<? super reactor.core.publisher.FluxSink<T>>,reactor.core.publisher.FluxSink.OverflowStrategy)"
- "reactor.core.publisher.Flux.<T>switchOnNext(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Flux.<T>switchOnNext(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<? extends T>>,int)"
- "reactor.core.publisher.Flux.<TRight,TLeftEnd,TRightEnd,R>groupJoin(org.reactivestreams.Publisher<? extends TRight>,java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<TLeftEnd>>,java.util.function.Function<? super TRight,? extends org.reactivestreams.Publisher<TRightEnd>>,java.util.function.BiFunction<? super T,? super reactor.core.publisher.Flux<TRight>,? extends R>)"
- "reactor.core.publisher.Flux.<TRight,TLeftEnd,TRightEnd,R>join(org.reactivestreams.Publisher<? extends TRight>,java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<TLeftEnd>>,java.util.function.Function<? super TRight,? extends org.reactivestreams.Publisher<TRightEnd>>,java.util.function.BiFunction<? super T,? super TRight,? extends R>)"
- "reactor.core.publisher.Flux.<TUPLE,V>zip(org.reactivestreams.Publisher<? extends org.reactivestreams.Publisher<?>>,java.util.function.Function<? super TUPLE,? extends V>)"
- "reactor.core.publisher.Flux.<U,R>withLatestFrom(org.reactivestreams.Publisher<? extends U>,java.util.function.BiFunction<? super T,? super U,? extends R>)"
- "reactor.core.publisher.Flux.<U,V,C>bufferWhen(org.reactivestreams.Publisher<U>,java.util.function.Function<? super U,? extends org.reactivestreams.Publisher<V>>,java.util.function.Supplier<C>)"
- "reactor.core.publisher.Flux.<U,V>bufferWhen(org.reactivestreams.Publisher<U>,java.util.function.Function<? super U,? extends org.reactivestreams.Publisher<V>>)"
- "reactor.core.publisher.Flux.<U,V>timeout(org.reactivestreams.Publisher<U>,java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<V>>)"
- "reactor.core.publisher.Flux.<U,V>timeout(org.reactivestreams.Publisher<U>,java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<V>>,org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Flux.<U,V>windowWhen(org.reactivestreams.Publisher<U>,java.util.function.Function<? super U,? extends org.reactivestreams.Publisher<V>>)"
- "reactor.core.publisher.Flux.<U>delaySubscription(org.reactivestreams.Publisher<U>)"
- "reactor.core.publisher.Flux.<U>ofType(java.lang.Class<U>)"
- "reactor.core.publisher.Flux.<U>sample(org.reactivestreams.Publisher<U>)"
- "reactor.core.publisher.Flux.<U>sampleFirst(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<U>>)"
- "reactor.core.publisher.Flux.<U>sampleTimeout(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<U>>)"
- "reactor.core.publisher.Flux.<U>sampleTimeout(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<U>>,int)"
- "reactor.core.publisher.Flux.<U>timeout(org.reactivestreams.Publisher<U>)"
- "reactor.core.publisher.Flux.<V,C>distinct(java.util.function.Function<? super T,? extends V>,java.util.function.Supplier<C>)"
- "reactor.core.publisher.Flux.<V,C>distinct(java.util.function.Function<? super T,? extends V>,java.util.function.Supplier<C>,java.util.function.BiPredicate<C,V>,java.util.function.Consumer<C>)"
- "reactor.core.publisher.Flux.<V>bufferUntilChanged()"
- "reactor.core.publisher.Flux.<V>bufferUntilChanged(java.util.function.Function<? super T,? extends V>)"
- "reactor.core.publisher.Flux.<V>bufferUntilChanged(java.util.function.Function<? super T,? extends V>,java.util.function.BiPredicate<? super V,? super V>)"
- "reactor.core.publisher.Flux.<V>concatMap(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends V>>)"
- "reactor.core.publisher.Flux.<V>concatMap(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends V>>,int)"
- "reactor.core.publisher.Flux.<V>concatMapDelayError(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends V>>)"
- "reactor.core.publisher.Flux.<V>concatMapDelayError(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends V>>,boolean,int)"
- "reactor.core.publisher.Flux.<V>concatMapDelayError(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends V>>,int)"
- "reactor.core.publisher.Flux.<V>distinct(java.util.function.Function<? super T,? extends V>)"
- "reactor.core.publisher.Flux.<V>distinctUntilChanged(java.util.function.Function<? super T,? extends V>)"
- "reactor.core.publisher.Flux.<V>distinctUntilChanged(java.util.function.Function<? super T,? extends V>,java.util.function.BiPredicate<? super V,? super V>)"
- "reactor.core.publisher.Flux.<V>flatMap(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends V>>,int)"
- "reactor.core.publisher.Flux.<V>flatMap(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends V>>,int,int)"
- "reactor.core.publisher.Flux.<V>flatMapDelayError(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends V>>,int,int)"
- "reactor.core.publisher.Flux.<V>map(java.util.function.Function<? super T,? extends V>)"
- "reactor.core.publisher.Flux.<V>mapNotNull(java.util.function.Function<? super T,? extends V>)"
- "reactor.core.publisher.Flux.<V>switchMap(java.util.function.Function<? super T,org.reactivestreams.Publisher<? extends V>>)"
- "reactor.core.publisher.Flux.<V>switchMap(java.util.function.Function<? super T,org.reactivestreams.Publisher<? extends V>>,int)"
- "reactor.core.publisher.Flux.<V>switchOnFirst(java.util.function.BiFunction<reactor.core.publisher.Signal<? extends T>,reactor.core.publisher.Flux<T>,org.reactivestreams.Publisher<? extends V>>)"
- "reactor.core.publisher.Flux.<V>switchOnFirst(java.util.function.BiFunction<reactor.core.publisher.Signal<? extends T>,reactor.core.publisher.Flux<T>,org.reactivestreams.Publisher<? extends V>>,boolean)"
- "reactor.core.publisher.Flux.<V>then(reactor.core.publisher.Mono<V>)"
- "reactor.core.publisher.Flux.<V>thenMany(org.reactivestreams.Publisher<V>)"
- "reactor.core.publisher.Flux.<V>transform(java.util.function.Function<? super reactor.core.publisher.Flux<T>,? extends org.reactivestreams.Publisher<V>>)"
- "reactor.core.publisher.Flux.<V>transformDeferred(java.util.function.Function<? super reactor.core.publisher.Flux<T>,? extends org.reactivestreams.Publisher<V>>)"
- "reactor.core.publisher.Flux.<V>transformDeferredContextual(java.util.function.BiFunction<? super reactor.core.publisher.Flux<T>,? super reactor.util.context.ContextView,? extends org.reactivestreams.Publisher<V>>)"
- "reactor.core.publisher.Flux.<V>windowUntilChanged()"
- "reactor.core.publisher.Flux.<V>windowUntilChanged(java.util.function.Function<? super T,? extends V>,java.util.function.BiPredicate<? super V,? super V>)"
- "reactor.core.publisher.Flux.<V>windowUntilChanged(java.util.function.Function<? super T,? super V>)"
- "reactor.core.publisher.Flux.<X>dematerialize()"
- "reactor.core.publisher.Flux.all(java.util.function.Predicate<? super T>)"
- "reactor.core.publisher.Flux.any(java.util.function.Predicate<? super T>)"
- "reactor.core.publisher.Flux.blockFirst()"
- "reactor.core.publisher.Flux.blockFirst(java.time.Duration)"
- "reactor.core.publisher.Flux.blockLast()"
- "reactor.core.publisher.Flux.blockLast(java.time.Duration)"
- "reactor.core.publisher.Flux.buffer()"
- "reactor.core.publisher.Flux.buffer(int)"
- "reactor.core.publisher.Flux.buffer(int,int)"
- "reactor.core.publisher.Flux.buffer(java.time.Duration)"
- "reactor.core.publisher.Flux.buffer(java.time.Duration,java.time.Duration)"
- "reactor.core.publisher.Flux.buffer(java.time.Duration,java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.buffer(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.buffer(org.reactivestreams.Publisher<?>)"
- "reactor.core.publisher.Flux.bufferTimeout(int,java.time.Duration)"
- "reactor.core.publisher.Flux.bufferTimeout(int,java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.bufferUntil(java.util.function.Predicate<? super T>)"
- "reactor.core.publisher.Flux.bufferUntil(java.util.function.Predicate<? super T>,boolean)"
- "reactor.core.publisher.Flux.bufferWhile(java.util.function.Predicate<? super T>)"
- "reactor.core.publisher.Flux.cache()"
- "reactor.core.publisher.Flux.cache(int)"
- "reactor.core.publisher.Flux.cache(int,java.time.Duration)"
- "reactor.core.publisher.Flux.cache(int,java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.cache(java.time.Duration)"
- "reactor.core.publisher.Flux.cache(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.cancelOn(reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.checkpoint()"
- "reactor.core.publisher.Flux.checkpoint(java.lang.String)"
- "reactor.core.publisher.Flux.checkpoint(java.lang.String,boolean)"
- "reactor.core.publisher.Flux.collectList()"
- "reactor.core.publisher.Flux.collectSortedList()"
- "reactor.core.publisher.Flux.collectSortedList(java.util.Comparator<? super T>)"
- "reactor.core.publisher.Flux.concatWith(org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Flux.concatWithValues(T...)"
- "reactor.core.publisher.Flux.contextWrite(java.util.function.Function<reactor.util.context.Context,reactor.util.context.Context>)"
- "reactor.core.publisher.Flux.contextWrite(reactor.util.context.ContextView)"
- "reactor.core.publisher.Flux.count()"
- "reactor.core.publisher.Flux.defaultIfEmpty(T)"
- "reactor.core.publisher.Flux.delayElements(java.time.Duration)"
- "reactor.core.publisher.Flux.delayElements(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.delaySequence(java.time.Duration)"
- "reactor.core.publisher.Flux.delaySequence(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.delaySubscription(java.time.Duration)"
- "reactor.core.publisher.Flux.delaySubscription(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.delayUntil(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Flux.distinct()"
- "reactor.core.publisher.Flux.distinctUntilChanged()"
- "reactor.core.publisher.Flux.doAfterTerminate(java.lang.Runnable)"
- "reactor.core.publisher.Flux.doFinally(java.util.function.Consumer<reactor.core.publisher.SignalType>)"
- "reactor.core.publisher.Flux.doFirst(java.lang.Runnable)"
- "reactor.core.publisher.Flux.doOnCancel(java.lang.Runnable)"
- "reactor.core.publisher.Flux.doOnComplete(java.lang.Runnable)"
- "reactor.core.publisher.Flux.doOnEach(java.util.function.Consumer<? super reactor.core.publisher.Signal<T>>)"
- "reactor.core.publisher.Flux.doOnError(java.util.function.Consumer<? super java.lang.Throwable>)"
- "reactor.core.publisher.Flux.doOnError(java.util.function.Predicate<? super java.lang.Throwable>,java.util.function.Consumer<? super java.lang.Throwable>)"
- "reactor.core.publisher.Flux.doOnNext(java.util.function.Consumer<? super T>)"
- "reactor.core.publisher.Flux.doOnRequest(java.util.function.LongConsumer)"
- "reactor.core.publisher.Flux.doOnSubscribe(java.util.function.Consumer<? super org.reactivestreams.Subscription>)"
- "reactor.core.publisher.Flux.doOnTerminate(java.lang.Runnable)"
- "reactor.core.publisher.Flux.elapsed()"
- "reactor.core.publisher.Flux.elapsed(reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.elementAt(int)"
- "reactor.core.publisher.Flux.elementAt(int,T)"
- "reactor.core.publisher.Flux.expand(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Flux.expand(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends T>>,int)"
- "reactor.core.publisher.Flux.expandDeep(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Flux.expandDeep(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends T>>,int)"
- "reactor.core.publisher.Flux.filter(java.util.function.Predicate<? super T>)"
- "reactor.core.publisher.Flux.filterWhen(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<java.lang.Boolean>>)"
- "reactor.core.publisher.Flux.filterWhen(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<java.lang.Boolean>>,int)"
- "reactor.core.publisher.Flux.getPrefetch()"
- "reactor.core.publisher.Flux.hasElement(T)"
- "reactor.core.publisher.Flux.hasElements()"
- "reactor.core.publisher.Flux.hide()"
- "reactor.core.publisher.Flux.ignoreElements()"
- "reactor.core.publisher.Flux.index()"
- "reactor.core.publisher.Flux.interval(java.time.Duration)"
- "reactor.core.publisher.Flux.interval(java.time.Duration,java.time.Duration)"
- "reactor.core.publisher.Flux.interval(java.time.Duration,java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.interval(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.last()"
- "reactor.core.publisher.Flux.last(T)"
- "reactor.core.publisher.Flux.limitRate(int)"
- "reactor.core.publisher.Flux.limitRate(int,int)"
- "reactor.core.publisher.Flux.limitRequest(long)"
- "reactor.core.publisher.Flux.log()"
- "reactor.core.publisher.Flux.log(java.lang.String)"
- "reactor.core.publisher.Flux.log(java.lang.String,java.util.logging.Level,boolean,reactor.core.publisher.SignalType...)"
- "reactor.core.publisher.Flux.log(java.lang.String,java.util.logging.Level,reactor.core.publisher.SignalType...)"
- "reactor.core.publisher.Flux.log(reactor.util.Logger)"
- "reactor.core.publisher.Flux.log(reactor.util.Logger,java.util.logging.Level,boolean,reactor.core.publisher.SignalType...)"
- "reactor.core.publisher.Flux.materialize()"
- "reactor.core.publisher.Flux.mergeComparingWith(org.reactivestreams.Publisher<? extends T>,java.util.Comparator<? super T>)"
- "reactor.core.publisher.Flux.mergeOrderedWith(org.reactivestreams.Publisher<? extends T>,java.util.Comparator<? super T>)"
- "reactor.core.publisher.Flux.mergeWith(org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Flux.metrics()"
- "reactor.core.publisher.Flux.name(java.lang.String)"
- "reactor.core.publisher.Flux.next()"
- "reactor.core.publisher.Flux.onBackpressureBuffer()"
- "reactor.core.publisher.Flux.onBackpressureBuffer(int)"
- "reactor.core.publisher.Flux.onBackpressureBuffer(int,java.util.function.Consumer<? super T>)"
- "reactor.core.publisher.Flux.onBackpressureBuffer(int,java.util.function.Consumer<? super T>,reactor.core.publisher.BufferOverflowStrategy)"
- "reactor.core.publisher.Flux.onBackpressureBuffer(int,reactor.core.publisher.BufferOverflowStrategy)"
- "reactor.core.publisher.Flux.onBackpressureBuffer(java.time.Duration,int,java.util.function.Consumer<? super T>)"
- "reactor.core.publisher.Flux.onBackpressureBuffer(java.time.Duration,int,java.util.function.Consumer<? super T>,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.onBackpressureDrop()"
- "reactor.core.publisher.Flux.onBackpressureDrop(java.util.function.Consumer<? super T>)"
- "reactor.core.publisher.Flux.onBackpressureError()"
- "reactor.core.publisher.Flux.onBackpressureLatest()"
- "reactor.core.publisher.Flux.onErrorContinue(java.util.function.BiConsumer<java.lang.Throwable,java.lang.Object>)"
- "reactor.core.publisher.Flux.onErrorMap(java.util.function.Function<? super java.lang.Throwable,? extends java.lang.Throwable>)"
- "reactor.core.publisher.Flux.onErrorMap(java.util.function.Predicate<? super java.lang.Throwable>,java.util.function.Function<? super java.lang.Throwable,? extends java.lang.Throwable>)"
- "reactor.core.publisher.Flux.onErrorResume(java.util.function.Function<? super java.lang.Throwable,? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Flux.onErrorResume(java.util.function.Predicate<? super java.lang.Throwable>,java.util.function.Function<? super java.lang.Throwable,? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Flux.onErrorReturn(T)"
- "reactor.core.publisher.Flux.onErrorReturn(java.util.function.Predicate<? super java.lang.Throwable>,T)"
- "reactor.core.publisher.Flux.onErrorStop()"
- "reactor.core.publisher.Flux.onTerminateDetach()"
- "reactor.core.publisher.Flux.or(org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Flux.parallel()"
- "reactor.core.publisher.Flux.parallel(int)"
- "reactor.core.publisher.Flux.parallel(int,int)"
- "reactor.core.publisher.Flux.publish()"
- "reactor.core.publisher.Flux.publish(int)"
- "reactor.core.publisher.Flux.publishNext()"
- "reactor.core.publisher.Flux.publishOn(reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.publishOn(reactor.core.scheduler.Scheduler,boolean,int)"
- "reactor.core.publisher.Flux.publishOn(reactor.core.scheduler.Scheduler,int)"
- "reactor.core.publisher.Flux.range(int,int)"
- "reactor.core.publisher.Flux.reduce(java.util.function.BiFunction<T,T,T>)"
- "reactor.core.publisher.Flux.repeat()"
- "reactor.core.publisher.Flux.repeat(java.util.function.BooleanSupplier)"
- "reactor.core.publisher.Flux.repeat(long)"
- "reactor.core.publisher.Flux.repeat(long,java.util.function.BooleanSupplier)"
- "reactor.core.publisher.Flux.repeatWhen(java.util.function.Function<reactor.core.publisher.Flux<java.lang.Long>,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Flux.replay()"
- "reactor.core.publisher.Flux.replay(int)"
- "reactor.core.publisher.Flux.replay(int,java.time.Duration)"
- "reactor.core.publisher.Flux.replay(int,java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.replay(java.time.Duration)"
- "reactor.core.publisher.Flux.replay(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.retry()"
- "reactor.core.publisher.Flux.retry(long)"
- "reactor.core.publisher.Flux.retryWhen(reactor.util.retry.Retry)"
- "reactor.core.publisher.Flux.sample(java.time.Duration)"
- "reactor.core.publisher.Flux.sampleFirst(java.time.Duration)"
- "reactor.core.publisher.Flux.scan(java.util.function.BiFunction<T,T,T>)"
- "reactor.core.publisher.Flux.share()"
- "reactor.core.publisher.Flux.shareNext()"
- "reactor.core.publisher.Flux.single()"
- "reactor.core.publisher.Flux.single(T)"
- "reactor.core.publisher.Flux.singleOrEmpty()"
- "reactor.core.publisher.Flux.skip(java.time.Duration)"
- "reactor.core.publisher.Flux.skip(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.skip(long)"
- "reactor.core.publisher.Flux.skipLast(int)"
- "reactor.core.publisher.Flux.skipUntil(java.util.function.Predicate<? super T>)"
- "reactor.core.publisher.Flux.skipUntilOther(org.reactivestreams.Publisher<?>)"
- "reactor.core.publisher.Flux.skipWhile(java.util.function.Predicate<? super T>)"
- "reactor.core.publisher.Flux.sort()"
- "reactor.core.publisher.Flux.sort(java.util.Comparator<? super T>)"
- "reactor.core.publisher.Flux.startWith(T...)"
- "reactor.core.publisher.Flux.startWith(java.lang.Iterable<? extends T>)"
- "reactor.core.publisher.Flux.startWith(org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Flux.subscribe()"
- "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer<? super T>)"
- "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer<? super T>,java.util.function.Consumer<? super java.lang.Throwable>)"
- "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer<? super T>,java.util.function.Consumer<? super java.lang.Throwable>,java.lang.Runnable)"
- "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer<? super T>,java.util.function.Consumer<? super java.lang.Throwable>,java.lang.Runnable,java.util.function.Consumer<? super org.reactivestreams.Subscription>)"
- "reactor.core.publisher.Flux.subscribe(java.util.function.Consumer<? super T>,java.util.function.Consumer<? super java.lang.Throwable>,java.lang.Runnable,reactor.util.context.Context)"
- "reactor.core.publisher.Flux.subscribe(org.reactivestreams.Subscriber<? super T>)"
- "reactor.core.publisher.Flux.subscribe(reactor.core.CoreSubscriber<? super T>)"
- "reactor.core.publisher.Flux.subscribeOn(reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.subscribeOn(reactor.core.scheduler.Scheduler,boolean)"
- "reactor.core.publisher.Flux.subscriberContext(java.util.function.Function<reactor.util.context.Context,reactor.util.context.Context>)"
- "reactor.core.publisher.Flux.subscriberContext(reactor.util.context.Context)"
- "reactor.core.publisher.Flux.switchIfEmpty(org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Flux.tag(java.lang.String,java.lang.String)"
- "reactor.core.publisher.Flux.take(java.time.Duration)"
- "reactor.core.publisher.Flux.take(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.take(long)"
- "reactor.core.publisher.Flux.take(long,boolean)"
- "reactor.core.publisher.Flux.takeLast(int)"
- "reactor.core.publisher.Flux.takeUntil(java.util.function.Predicate<? super T>)"
- "reactor.core.publisher.Flux.takeUntilOther(org.reactivestreams.Publisher<?>)"
- "reactor.core.publisher.Flux.takeWhile(java.util.function.Predicate<? super T>)"
- "reactor.core.publisher.Flux.then()"
- "reactor.core.publisher.Flux.thenEmpty(org.reactivestreams.Publisher<java.lang.Void>)"
- "reactor.core.publisher.Flux.timed()"
- "reactor.core.publisher.Flux.timed(reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.timeout(java.time.Duration)"
- "reactor.core.publisher.Flux.timeout(java.time.Duration,org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Flux.timeout(java.time.Duration,org.reactivestreams.Publisher<? extends T>,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.timeout(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.timestamp()"
- "reactor.core.publisher.Flux.timestamp(reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.toIterable()"
- "reactor.core.publisher.Flux.toIterable(int)"
- "reactor.core.publisher.Flux.toIterable(int,java.util.function.Supplier<java.util.Queue<T>>)"
- "reactor.core.publisher.Flux.toStream()"
- "reactor.core.publisher.Flux.toStream(int)"
- "reactor.core.publisher.Flux.toString()"
- "reactor.core.publisher.Flux.window(int)"
- "reactor.core.publisher.Flux.window(int,int)"
- "reactor.core.publisher.Flux.window(java.time.Duration)"
- "reactor.core.publisher.Flux.window(java.time.Duration,java.time.Duration)"
- "reactor.core.publisher.Flux.window(java.time.Duration,java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.window(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.window(org.reactivestreams.Publisher<?>)"
- "reactor.core.publisher.Flux.windowTimeout(int,java.time.Duration)"
- "reactor.core.publisher.Flux.windowTimeout(int,java.time.Duration,boolean)"
- "reactor.core.publisher.Flux.windowTimeout(int,java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Flux.windowTimeout(int,java.time.Duration,reactor.core.scheduler.Scheduler,boolean)"
- "reactor.core.publisher.Flux.windowUntil(java.util.function.Predicate<T>)"
- "reactor.core.publisher.Flux.windowUntil(java.util.function.Predicate<T>,boolean)"
- "reactor.core.publisher.Flux.windowUntil(java.util.function.Predicate<T>,boolean,int)"
- "reactor.core.publisher.Flux.windowWhile(java.util.function.Predicate<T>)"
- "reactor.core.publisher.Flux.windowWhile(java.util.function.Predicate<T>,int)"
syntax: "public final class PollerFlux<T,U> extends Flux<AsyncPollResponse<T,U>>"
constructors:
- uid: "com.azure.core.util.polling.PollerFlux.PollerFlux(java.time.Duration,java.util.function.Function<com.azure.core.util.polling.PollingContext<T>,reactor.core.publisher.Mono<T>>,java.util.function.Function<com.azure.core.util.polling.PollingContext<T>,reactor.core.publisher.Mono<com.azure.core.util.polling.PollResponse<T>>>,java.util.function.BiFunction<com.azure.core.util.polling.PollingContext<T>,com.azure.core.util.polling.PollResponse<T>,reactor.core.publisher.Mono<T>>,java.util.function.Function<com.azure.core.util.polling.PollingContext<T>,reactor.core.publisher.Mono<U>>)"
  fullName: "com.azure.core.util.polling.PollerFlux<T,U>.PollerFlux(Duration pollInterval, Function<PollingContext<T>,Mono<T>> activationOperation, Function<PollingContext<T>,Mono<PollResponse<T>>> pollOperation, BiFunction<PollingContext<T>,PollResponse<T>,Mono<T>> cancelOperation, Function<PollingContext<T>,Mono<U>> fetchResultOperation)"
  name: "PollerFlux(Duration pollInterval, Function<PollingContext<T>,Mono<T>> activationOperation, Function<PollingContext<T>,Mono<PollResponse<T>>> pollOperation, BiFunction<PollingContext<T>,PollResponse<T>,Mono<T>> cancelOperation, Function<PollingContext<T>,Mono<U>> fetchResultOperation)"
  nameWithType: "PollerFlux<T,U>.PollerFlux(Duration pollInterval, Function<PollingContext<T>,Mono<T>> activationOperation, Function<PollingContext<T>,Mono<PollResponse<T>>> pollOperation, BiFunction<PollingContext<T>,PollResponse<T>,Mono<T>> cancelOperation, Function<PollingContext<T>,Mono<U>> fetchResultOperation)"
  summary: "Creates Poller<wbr>Flux."
  parameters:
  - description: "the polling interval"
    name: "pollInterval"
    type: "<xref href=\"java.time.Duration?alt=java.time.Duration&text=Duration\" data-throw-if-not-resolved=\"False\" />"
  - description: "the activation operation to activate (start) the long running operation.\n     This operation will be invoked at most once across all subscriptions. This parameter is required.\n     If there is no specific activation work to be done then invocation should return Mono.empty(),\n     this operation will be called with a new <xref uid=\"com.azure.core.util.polling.PollingContext\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollingContext\"></xref>."
    name: "activationOperation"
    type: "<xref href=\"java.util.function.Function?alt=java.util.function.Function&text=Function\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.polling.PollingContext?alt=com.azure.core.util.polling.PollingContext&text=PollingContext\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;,<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  - description: "the operation to poll the current state of long running operation. This parameter\n     is required and the operation will be called with current <xref uid=\"com.azure.core.util.polling.PollingContext\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollingContext\"></xref>."
    name: "pollOperation"
    type: "<xref href=\"java.util.function.Function?alt=java.util.function.Function&text=Function\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.polling.PollingContext?alt=com.azure.core.util.polling.PollingContext&text=PollingContext\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;,<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.polling.PollResponse?alt=com.azure.core.util.polling.PollResponse&text=PollResponse\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;&gt;&gt;"
  - description: "a <xref uid=\"java.util.function.Function\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Function\"></xref> that represents the operation to cancel the long running operation\n     if service supports cancellation. This parameter is required. If service does not support cancellation\n     then the implementer should return Mono.error with an error message indicating absence of cancellation\n     support. The operation will be called with current <xref uid=\"com.azure.core.util.polling.PollingContext\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollingContext\"></xref>."
    name: "cancelOperation"
    type: "<xref href=\"java.util.function.BiFunction?alt=java.util.function.BiFunction&text=BiFunction\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.polling.PollingContext?alt=com.azure.core.util.polling.PollingContext&text=PollingContext\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;,<xref href=\"com.azure.core.util.polling.PollResponse?alt=com.azure.core.util.polling.PollResponse&text=PollResponse\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;,<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  - description: "a <xref uid=\"java.util.function.Function\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Function\"></xref> that represents the  operation to retrieve final result of\n     the long running operation if service support it. This parameter is required and operation will be called\n     with the current <xref uid=\"com.azure.core.util.polling.PollingContext\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollingContext\"></xref>. If service does not have an api to fetch final result and if final\n     result is same as final poll response value then implementer can choose to simply return value from provided\n     final poll response."
    name: "fetchResultOperation"
    type: "<xref href=\"java.util.function.Function?alt=java.util.function.Function&text=Function\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.polling.PollingContext?alt=com.azure.core.util.polling.PollingContext&text=PollingContext\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;,<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"U?alt=U&text=U\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  syntax: "public PollerFlux(Duration pollInterval, Function<PollingContext<T>,Mono<T>> activationOperation, Function<PollingContext<T>,Mono<PollResponse<T>>> pollOperation, BiFunction<PollingContext<T>,PollResponse<T>,Mono<T>> cancelOperation, Function<PollingContext<T>,Mono<U>> fetchResultOperation)"
  desc: "Creates PollerFlux."
methods:
- uid: "com.azure.core.util.polling.PollerFlux.<T,U>create(java.time.Duration,java.util.function.Function<com.azure.core.util.polling.PollingContext<T>,reactor.core.publisher.Mono<com.azure.core.util.polling.PollResponse<T>>>,java.util.function.Function<com.azure.core.util.polling.PollingContext<T>,reactor.core.publisher.Mono<com.azure.core.util.polling.PollResponse<T>>>,java.util.function.BiFunction<com.azure.core.util.polling.PollingContext<T>,com.azure.core.util.polling.PollResponse<T>,reactor.core.publisher.Mono<T>>,java.util.function.Function<com.azure.core.util.polling.PollingContext<T>,reactor.core.publisher.Mono<U>>)"
  fullName: "com.azure.core.util.polling.PollerFlux<T,U>.<T,U>create(Duration pollInterval, Function<PollingContext<T>,Mono<PollResponse<T>>> activationOperation, Function<PollingContext<T>,Mono<PollResponse<T>>> pollOperation, BiFunction<PollingContext<T>,PollResponse<T>,Mono<T>> cancelOperation, Function<PollingContext<T>,Mono<U>> fetchResultOperation)"
  name: "<T,U>create(Duration pollInterval, Function<PollingContext<T>,Mono<PollResponse<T>>> activationOperation, Function<PollingContext<T>,Mono<PollResponse<T>>> pollOperation, BiFunction<PollingContext<T>,PollResponse<T>,Mono<T>> cancelOperation, Function<PollingContext<T>,Mono<U>> fetchResultOperation)"
  nameWithType: "PollerFlux<T,U>.<T,U>create(Duration pollInterval, Function<PollingContext<T>,Mono<PollResponse<T>>> activationOperation, Function<PollingContext<T>,Mono<PollResponse<T>>> pollOperation, BiFunction<PollingContext<T>,PollResponse<T>,Mono<T>> cancelOperation, Function<PollingContext<T>,Mono<U>> fetchResultOperation)"
  summary: "Creates Poller<wbr>Flux."
  modifiers:
  - "static"
  parameters:
  - description: "the polling interval"
    name: "pollInterval"
    type: "<xref href=\"java.time.Duration?alt=java.time.Duration&text=Duration\" data-throw-if-not-resolved=\"False\" />"
  - description: "the activation operation to activate (start) the long running operation.\n     This operation will be invoked at most once across all subscriptions. This parameter is required.\n     If there is no specific activation work to be done then invocation should return Mono.empty(),\n     this operation will be called with a new <xref uid=\"com.azure.core.util.polling.PollingContext\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollingContext\"></xref>."
    name: "activationOperation"
    type: "<xref href=\"java.util.function.Function?alt=java.util.function.Function&text=Function\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.polling.PollingContext?alt=com.azure.core.util.polling.PollingContext&text=PollingContext\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;,<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.polling.PollResponse?alt=com.azure.core.util.polling.PollResponse&text=PollResponse\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;&gt;&gt;"
  - description: "the operation to poll the current state of long running operation. This parameter\n     is required and the operation will be called with current <xref uid=\"com.azure.core.util.polling.PollingContext\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollingContext\"></xref>."
    name: "pollOperation"
    type: "<xref href=\"java.util.function.Function?alt=java.util.function.Function&text=Function\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.polling.PollingContext?alt=com.azure.core.util.polling.PollingContext&text=PollingContext\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;,<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.polling.PollResponse?alt=com.azure.core.util.polling.PollResponse&text=PollResponse\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;&gt;&gt;"
  - description: "a <xref uid=\"java.util.function.Function\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Function\"></xref> that represents the operation to cancel the long running operation\n     if service supports cancellation. This parameter is required. If service does not support cancellation\n     then the implementer should return Mono.error with an error message indicating absence of cancellation\n     support. The operation will be called with current <xref uid=\"com.azure.core.util.polling.PollingContext\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollingContext\"></xref>."
    name: "cancelOperation"
    type: "<xref href=\"java.util.function.BiFunction?alt=java.util.function.BiFunction&text=BiFunction\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.polling.PollingContext?alt=com.azure.core.util.polling.PollingContext&text=PollingContext\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;,<xref href=\"com.azure.core.util.polling.PollResponse?alt=com.azure.core.util.polling.PollResponse&text=PollResponse\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;,<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  - description: "a <xref uid=\"java.util.function.Function\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Function\"></xref> that represents the  operation to retrieve final result of\n     the long running operation if service support it. This parameter is required and operation will be called\n     current <xref uid=\"com.azure.core.util.polling.PollingContext\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollingContext\"></xref>. If service does not have an api to fetch final result and if final result\n     is same as final poll response value then implementer can choose to simply return value from provided\n     final poll response."
    name: "fetchResultOperation"
    type: "<xref href=\"java.util.function.Function?alt=java.util.function.Function&text=Function\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.polling.PollingContext?alt=com.azure.core.util.polling.PollingContext&text=PollingContext\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;,<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"U?alt=U&text=U\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  syntax: "public static PollerFlux<T,U> <T,U>create(Duration pollInterval, Function<PollingContext<T>,Mono<PollResponse<T>>> activationOperation, Function<PollingContext<T>,Mono<PollResponse<T>>> pollOperation, BiFunction<PollingContext<T>,PollResponse<T>,Mono<T>> cancelOperation, Function<PollingContext<T>,Mono<U>> fetchResultOperation)"
  desc: "Creates PollerFlux. This create method differs from the PollerFlux constructor in that the constructor uses an activationOperation which returns a Mono that emits result, the create method uses an activationOperation which returns a Mono that emits <xref uid=\"com.azure.core.util.polling.PollResponse\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollResponse\"></xref>. The <xref uid=\"com.azure.core.util.polling.PollResponse\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollResponse\"></xref> holds the result. If the <xref uid=\"com.azure.core.util.polling.PollResponse\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollResponse\"></xref> from the activationOperation indicate that long running operation is completed then the pollOperation will not be called."
  returns:
    description: "PollerFlux"
    type: "<xref href=\"com.azure.core.util.polling.PollerFlux?alt=com.azure.core.util.polling.PollerFlux&text=PollerFlux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />,<xref href=\"U?alt=U&text=U\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.polling.PollerFlux.<T,U>create(java.time.Duration,java.util.function.Supplier<reactor.core.publisher.Mono<? extends com.azure.core.http.rest.Response<?>>>,com.azure.core.util.polling.PollingStrategy<T,U>,com.azure.core.util.serializer.TypeReference<T>,com.azure.core.util.serializer.TypeReference<U>)"
  fullName: "com.azure.core.util.polling.PollerFlux<T,U>.<T,U>create(Duration pollInterval, Supplier<Mono<? extends Response<?>>> initialOperation, PollingStrategy<T,U> strategy, TypeReference<T> pollResponseType, TypeReference<U> resultType)"
  name: "<T,U>create(Duration pollInterval, Supplier<Mono<? extends Response<?>>> initialOperation, PollingStrategy<T,U> strategy, TypeReference<T> pollResponseType, TypeReference<U> resultType)"
  nameWithType: "PollerFlux<T,U>.<T,U>create(Duration pollInterval, Supplier<Mono<? extends Response<?>>> initialOperation, PollingStrategy<T,U> strategy, TypeReference<T> pollResponseType, TypeReference<U> resultType)"
  summary: "Creates Poller<wbr>Flux."
  modifiers:
  - "static"
  parameters:
  - description: "the polling interval"
    name: "pollInterval"
    type: "<xref href=\"java.time.Duration?alt=java.time.Duration&text=Duration\" data-throw-if-not-resolved=\"False\" />"
  - description: "the activation operation to activate (start) the long running operation.\n     This operation will be invoked at most once across all subscriptions. This parameter is required.\n     If there is no specific activation work to be done then invocation should return Mono.empty(),\n     this operation will be called with a new <xref uid=\"com.azure.core.util.polling.PollingContext\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollingContext\"></xref>."
    name: "initialOperation"
    type: "<xref href=\"java.util.function.Supplier?alt=java.util.function.Supplier&text=Supplier\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"? extends com.azure.core.http.rest.Response?alt=? extends com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;?&gt;&gt;&gt;"
  - description: "a known strategy for polling a long running operation in Azure"
    name: "strategy"
    type: "<xref href=\"com.azure.core.util.polling.PollingStrategy?alt=com.azure.core.util.polling.PollingStrategy&text=PollingStrategy\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />,<xref href=\"U?alt=U&text=U\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "the <xref uid=\"com.azure.core.util.serializer.TypeReference\" data-throw-if-not-resolved=\"false\" data-raw-source=\"TypeReference\"></xref> of the response type from a polling call, or BinaryData if raw\n                         response body should be kept. This should match the generic parameter <xref uid=\"U\" data-throw-if-not-resolved=\"false\" data-raw-source=\"U\"></xref>."
    name: "pollResponseType"
    type: "<xref href=\"com.azure.core.util.serializer.TypeReference?alt=com.azure.core.util.serializer.TypeReference&text=TypeReference\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "the <xref uid=\"com.azure.core.util.serializer.TypeReference\" data-throw-if-not-resolved=\"false\" data-raw-source=\"TypeReference\"></xref> of the final result object to deserialize into, or BinaryData if raw\n                   response body should be kept. This should match the generic parameter <xref uid=\"U\" data-throw-if-not-resolved=\"false\" data-raw-source=\"U\"></xref>."
    name: "resultType"
    type: "<xref href=\"com.azure.core.util.serializer.TypeReference?alt=com.azure.core.util.serializer.TypeReference&text=TypeReference\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"U?alt=U&text=U\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static PollerFlux<T,U> <T,U>create(Duration pollInterval, Supplier<Mono<? extends Response<?>>> initialOperation, PollingStrategy<T,U> strategy, TypeReference<T> pollResponseType, TypeReference<U> resultType)"
  desc: "Creates PollerFlux. This create method uses a <xref uid=\"com.azure.core.util.polling.PollingStrategy\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollingStrategy\"></xref> to poll the status of a long running operation after the activation operation is invoked. See <xref uid=\"com.azure.core.util.polling.PollingStrategy\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollingStrategy\"></xref> for more details of known polling strategies and how to create a custom strategy."
  returns:
    description: "PollerFlux"
    type: "<xref href=\"com.azure.core.util.polling.PollerFlux?alt=com.azure.core.util.polling.PollerFlux&text=PollerFlux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />,<xref href=\"U?alt=U&text=U\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.polling.PollerFlux.<T,U>error(java.lang.Exception)"
  fullName: "com.azure.core.util.polling.PollerFlux<T,U>.<T,U>error(Exception ex)"
  name: "<T,U>error(Exception ex)"
  nameWithType: "PollerFlux<T,U>.<T,U>error(Exception ex)"
  summary: "Creates a Poller<wbr>Flux instance that returns an error on subscription."
  modifiers:
  - "static"
  parameters:
  - description: "The exception to be returned on subscription of this <xref uid=\"com.azure.core.util.polling.PollerFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollerFlux\"></xref>."
    name: "ex"
    type: "<xref href=\"java.lang.Exception?alt=java.lang.Exception&text=Exception\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static PollerFlux<T,U> <T,U>error(Exception ex)"
  desc: "Creates a PollerFlux instance that returns an error on subscription."
  returns:
    description: "A poller flux instance that returns an error without emitting any data."
    type: "<xref href=\"com.azure.core.util.polling.PollerFlux?alt=com.azure.core.util.polling.PollerFlux&text=PollerFlux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />,<xref href=\"U?alt=U&text=U\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.polling.PollerFlux.getPollInterval()"
  fullName: "com.azure.core.util.polling.PollerFlux<T,U>.getPollInterval()"
  name: "getPollInterval()"
  nameWithType: "PollerFlux<T,U>.getPollInterval()"
  summary: "Returns the current polling duration for this <xref uid=\"com.azure.core.util.polling.PollerFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollerFlux\"></xref> instance."
  syntax: "public Duration getPollInterval()"
  desc: "Returns the current polling duration for this <xref uid=\"com.azure.core.util.polling.PollerFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollerFlux\"></xref> instance."
  returns:
    description: "The current polling duration."
    type: "<xref href=\"java.time.Duration?alt=java.time.Duration&text=Duration\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.core.util.polling.PollerFlux.getSyncPoller()"
  fullName: "com.azure.core.util.polling.PollerFlux<T,U>.getSyncPoller()"
  name: "getSyncPoller()"
  nameWithType: "PollerFlux<T,U>.getSyncPoller()"
  syntax: "public SyncPoller<T,U> getSyncPoller()"
  returns:
    description: "a synchronous blocking poller."
    type: "<xref href=\"com.azure.core.util.polling.SyncPoller?alt=com.azure.core.util.polling.SyncPoller&text=SyncPoller\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />,<xref href=\"U?alt=U&text=U\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.polling.PollerFlux.setPollInterval(java.time.Duration)"
  fullName: "com.azure.core.util.polling.PollerFlux<T,U>.setPollInterval(Duration pollInterval)"
  name: "setPollInterval(Duration pollInterval)"
  nameWithType: "PollerFlux<T,U>.setPollInterval(Duration pollInterval)"
  summary: "Sets the poll interval for this poller."
  parameters:
  - description: "The new poll interval for this poller."
    name: "pollInterval"
    type: "<xref href=\"java.time.Duration?alt=java.time.Duration&text=Duration\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public PollerFlux<T,U> setPollInterval(Duration pollInterval)"
  desc: "Sets the poll interval for this poller. The new interval will be used for all subsequent polling operations including the subscriptions that are already in progress."
  returns:
    description: "The updated instance of <xref uid=\"com.azure.core.util.polling.PollerFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollerFlux\"></xref>."
    type: "<xref href=\"com.azure.core.util.polling.PollerFlux?alt=com.azure.core.util.polling.PollerFlux&text=PollerFlux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />,<xref href=\"U?alt=U&text=U\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.polling.PollerFlux.subscribe(reactor.core.CoreSubscriber<? super com.azure.core.util.polling.AsyncPollResponse<T,U>>)"
  fullName: "com.azure.core.util.polling.PollerFlux<T,U>.subscribe(CoreSubscriber<? super AsyncPollResponse<T,U>> actual)"
  name: "subscribe(CoreSubscriber<? super AsyncPollResponse<T,U>> actual)"
  nameWithType: "PollerFlux<T,U>.subscribe(CoreSubscriber<? super AsyncPollResponse<T,U>> actual)"
  overridden: "reactor.core.publisher.Flux.subscribe(reactor.core.CoreSubscriber<? super T>)"
  parameters:
  - name: "actual"
    type: "<xref href=\"reactor.core.CoreSubscriber?alt=reactor.core.CoreSubscriber&text=CoreSubscriber\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"? super com.azure.core.util.polling.AsyncPollResponse?alt=? super com.azure.core.util.polling.AsyncPollResponse&text=AsyncPollResponse\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />,<xref href=\"U?alt=U&text=U\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  syntax: "public void subscribe(CoreSubscriber<? super AsyncPollResponse<T,U>> actual)"
type: "class"
typeParameters:
- description: "The type of poll response value."
  name: "T"
- description: "The type of the final result of long running operation."
  name: "U"
desc: "A Flux that simplifies the task of executing long running operations against an Azure service. A subscription to <xref uid=\"com.azure.core.util.polling.PollerFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PollerFlux\"></xref> initiates a long running operation and polls the status until it completes.\n\n**Code samples**\n\n**Instantiating and subscribing to PollerFlux**\n\n```java\nLocalDateTime timeToReturnFinalResponse = LocalDateTime.now().plus(Duration.ofMillis(800));\n\n // Create poller instance\n PollerFlux<String, String> poller = new PollerFlux<>(Duration.ofMillis(100),\n     (context) -> Mono.empty(),\n     // Define your custom poll operation\n     (context) ->  {\n         if (LocalDateTime.now().isBefore(timeToReturnFinalResponse)) {\n             System.out.println(\"Returning intermediate response.\");\n             return Mono.just(new PollResponse<>(LongRunningOperationStatus.IN_PROGRESS,\n                     \"Operation in progress.\"));\n         } else {\n             System.out.println(\"Returning final response.\");\n             return Mono.just(new PollResponse<>(LongRunningOperationStatus.SUCCESSFULLY_COMPLETED,\n                     \"Operation completed.\"));\n         }\n     },\n     (activationResponse, context) -> Mono.error(new RuntimeException(\"Cancellation is not supported\")),\n     (context) -> Mono.just(\"Final Output\"));\n\n // Listen to poll responses\n poller.subscribe(response -> {\n     // Process poll response\n     System.out.printf(\"Got response. Status: %s, Value: %s%n\", response.getStatus(), response.getValue());\n });\n // Do something else\n```\n\n**Asynchronously wait for polling to complete and then retrieve the final result**\n\n```java\nLocalDateTime timeToReturnFinalResponse = LocalDateTime.now().plus(Duration.ofMinutes(5));\n\n // Create poller instance\n PollerFlux<String, String> poller = new PollerFlux<>(Duration.ofMillis(100),\n     (context) -> Mono.empty(),\n     (context) ->  {\n         if (LocalDateTime.now().isBefore(timeToReturnFinalResponse)) {\n             System.out.println(\"Returning intermediate response.\");\n             return Mono.just(new PollResponse<>(LongRunningOperationStatus.IN_PROGRESS,\n                     \"Operation in progress.\"));\n         } else {\n             System.out.println(\"Returning final response.\");\n             return Mono.just(new PollResponse<>(LongRunningOperationStatus.SUCCESSFULLY_COMPLETED,\n                     \"Operation completed.\"));\n         }\n     },\n     (activationResponse, context) -> Mono.just(\"FromServer:OperationIsCancelled\"),\n     (context) -> Mono.just(\"FromServer:FinalOutput\"));\n\n poller.take(Duration.ofMinutes(30))\n         .last()\n         .flatMap(asyncPollResponse -> {\n             if (asyncPollResponse.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED) {\n                 // operation completed successfully, retrieving final result.\n                 return asyncPollResponse\n                         .getFinalResult();\n             } else {\n                 return Mono.error(new RuntimeException(\"polling completed unsuccessfully with status:\"\n                         + asyncPollResponse.getStatus()));\n             }\n         }).block();\n```\n\n**Block for polling to complete and then retrieve the final result**\n\n```java\nAsyncPollResponse<String, String> terminalResponse = pollerFlux.blockLast();\n System.out.printf(\"Polling complete. Final Status: %s\", terminalResponse.getStatus());\n if (terminalResponse.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED) {\n     String finalResult = terminalResponse.getFinalResult().block();\n     System.out.printf(\"Polling complete. Final Status: %s\", finalResult);\n }\n```\n\n**Asynchronously poll until poller receives matching status**\n\n```java\nfinal Predicate<AsyncPollResponse<String, String>> isComplete = response -> {\n     return response.getStatus() != LongRunningOperationStatus.IN_PROGRESS\n         && response.getStatus() != LongRunningOperationStatus.NOT_STARTED;\n };\n\n pollerFlux\n     .takeUntil(isComplete)\n     .subscribe(completed -> {\n         System.out.println(\"Completed poll response, status: \" + completed.getStatus());\n     });\n```\n\n**Asynchronously cancel the long running operation**\n\n```java\nLocalDateTime timeToReturnFinalResponse = LocalDateTime.now().plus(Duration.ofMinutes(5));\n\n // Create poller instance\n PollerFlux<String, String> poller = new PollerFlux<>(Duration.ofMillis(100),\n     (context) -> Mono.empty(),\n     (context) ->  {\n         if (LocalDateTime.now().isBefore(timeToReturnFinalResponse)) {\n             System.out.println(\"Returning intermediate response.\");\n             return Mono.just(new PollResponse<>(LongRunningOperationStatus.IN_PROGRESS,\n                     \"Operation in progress.\"));\n         } else {\n             System.out.println(\"Returning final response.\");\n             return Mono.just(new PollResponse<>(LongRunningOperationStatus.SUCCESSFULLY_COMPLETED,\n                     \"Operation completed.\"));\n         }\n     },\n     (activationResponse, context) -> Mono.just(\"FromServer:OperationIsCancelled\"),\n     (context) -> Mono.just(\"FromServer:FinalOutput\"));\n\n // Asynchronously wait 30 minutes to complete the polling, if not completed\n // within in the time then cancel the server operation.\n poller.take(Duration.ofMinutes(30))\n         .last()\n         .flatMap(asyncPollResponse -> {\n             if (!asyncPollResponse.getStatus().isComplete()) {\n                 return asyncPollResponse\n                         .cancelOperation()\n                         .then(Mono.error(new RuntimeException(\"Operation is cancelled!\")));\n             } else {\n                 return Mono.just(asyncPollResponse);\n             }\n         }).block();\n```\n\n**Instantiating and subscribing to PollerFlux from a known polling strategy**\n\n```java\n// Create poller instance\n PollerFlux<BinaryData, String> poller = PollerFlux.create(\n     Duration.ofMillis(100),\n     // pass in your custom activation operation\n     () -> Mono.just(new SimpleResponse<Void>(new HttpRequest(\n         HttpMethod.POST,\n         \"http://httpbin.org\"),\n         202,\n         new HttpHeaders().set(\"Operation-Location\", \"http://httpbin.org\"),\n         null)),\n     new OperationResourcePollingStrategy<>(new HttpPipelineBuilder().build()),\n     TypeReference.createInstance(BinaryData.class),\n     TypeReference.createInstance(String.class));\n\n // Listen to poll responses\n poller.subscribe(response -> {\n     // Process poll response\n     System.out.printf(\"Got response. Status: %s, Value: %s%n\", response.getStatus(), response.getValue());\n });\n // Do something else\n```\n\n**Instantiating and subscribing to PollerFlux from a custom polling strategy**\n\n```java\n// Create custom polling strategy based on OperationResourcePollingStrategy\n PollingStrategy<BinaryData, String> strategy = new OperationResourcePollingStrategy<BinaryData, String>(\n         new HttpPipelineBuilder().build()) {\n     // override any interface method to customize the polling behavior\n     @Override\n     public Mono<PollResponse<BinaryData>> poll(PollingContext<BinaryData> context,\n                                                TypeReference<BinaryData> pollResponseType) {\n         return Mono.just(new PollResponse<>(\n             LongRunningOperationStatus.SUCCESSFULLY_COMPLETED,\n             BinaryData.fromString(\"\")));\n     }\n };\n\n // Create poller instance\n PollerFlux<BinaryData, String> poller = PollerFlux.create(\n     Duration.ofMillis(100),\n     // pass in your custom activation operation\n     () -> Mono.just(new SimpleResponse<Void>(new HttpRequest(\n         HttpMethod.POST,\n         \"http://httpbin.org\"),\n         202,\n         new HttpHeaders().set(\"Operation-Location\", \"http://httpbin.org\"),\n         null)),\n     strategy,\n     TypeReference.createInstance(BinaryData.class),\n     TypeReference.createInstance(String.class));\n\n // Listen to poll responses\n poller.subscribe(response -> {\n     // Process poll response\n     System.out.printf(\"Got response. Status: %s, Value: %s%n\", response.getStatus(), response.getValue());\n });\n // Do something else\n```"
metadata: {}
package: "com.azure.core.util.polling"
artifact: com.azure:azure-core:1.31.0
