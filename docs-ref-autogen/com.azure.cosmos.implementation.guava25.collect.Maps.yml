### YamlMime:ManagedReference
items:
- uid: com.azure.cosmos.implementation.guava25.collect.Maps
  id: Maps
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect
  children:
  - com.azure.cosmos.implementation.guava25.collect.Maps.<A,B>asConverter(com.azure.cosmos.implementation.guava25.collect.BiMap<A,B>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<C,K,V>newTreeMap(java.util.Comparator<C>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(java.util.Map<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(java.util.NavigableMap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(java.util.SortedMap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformValues(java.util.Map<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformValues(java.util.NavigableMap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformValues(java.util.SortedMap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>asMap(java.util.NavigableSet<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>asMap(java.util.Set<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>asMap(java.util.SortedSet<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>difference(java.util.Map<? extends K,? extends V>,java.util.Map<? extends K,? extends V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>difference(java.util.Map<? extends K,? extends V>,java.util.Map<? extends K,? extends V>,com.azure.cosmos.implementation.guava25.base.Equivalence<? super V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>difference(java.util.SortedMap<K,? extends V>,java.util.Map<? extends K,? extends V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(java.util.Map<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(java.util.SortedMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(java.util.Map<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(java.util.SortedMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(java.util.Map<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(java.util.SortedMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>immutableEntry(K,V)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>immutableEnumMap(java.util.Map<K,? extends V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newConcurrentMap()
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newEnumMap(java.lang.Class<K>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newEnumMap(java.util.Map<K,? extends V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newHashMap()
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newHashMap(java.util.Map<? extends K,? extends V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newHashMapWithExpectedSize(int)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newIdentityHashMap()
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newLinkedHashMap()
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newLinkedHashMap(java.util.Map<? extends K,? extends V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newLinkedHashMapWithExpectedSize(int)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newTreeMap()
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newTreeMap(java.util.SortedMap<K,? extends V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>subMap(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.collect.Range<K>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>synchronizedBiMap(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>synchronizedNavigableMap(java.util.NavigableMap<K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>toMap(java.lang.Iterable<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>toMap(java.util.Iterator<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex(java.lang.Iterable<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex(java.util.Iterator<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>unmodifiableBiMap(com.azure.cosmos.implementation.guava25.collect.BiMap<? extends K,? extends V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>unmodifiableNavigableMap(java.util.NavigableMap<K,? extends V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<T,K,V>toImmutableEnumMap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.<T,K,V>toImmutableEnumMap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>,java.util.function.BinaryOperator<V>)
  - com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer
  - com.azure.cosmos.implementation.guava25.collect.Maps.fromProperties(java.util.Properties)
  langs:
  - java
  name: Maps
  nameWithType: Maps
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps
  type: Class
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Static utility methods pertaining to <xref uid="java.util.Map" data-throw-if-not-resolved="false">Map</xref> instances (including instances of <xref uid="java.util.SortedMap" data-throw-if-not-resolved="false">SortedMap</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.BiMap" data-throw-if-not-resolved="false">BiMap</xref>, etc.). Also see this class's counterparts <xref uid="com.azure.cosmos.implementation.guava25.collect.Lists" data-throw-if-not-resolved="false">Lists</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.Sets" data-throw-if-not-resolved="false">Sets</xref>.


    See the Guava User Guide article on [ `Maps`][_Maps].



    [_Maps]: https://github.com/google/guava/wiki/CollectionUtilitiesExplained#maps
  syntax:
    content: public final class Maps
  inheritance:
  - java.lang.Object
  inheritedMembers:
  - java.lang.Object.clone()
  - java.lang.Object.equals(java.lang.Object)
  - java.lang.Object.finalize()
  - java.lang.Object.getClass()
  - java.lang.Object.hashCode()
  - java.lang.Object.notify()
  - java.lang.Object.notifyAll()
  - java.lang.Object.toString()
  - java.lang.Object.wait()
  - java.lang.Object.wait(long)
  - java.lang.Object.wait(long,int)
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<A,B>asConverter(com.azure.cosmos.implementation.guava25.collect.BiMap<A,B>)
  id: <A,B>asConverter(com.azure.cosmos.implementation.guava25.collect.BiMap<A,B>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <A,B>asConverter(BiMap<A,B> bimap)
  nameWithType: Maps.<A,B>asConverter(BiMap<A,B> bimap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<A,B>asConverter(BiMap<A,B> bimap)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.asConverter*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a <xref uid="com.azure.cosmos.implementation.guava25.base.Converter" data-throw-if-not-resolved="false">Converter</xref> that converts values using <xref uid="com.azure.cosmos.implementation.guava25.collect.BiMap.get" data-throw-if-not-resolved="false">bimap.get()</xref>, and whose inverse view converts values using <xref uid="com.azure.cosmos.implementation.guava25.collect.BiMap.inverse" data-throw-if-not-resolved="false">bimap.inverse()</xref>`.get()`.


    To use a plain <xref uid="java.util.Map" data-throw-if-not-resolved="false">Map</xref> as a <xref uid="com.azure.cosmos.implementation.guava25.base.Function" data-throw-if-not-resolved="false">Function</xref>, see <xref uid="com.azure.cosmos.implementation.guava25.base.Functions.forMap*" data-throw-if-not-resolved="false">com.azure.cosmos.implementation.guava25.base.Functions#forMap(Map)</xref> or <xref uid="com.azure.cosmos.implementation.guava25.base.Functions.forMap*" data-throw-if-not-resolved="false">com.azure.cosmos.implementation.guava25.base.Functions#forMap(Map, Object)</xref>.
  syntax:
    content: public static Converter<A,B> <A,B>asConverter(BiMap<A,B> bimap)
    parameters:
    - id: bimap
      type: com.azure.cosmos.implementation.guava25.collect.BiMap<A,B>
    return:
      type: com.azure.cosmos.implementation.guava25.base.Converter<A,B>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<C,K,V>newTreeMap(java.util.Comparator<C>)
  id: <C,K,V>newTreeMap(java.util.Comparator<C>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <C,K,V>newTreeMap(Comparator<C> comparator)
  nameWithType: Maps.<C,K,V>newTreeMap(Comparator<C> comparator)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<C,K,V>newTreeMap(Comparator<C> comparator)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newTreeMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable*, empty `TreeMap` instance using the given comparator.


    **Note:** if mutability is not required, use `ImmutableSortedMap.orderedBy(comparator).build()` instead.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `TreeMap` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static TreeMap<K,V> <C,K,V>newTreeMap(Comparator<C> comparator)
    parameters:
    - id: comparator
      type: java.util.Comparator<C>
      description: the comparator to sort the keys with
    return:
      type: java.util.TreeMap<K,V>
      description: a new, empty <code>TreeMap</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(java.util.Map<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  id: <K,V1,V2>transformEntries(java.util.Map<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V1,V2>transformEntries(Map<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  nameWithType: Maps.<K,V1,V2>transformEntries(Map<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(Map<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.transformEntries*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of a map whose values are derived from the original map's entries. In contrast to <xref uid="com.azure.cosmos.implementation.guava25.collect.Maps.transformValues" data-throw-if-not-resolved="false">#transformValues</xref>, this method's entry-transformation logic may depend on the key as well as the value.


    All other properties of the transformed map, such as iteration order, are left intact. For example, the code:


    ```java

    Map options =
         ImmutableMap.of("verbose", true, "sort", false);
     EntryTransformer flagPrefixer =
         new EntryTransformer() {
           public String transformEntry(String key, Boolean value) {
             return value ? key : "no" + key;
           }
         };
     Map transformed =
         Maps.transformEntries(options, flagPrefixer);
     System.out.println(transformed);
    ```


    ... prints `{verbose=verbose, sort=nosort}`.


    Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map.


    It's acceptable for the underlying map to contain null keys and null values provided that the transformer is capable of accepting null inputs. The transformed map might contain null values if the transformer sometimes gives a null result.


    The returned map is not thread-safe or serializable, even if the underlying map is.


    The transformer is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the transformer will be applied many times for bulk operations like <xref uid="java.util.Map.containsValue" data-throw-if-not-resolved="false">Map#containsValue</xref> and <xref uid="java.lang.Object.toString" data-throw-if-not-resolved="false">Object#toString</xref>. For this to perform well, `transformer` should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing.


    **Warning:** This method assumes that for any instance `k` of `EntryTransformer` key type `K`, `k.equals(k2)` implies that `k2` is also of type `K`. Using an `EntryTransformer` key type for which this may not hold, such as `ArrayList`, may risk a `ClassCastException` when calling methods on the transformed map.
  syntax:
    content: public static Map<K,V2> <K,V1,V2>transformEntries(Map<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
    parameters:
    - id: fromMap
      type: java.util.Map<K,V1>
    - id: transformer
      type: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>
    return:
      type: java.util.Map<K,V2>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(java.util.NavigableMap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  id: <K,V1,V2>transformEntries(java.util.NavigableMap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V1,V2>transformEntries(NavigableMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  nameWithType: Maps.<K,V1,V2>transformEntries(NavigableMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(NavigableMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.transformEntries*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of a navigable map whose values are derived from the original navigable map's entries. In contrast to <xref uid="com.azure.cosmos.implementation.guava25.collect.Maps.transformValues" data-throw-if-not-resolved="false">#transformValues</xref>, this method's entry-transformation logic may depend on the key as well as the value.


    All other properties of the transformed map, such as iteration order, are left intact. For example, the code:


    ```java

    NavigableMap options = Maps.newTreeMap();
     options.put("verbose", false);
     options.put("sort", true);
     EntryTransformer flagPrefixer =
         new EntryTransformer() {
           public String transformEntry(String key, Boolean value) {
             return value ? key : ("yes" + key);
           }
         };
     NavigableMap transformed =
         LabsMaps.transformNavigableEntries(options, flagPrefixer);
     System.out.println(transformed);
    ```


    ... prints `{sort=yessort, verbose=verbose}`.


    Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map.


    It's acceptable for the underlying map to contain null keys and null values provided that the transformer is capable of accepting null inputs. The transformed map might contain null values if the transformer sometimes gives a null result.


    The returned map is not thread-safe or serializable, even if the underlying map is.


    The transformer is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the transformer will be applied many times for bulk operations like <xref uid="java.util.Map.containsValue" data-throw-if-not-resolved="false">Map#containsValue</xref> and <xref uid="java.lang.Object.toString" data-throw-if-not-resolved="false">Object#toString</xref>. For this to perform well, `transformer` should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing.


    **Warning:** This method assumes that for any instance `k` of `EntryTransformer` key type `K`, `k.equals(k2)` implies that `k2` is also of type `K`. Using an `EntryTransformer` key type for which this may not hold, such as `ArrayList`, may risk a `ClassCastException` when calling methods on the transformed map.
  syntax:
    content: public static NavigableMap<K,V2> <K,V1,V2>transformEntries(NavigableMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
    parameters:
    - id: fromMap
      type: java.util.NavigableMap<K,V1>
    - id: transformer
      type: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>
    return:
      type: java.util.NavigableMap<K,V2>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(java.util.SortedMap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  id: <K,V1,V2>transformEntries(java.util.SortedMap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V1,V2>transformEntries(SortedMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  nameWithType: Maps.<K,V1,V2>transformEntries(SortedMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(SortedMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.transformEntries*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of a sorted map whose values are derived from the original sorted map's entries. In contrast to <xref uid="com.azure.cosmos.implementation.guava25.collect.Maps.transformValues" data-throw-if-not-resolved="false">#transformValues</xref>, this method's entry-transformation logic may depend on the key as well as the value.


    All other properties of the transformed map, such as iteration order, are left intact. For example, the code:


    ```java

    Map options =
         ImmutableSortedMap.of("verbose", true, "sort", false);
     EntryTransformer flagPrefixer =
         new EntryTransformer() {
           public String transformEntry(String key, Boolean value) {
             return value ? key : "yes" + key;
           }
         };
     SortedMap transformed =
         Maps.transformEntries(options, flagPrefixer);
     System.out.println(transformed);
    ```


    ... prints `{sort=yessort, verbose=verbose}`.


    Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map.


    It's acceptable for the underlying map to contain null keys and null values provided that the transformer is capable of accepting null inputs. The transformed map might contain null values if the transformer sometimes gives a null result.


    The returned map is not thread-safe or serializable, even if the underlying map is.


    The transformer is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the transformer will be applied many times for bulk operations like <xref uid="java.util.Map.containsValue" data-throw-if-not-resolved="false">Map#containsValue</xref> and <xref uid="java.lang.Object.toString" data-throw-if-not-resolved="false">Object#toString</xref>. For this to perform well, `transformer` should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing.


    **Warning:** This method assumes that for any instance `k` of `EntryTransformer` key type `K`, `k.equals(k2)` implies that `k2` is also of type `K`. Using an `EntryTransformer` key type for which this may not hold, such as `ArrayList`, may risk a `ClassCastException` when calling methods on the transformed map.
  syntax:
    content: public static SortedMap<K,V2> <K,V1,V2>transformEntries(SortedMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)
    parameters:
    - id: fromMap
      type: java.util.SortedMap<K,V1>
    - id: transformer
      type: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>
    return:
      type: java.util.SortedMap<K,V2>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformValues(java.util.Map<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  id: <K,V1,V2>transformValues(java.util.Map<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V1,V2>transformValues(Map<K,V1> fromMap, Function<? super V1,V2> function)
  nameWithType: Maps.<K,V1,V2>transformValues(Map<K,V1> fromMap, Function<? super V1,V2> function)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformValues(Map<K,V1> fromMap, Function<? super V1,V2> function)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.transformValues*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of a map where each value is transformed by a function. All other properties of the map, such as iteration order, are left intact. For example, the code:


    ```java

    Map map = ImmutableMap.of("a", 4, "b", 9);
     Function sqrt =
         new Function() {
           public Double apply(Integer in) {
             return Math.sqrt((int) in);
           }
         };
     Map transformed = Maps.transformValues(map, sqrt);
     System.out.println(transformed);
    ```


    ... prints `{a=2.0, b=3.0}`.


    Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map.


    It's acceptable for the underlying map to contain null keys, and even null values provided that the function is capable of accepting null input. The transformed map might contain null values, if the function sometimes gives a null result.


    The returned map is not thread-safe or serializable, even if the underlying map is.


    The function is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the function will be applied many times for bulk operations like <xref uid="java.util.Map.containsValue" data-throw-if-not-resolved="false">Map#containsValue</xref> and `Map.toString()`. For this to perform well, `function` should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing.
  syntax:
    content: public static Map<K,V2> <K,V1,V2>transformValues(Map<K,V1> fromMap, Function<? super V1,V2> function)
    parameters:
    - id: fromMap
      type: java.util.Map<K,V1>
    - id: function
      type: com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>
    return:
      type: java.util.Map<K,V2>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformValues(java.util.NavigableMap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  id: <K,V1,V2>transformValues(java.util.NavigableMap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V1,V2>transformValues(NavigableMap<K,V1> fromMap, Function<? super V1,V2> function)
  nameWithType: Maps.<K,V1,V2>transformValues(NavigableMap<K,V1> fromMap, Function<? super V1,V2> function)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformValues(NavigableMap<K,V1> fromMap, Function<? super V1,V2> function)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.transformValues*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of a navigable map where each value is transformed by a function. All other properties of the map, such as iteration order, are left intact. For example, the code:


    ```java

    NavigableMap map = Maps.newTreeMap();
     map.put("a", 4);
     map.put("b", 9);
     Function sqrt =
         new Function() {
           public Double apply(Integer in) {
             return Math.sqrt((int) in);
           }
         };
     NavigableMap transformed =
          Maps.transformNavigableValues(map, sqrt);
     System.out.println(transformed);
    ```


    ... prints `{a=2.0, b=3.0}`.


    Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map.


    It's acceptable for the underlying map to contain null keys, and even null values provided that the function is capable of accepting null input. The transformed map might contain null values, if the function sometimes gives a null result.


    The returned map is not thread-safe or serializable, even if the underlying map is.


    The function is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the function will be applied many times for bulk operations like <xref uid="java.util.Map.containsValue" data-throw-if-not-resolved="false">Map#containsValue</xref> and `Map.toString()`. For this to perform well, `function` should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing.
  syntax:
    content: public static NavigableMap<K,V2> <K,V1,V2>transformValues(NavigableMap<K,V1> fromMap, Function<? super V1,V2> function)
    parameters:
    - id: fromMap
      type: java.util.NavigableMap<K,V1>
    - id: function
      type: com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>
    return:
      type: java.util.NavigableMap<K,V2>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformValues(java.util.SortedMap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  id: <K,V1,V2>transformValues(java.util.SortedMap<K,V1>,com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V1,V2>transformValues(SortedMap<K,V1> fromMap, Function<? super V1,V2> function)
  nameWithType: Maps.<K,V1,V2>transformValues(SortedMap<K,V1> fromMap, Function<? super V1,V2> function)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformValues(SortedMap<K,V1> fromMap, Function<? super V1,V2> function)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.transformValues*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of a sorted map where each value is transformed by a function. All other properties of the map, such as iteration order, are left intact. For example, the code:


    ```java

    SortedMap map = ImmutableSortedMap.of("a", 4, "b", 9);
     Function sqrt =
         new Function() {
           public Double apply(Integer in) {
             return Math.sqrt((int) in);
           }
         };
     SortedMap transformed =
          Maps.transformValues(map, sqrt);
     System.out.println(transformed);
    ```


    ... prints `{a=2.0, b=3.0}`.


    Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map.


    It's acceptable for the underlying map to contain null keys, and even null values provided that the function is capable of accepting null input. The transformed map might contain null values, if the function sometimes gives a null result.


    The returned map is not thread-safe or serializable, even if the underlying map is.


    The function is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the function will be applied many times for bulk operations like <xref uid="java.util.Map.containsValue" data-throw-if-not-resolved="false">Map#containsValue</xref> and `Map.toString()`. For this to perform well, `function` should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing.
  syntax:
    content: public static SortedMap<K,V2> <K,V1,V2>transformValues(SortedMap<K,V1> fromMap, Function<? super V1,V2> function)
    parameters:
    - id: fromMap
      type: java.util.SortedMap<K,V1>
    - id: function
      type: com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>
    return:
      type: java.util.SortedMap<K,V2>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>asMap(java.util.NavigableSet<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  id: <K,V>asMap(java.util.NavigableSet<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>asMap(NavigableSet<K> set, Function<? super K,V> function)
  nameWithType: Maps.<K,V>asMap(NavigableSet<K> set, Function<? super K,V> function)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>asMap(NavigableSet<K> set, Function<? super K,V> function)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.asMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of the navigable set as a map, mapping keys from the set according to the specified function.


    Specifically, for each `k` in the backing set, the returned map has an entry mapping `k` to `function.apply(k)`. The `keySet`, `values`, and `entrySet` views of the returned map iterate in the same order as the backing set.


    Modifications to the backing set are read through to the returned map. The returned map supports removal operations if the backing set does. Removal operations write through to the backing set. The returned map does not support put operations.


    **Warning:** If the function rejects `null`, caution is required to make sure the set does not contain `null`, because the view cannot stop `null` from being added to the set.


    **Warning:** This method assumes that for any instance `k` of key type `K`, `k.equals(k2)` implies that `k2` is also of type `K`. Using a key type for which this may not hold, such as `ArrayList`, may risk a `ClassCastException` when calling methods on the resulting map view.
  syntax:
    content: public static NavigableMap<K,V> <K,V>asMap(NavigableSet<K> set, Function<? super K,V> function)
    parameters:
    - id: set
      type: java.util.NavigableSet<K>
    - id: function
      type: com.azure.cosmos.implementation.guava25.base.Function<? super K,V>
    return:
      type: java.util.NavigableMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>asMap(java.util.Set<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  id: <K,V>asMap(java.util.Set<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>asMap(Set<K> set, Function<? super K,V> function)
  nameWithType: Maps.<K,V>asMap(Set<K> set, Function<? super K,V> function)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>asMap(Set<K> set, Function<? super K,V> function)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.asMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a live <xref uid="java.util.Map" data-throw-if-not-resolved="false">Map</xref> view whose keys are the contents of `set` and whose values are computed on demand using `function`. To get an immutable *copy* instead, use <xref uid="com.azure.cosmos.implementation.guava25.collect.Maps.&lt;K,V&gt;toMap(java.lang.Iterable&lt;K&gt;,com.azure.cosmos.implementation.guava25.base.Function&lt;? super K,V&gt;)" data-throw-if-not-resolved="false">#toMap(Iterable, Function)</xref>.


    Specifically, for each `k` in the backing set, the returned map has an entry mapping `k` to `function.apply(k)`. The `keySet`, `values`, and `entrySet` views of the returned map iterate in the same order as the backing set.


    Modifications to the backing set are read through to the returned map. The returned map supports removal operations if the backing set does. Removal operations write through to the backing set. The returned map does not support put operations.


    **Warning:** If the function rejects `null`, caution is required to make sure the set does not contain `null`, because the view cannot stop `null` from being added to the set.


    **Warning:** This method assumes that for any instance `k` of key type `K`, `k.equals(k2)` implies that `k2` is also of type `K`. Using a key type for which this may not hold, such as `ArrayList`, may risk a `ClassCastException` when calling methods on the resulting map view.
  syntax:
    content: public static Map<K,V> <K,V>asMap(Set<K> set, Function<? super K,V> function)
    parameters:
    - id: set
      type: java.util.Set<K>
    - id: function
      type: com.azure.cosmos.implementation.guava25.base.Function<? super K,V>
    return:
      type: java.util.Map<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>asMap(java.util.SortedSet<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  id: <K,V>asMap(java.util.SortedSet<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>asMap(SortedSet<K> set, Function<? super K,V> function)
  nameWithType: Maps.<K,V>asMap(SortedSet<K> set, Function<? super K,V> function)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>asMap(SortedSet<K> set, Function<? super K,V> function)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.asMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of the sorted set as a map, mapping keys from the set according to the specified function.


    Specifically, for each `k` in the backing set, the returned map has an entry mapping `k` to `function.apply(k)`. The `keySet`, `values`, and `entrySet` views of the returned map iterate in the same order as the backing set.


    Modifications to the backing set are read through to the returned map. The returned map supports removal operations if the backing set does. Removal operations write through to the backing set. The returned map does not support put operations.


    **Warning:** If the function rejects `null`, caution is required to make sure the set does not contain `null`, because the view cannot stop `null` from being added to the set.


    **Warning:** This method assumes that for any instance `k` of key type `K`, `k.equals(k2)` implies that `k2` is also of type `K`. Using a key type for which this may not hold, such as `ArrayList`, may risk a `ClassCastException` when calling methods on the resulting map view.
  syntax:
    content: public static SortedMap<K,V> <K,V>asMap(SortedSet<K> set, Function<? super K,V> function)
    parameters:
    - id: set
      type: java.util.SortedSet<K>
    - id: function
      type: com.azure.cosmos.implementation.guava25.base.Function<? super K,V>
    return:
      type: java.util.SortedMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>difference(java.util.Map<? extends K,? extends V>,java.util.Map<? extends K,? extends V>)
  id: <K,V>difference(java.util.Map<? extends K,? extends V>,java.util.Map<? extends K,? extends V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>difference(Map<? extends K,? extends V> left, Map<? extends K,? extends V> right)
  nameWithType: Maps.<K,V>difference(Map<? extends K,? extends V> left, Map<? extends K,? extends V> right)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>difference(Map<? extends K,? extends V> left, Map<? extends K,? extends V> right)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.difference*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Computes the difference between two maps. This difference is an immutable snapshot of the state of the maps at the time this method is called. It will never change, even if the maps change at a later time.


    Since this method uses `HashMap` instances internally, the keys of the supplied maps must be well-behaved with respect to <xref uid="java.lang.Object.equals" data-throw-if-not-resolved="false">Object#equals</xref> and <xref uid="java.lang.Object.hashCode" data-throw-if-not-resolved="false">Object#hashCode</xref>.


    **Note:**If you only need to know whether two maps have the same mappings, call `left.equals(right)` instead of this method.
  syntax:
    content: public static MapDifference<K,V> <K,V>difference(Map<? extends K,? extends V> left, Map<? extends K,? extends V> right)
    parameters:
    - id: left
      type: java.util.Map<? extends K,? extends V>
      description: the map to treat as the "left" map for purposes of comparison
    - id: right
      type: java.util.Map<? extends K,? extends V>
      description: the map to treat as the "right" map for purposes of comparison
    return:
      type: com.azure.cosmos.implementation.guava25.collect.MapDifference<K,V>
      description: the difference between the two maps
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>difference(java.util.Map<? extends K,? extends V>,java.util.Map<? extends K,? extends V>,com.azure.cosmos.implementation.guava25.base.Equivalence<? super V>)
  id: <K,V>difference(java.util.Map<? extends K,? extends V>,java.util.Map<? extends K,? extends V>,com.azure.cosmos.implementation.guava25.base.Equivalence<? super V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>difference(Map<? extends K,? extends V> left, Map<? extends K,? extends V> right, Equivalence<? super V> valueEquivalence)
  nameWithType: Maps.<K,V>difference(Map<? extends K,? extends V> left, Map<? extends K,? extends V> right, Equivalence<? super V> valueEquivalence)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>difference(Map<? extends K,? extends V> left, Map<? extends K,? extends V> right, Equivalence<? super V> valueEquivalence)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.difference*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Computes the difference between two maps. This difference is an immutable snapshot of the state of the maps at the time this method is called. It will never change, even if the maps change at a later time.


    Since this method uses `HashMap` instances internally, the keys of the supplied maps must be well-behaved with respect to <xref uid="java.lang.Object.equals" data-throw-if-not-resolved="false">Object#equals</xref> and <xref uid="java.lang.Object.hashCode" data-throw-if-not-resolved="false">Object#hashCode</xref>.
  syntax:
    content: public static MapDifference<K,V> <K,V>difference(Map<? extends K,? extends V> left, Map<? extends K,? extends V> right, Equivalence<? super V> valueEquivalence)
    parameters:
    - id: left
      type: java.util.Map<? extends K,? extends V>
      description: the map to treat as the "left" map for purposes of comparison
    - id: right
      type: java.util.Map<? extends K,? extends V>
      description: the map to treat as the "right" map for purposes of comparison
    - id: valueEquivalence
      type: com.azure.cosmos.implementation.guava25.base.Equivalence<? super V>
      description: the equivalence relationship to use to compare values
    return:
      type: com.azure.cosmos.implementation.guava25.collect.MapDifference<K,V>
      description: the difference between the two maps
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>difference(java.util.SortedMap<K,? extends V>,java.util.Map<? extends K,? extends V>)
  id: <K,V>difference(java.util.SortedMap<K,? extends V>,java.util.Map<? extends K,? extends V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>difference(SortedMap<K,? extends V> left, Map<? extends K,? extends V> right)
  nameWithType: Maps.<K,V>difference(SortedMap<K,? extends V> left, Map<? extends K,? extends V> right)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>difference(SortedMap<K,? extends V> left, Map<? extends K,? extends V> right)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.difference*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Computes the difference between two sorted maps, using the comparator of the left map, or `Ordering.natural()` if the left map uses the natural ordering of its elements. This difference is an immutable snapshot of the state of the maps at the time this method is called. It will never change, even if the maps change at a later time.


    Since this method uses `TreeMap` instances internally, the keys of the right map must all compare as distinct according to the comparator of the left map.


    **Note:**If you only need to know whether two sorted maps have the same mappings, call `left.equals(right)` instead of this method.
  syntax:
    content: public static SortedMapDifference<K,V> <K,V>difference(SortedMap<K,? extends V> left, Map<? extends K,? extends V> right)
    parameters:
    - id: left
      type: java.util.SortedMap<K,? extends V>
      description: the map to treat as the "left" map for purposes of comparison
    - id: right
      type: java.util.Map<? extends K,? extends V>
      description: the map to treat as the "right" map for purposes of comparison
    return:
      type: com.azure.cosmos.implementation.guava25.collect.SortedMapDifference<K,V>
      description: the difference between the two maps
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  id: <K,V>filterEntries(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterEntries(BiMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  nameWithType: Maps.<K,V>filterEntries(BiMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(BiMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterEntries*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a bimap containing the mappings in `unfiltered` that satisfy a predicate. The returned bimap is a live view of `unfiltered`; changes to one affect the other.


    The resulting bimap's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the bimap and its views. When given a key/value pair that doesn't satisfy the predicate, the bimap's `put()`, `forcePut()` and `putAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>. Similarly, the map's entries have an <xref uid="? super java.util.Map.Entry.setValue" data-throw-if-not-resolved="false">Entry#setValue</xref> method that throws an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref> when the existing key and the provided value don't satisfy the predicate.


    When methods such as `removeAll()` and `clear()` are called on the filtered bimap or its views, only mappings that satisfy the filter will be removed from the underlying bimap.


    The returned bimap isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered bimap's methods, such as `size()`, iterate across every key/value mapping in the underlying bimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered bimap and use the copy.


    **Warning:** `entryPredicate` must be *consistent with equals* , as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>.
  syntax:
    content: public static BiMap<K,V> <K,V>filterEntries(BiMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
    parameters:
    - id: unfiltered
      type: com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>
    - id: entryPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(java.util.Map<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  id: <K,V>filterEntries(java.util.Map<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterEntries(Map<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  nameWithType: Maps.<K,V>filterEntries(Map<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(Map<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterEntries*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a map containing the mappings in `unfiltered` that satisfy a predicate. The returned map is a live view of `unfiltered`; changes to one affect the other.


    The resulting map's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the map and its views. When given a key/value pair that doesn't satisfy the predicate, the map's `put()` and `putAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>. Similarly, the map's entries have a <xref uid="? super java.util.Map.Entry.setValue" data-throw-if-not-resolved="false">Entry#setValue</xref> method that throws an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref> when the existing key and the provided value don't satisfy the predicate.


    When methods such as `removeAll()` and `clear()` are called on the filtered map or its views, only mappings that satisfy the filter will be removed from the underlying map.


    The returned map isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered map's methods, such as `size()`, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered map and use the copy.


    **Warning:** `entryPredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>.
  syntax:
    content: public static Map<K,V> <K,V>filterEntries(Map<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
    parameters:
    - id: unfiltered
      type: java.util.Map<K,V>
    - id: entryPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>
    return:
      type: java.util.Map<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  id: <K,V>filterEntries(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterEntries(NavigableMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  nameWithType: Maps.<K,V>filterEntries(NavigableMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(NavigableMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterEntries*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a sorted map containing the mappings in `unfiltered` that satisfy a predicate. The returned map is a live view of `unfiltered`; changes to one affect the other.


    The resulting map's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the map and its views. When given a key/value pair that doesn't satisfy the predicate, the map's `put()` and `putAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>. Similarly, the map's entries have a <xref uid="? super java.util.Map.Entry.setValue" data-throw-if-not-resolved="false">Entry#setValue</xref> method that throws an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref> when the existing key and the provided value don't satisfy the predicate.


    When methods such as `removeAll()` and `clear()` are called on the filtered map or its views, only mappings that satisfy the filter will be removed from the underlying map.


    The returned map isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered map's methods, such as `size()`, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered map and use the copy.


    **Warning:** `entryPredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>.
  syntax:
    content: public static NavigableMap<K,V> <K,V>filterEntries(NavigableMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
    parameters:
    - id: unfiltered
      type: java.util.NavigableMap<K,V>
    - id: entryPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>
    return:
      type: java.util.NavigableMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(java.util.SortedMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  id: <K,V>filterEntries(java.util.SortedMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterEntries(SortedMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  nameWithType: Maps.<K,V>filterEntries(SortedMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries(SortedMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterEntries*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a sorted map containing the mappings in `unfiltered` that satisfy a predicate. The returned map is a live view of `unfiltered`; changes to one affect the other.


    The resulting map's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the map and its views. When given a key/value pair that doesn't satisfy the predicate, the map's `put()` and `putAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>. Similarly, the map's entries have a <xref uid="? super java.util.Map.Entry.setValue" data-throw-if-not-resolved="false">Entry#setValue</xref> method that throws an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref> when the existing key and the provided value don't satisfy the predicate.


    When methods such as `removeAll()` and `clear()` are called on the filtered map or its views, only mappings that satisfy the filter will be removed from the underlying map.


    The returned map isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered map's methods, such as `size()`, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered map and use the copy.


    **Warning:** `entryPredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>.
  syntax:
    content: public static SortedMap<K,V> <K,V>filterEntries(SortedMap<K,V> unfiltered, Predicate<? super Map.Entry<K,V>> entryPredicate)
    parameters:
    - id: unfiltered
      type: java.util.SortedMap<K,V>
    - id: entryPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>
    return:
      type: java.util.SortedMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  id: <K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterKeys(BiMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  nameWithType: Maps.<K,V>filterKeys(BiMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(BiMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterKeys*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a bimap containing the mappings in `unfiltered` whose keys satisfy a predicate. The returned bimap is a live view of `unfiltered`; changes to one affect the other.


    The resulting bimap's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the bimap and its views. When given a key that doesn't satisfy the predicate, the bimap's `put()`, `forcePut()` and `putAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered bimap or its views, only mappings that satisfy the filter will be removed from the underlying bimap.


    The returned bimap isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered bimap's methods, such as `size()`, iterate across every key in the underlying bimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered bimap and use the copy.


    **Warning:** `entryPredicate` must be *consistent with equals* , as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>.
  syntax:
    content: public static BiMap<K,V> <K,V>filterKeys(BiMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
    parameters:
    - id: unfiltered
      type: com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>
    - id: keyPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super K>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(java.util.Map<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  id: <K,V>filterKeys(java.util.Map<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterKeys(Map<K,V> unfiltered, Predicate<? super K> keyPredicate)
  nameWithType: Maps.<K,V>filterKeys(Map<K,V> unfiltered, Predicate<? super K> keyPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(Map<K,V> unfiltered, Predicate<? super K> keyPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterKeys*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a map containing the mappings in `unfiltered` whose keys satisfy a predicate. The returned map is a live view of `unfiltered`; changes to one affect the other.


    The resulting map's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the map and its views. When given a key that doesn't satisfy the predicate, the map's `put()` and `putAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered map or its views, only mappings whose keys satisfy the filter will be removed from the underlying map.


    The returned map isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered map's methods, such as `size()`, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered map and use the copy.


    **Warning:** `keyPredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals.
  syntax:
    content: public static Map<K,V> <K,V>filterKeys(Map<K,V> unfiltered, Predicate<? super K> keyPredicate)
    parameters:
    - id: unfiltered
      type: java.util.Map<K,V>
    - id: keyPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super K>
    return:
      type: java.util.Map<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  id: <K,V>filterKeys(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterKeys(NavigableMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  nameWithType: Maps.<K,V>filterKeys(NavigableMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(NavigableMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterKeys*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a navigable map containing the mappings in `unfiltered` whose keys satisfy a predicate. The returned map is a live view of `unfiltered`; changes to one affect the other.


    The resulting map's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the map and its views. When given a key that doesn't satisfy the predicate, the map's `put()` and `putAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered map or its views, only mappings whose keys satisfy the filter will be removed from the underlying map.


    The returned map isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered map's methods, such as `size()`, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered map and use the copy.


    **Warning:** `keyPredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals.
  syntax:
    content: public static NavigableMap<K,V> <K,V>filterKeys(NavigableMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
    parameters:
    - id: unfiltered
      type: java.util.NavigableMap<K,V>
    - id: keyPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super K>
    return:
      type: java.util.NavigableMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(java.util.SortedMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  id: <K,V>filterKeys(java.util.SortedMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterKeys(SortedMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  nameWithType: Maps.<K,V>filterKeys(SortedMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys(SortedMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterKeys*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a sorted map containing the mappings in `unfiltered` whose keys satisfy a predicate. The returned map is a live view of `unfiltered`; changes to one affect the other.


    The resulting map's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the map and its views. When given a key that doesn't satisfy the predicate, the map's `put()` and `putAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered map or its views, only mappings whose keys satisfy the filter will be removed from the underlying map.


    The returned map isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered map's methods, such as `size()`, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered map and use the copy.


    **Warning:** `keyPredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals.
  syntax:
    content: public static SortedMap<K,V> <K,V>filterKeys(SortedMap<K,V> unfiltered, Predicate<? super K> keyPredicate)
    parameters:
    - id: unfiltered
      type: java.util.SortedMap<K,V>
    - id: keyPredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super K>
    return:
      type: java.util.SortedMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  id: <K,V>filterValues(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterValues(BiMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  nameWithType: Maps.<K,V>filterValues(BiMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(BiMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterValues*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a bimap containing the mappings in `unfiltered` whose values satisfy a predicate. The returned bimap is a live view of `unfiltered`; changes to one affect the other.


    The resulting bimap's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the bimap and its views. When given a value that doesn't satisfy the predicate, the bimap's `put()`, `forcePut()` and `putAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>. Similarly, the map's entries have a <xref uid="? super java.util.Map.Entry.setValue" data-throw-if-not-resolved="false">Entry#setValue</xref> method that throws an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref> when the provided value doesn't satisfy the predicate.


    When methods such as `removeAll()` and `clear()` are called on the filtered bimap or its views, only mappings that satisfy the filter will be removed from the underlying bimap.


    The returned bimap isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered bimap's methods, such as `size()`, iterate across every value in the underlying bimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered bimap and use the copy.


    **Warning:** `entryPredicate` must be *consistent with equals* , as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>.
  syntax:
    content: public static BiMap<K,V> <K,V>filterValues(BiMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
    parameters:
    - id: unfiltered
      type: com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>
    - id: valuePredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super V>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(java.util.Map<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  id: <K,V>filterValues(java.util.Map<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterValues(Map<K,V> unfiltered, Predicate<? super V> valuePredicate)
  nameWithType: Maps.<K,V>filterValues(Map<K,V> unfiltered, Predicate<? super V> valuePredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(Map<K,V> unfiltered, Predicate<? super V> valuePredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterValues*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a map containing the mappings in `unfiltered` whose values satisfy a predicate. The returned map is a live view of `unfiltered`; changes to one affect the other.


    The resulting map's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the map and its views. When given a value that doesn't satisfy the predicate, the map's `put()`, `putAll()`, and <xref uid="? super java.util.Map.Entry.setValue" data-throw-if-not-resolved="false">Entry#setValue</xref> methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered map or its views, only mappings whose values satisfy the filter will be removed from the underlying map.


    The returned map isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered map's methods, such as `size()`, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered map and use the copy.


    **Warning:** `valuePredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals.
  syntax:
    content: public static Map<K,V> <K,V>filterValues(Map<K,V> unfiltered, Predicate<? super V> valuePredicate)
    parameters:
    - id: unfiltered
      type: java.util.Map<K,V>
    - id: valuePredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super V>
    return:
      type: java.util.Map<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  id: <K,V>filterValues(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterValues(NavigableMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  nameWithType: Maps.<K,V>filterValues(NavigableMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(NavigableMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterValues*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a navigable map containing the mappings in `unfiltered` whose values satisfy a predicate. The returned map is a live view of `unfiltered`; changes to one affect the other.


    The resulting map's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the map and its views. When given a value that doesn't satisfy the predicate, the map's `put()`, `putAll()`, and <xref uid="? super java.util.Map.Entry.setValue" data-throw-if-not-resolved="false">Entry#setValue</xref> methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered map or its views, only mappings whose values satisfy the filter will be removed from the underlying map.


    The returned map isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered map's methods, such as `size()`, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered map and use the copy.


    **Warning:** `valuePredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals.
  syntax:
    content: public static NavigableMap<K,V> <K,V>filterValues(NavigableMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
    parameters:
    - id: unfiltered
      type: java.util.NavigableMap<K,V>
    - id: valuePredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super V>
    return:
      type: java.util.NavigableMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(java.util.SortedMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  id: <K,V>filterValues(java.util.SortedMap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>filterValues(SortedMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  nameWithType: Maps.<K,V>filterValues(SortedMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues(SortedMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.filterValues*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a sorted map containing the mappings in `unfiltered` whose values satisfy a predicate. The returned map is a live view of `unfiltered`; changes to one affect the other.


    The resulting map's `keySet()`, `entrySet()`, and `values()` views have iterators that don't support `remove()`, but all other methods are supported by the map and its views. When given a value that doesn't satisfy the predicate, the map's `put()`, `putAll()`, and <xref uid="? super java.util.Map.Entry.setValue" data-throw-if-not-resolved="false">Entry#setValue</xref> methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>.


    When methods such as `removeAll()` and `clear()` are called on the filtered map or its views, only mappings whose values satisfy the filter will be removed from the underlying map.


    The returned map isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered map's methods, such as `size()`, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered map and use the copy.


    **Warning:** `valuePredicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals.
  syntax:
    content: public static SortedMap<K,V> <K,V>filterValues(SortedMap<K,V> unfiltered, Predicate<? super V> valuePredicate)
    parameters:
    - id: unfiltered
      type: java.util.SortedMap<K,V>
    - id: valuePredicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super V>
    return:
      type: java.util.SortedMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>immutableEntry(K,V)
  id: <K,V>immutableEntry(K,V)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>immutableEntry(K key, V value)
  nameWithType: Maps.<K,V>immutableEntry(K key, V value)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>immutableEntry(K key, V value)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.immutableEntry*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an immutable map entry with the specified key and value. The <xref uid="? super java.util.Map.Entry.setValue" data-throw-if-not-resolved="false">Entry#setValue</xref> operation throws an <xref uid="java.lang.UnsupportedOperationException" data-throw-if-not-resolved="false">UnsupportedOperationException</xref>.


    The returned entry is serializable.
  syntax:
    content: public static Map.Entry<K,V> <K,V>immutableEntry(K key, V value)
    parameters:
    - id: key
      type: K
      description: the key to be associated with the returned entry
    - id: value
      type: V
      description: the value to be associated with the returned entry
    return:
      type: java.util.Map.Entry<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>immutableEnumMap(java.util.Map<K,? extends V>)
  id: <K,V>immutableEnumMap(java.util.Map<K,? extends V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>immutableEnumMap(Map<K,? extends V> map)
  nameWithType: Maps.<K,V>immutableEnumMap(Map<K,? extends V> map)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>immutableEnumMap(Map<K,? extends V> map)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.immutableEnumMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an immutable map instance containing the given entries. Internally, the returned map will be backed by an <xref uid="java.util.EnumMap" data-throw-if-not-resolved="false">EnumMap</xref>.


    The iteration order of the returned map follows the enum's iteration order, not the order in which the elements appear in the given map.
  syntax:
    content: public static ImmutableMap<K,V> <K,V>immutableEnumMap(Map<K,? extends V> map)
    parameters:
    - id: map
      type: java.util.Map<K,? extends V>
      description: the map to make an immutable copy of
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableMap<K,V>
      description: an immutable map containing those entries
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newConcurrentMap()
  id: <K,V>newConcurrentMap()
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newConcurrentMap()
  nameWithType: Maps.<K,V>newConcurrentMap()
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newConcurrentMap()
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newConcurrentMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Creates a new empty <xref uid="" data-throw-if-not-resolved="false">ConcurrentHashMap</xref> instance.
  syntax:
    content: public static ConcurrentMap<K,V> <K,V>newConcurrentMap()
    return:
      type: java.util.concurrent.ConcurrentMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newEnumMap(java.lang.Class<K>)
  id: <K,V>newEnumMap(java.lang.Class<K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newEnumMap(Class<K> type)
  nameWithType: Maps.<K,V>newEnumMap(Class<K> type)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newEnumMap(Class<K> type)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newEnumMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Creates an `EnumMap` instance.
  syntax:
    content: public static EnumMap<K,V> <K,V>newEnumMap(Class<K> type)
    parameters:
    - id: type
      type: java.lang.Class<K>
      description: the key type for this map
    return:
      type: java.util.EnumMap<K,V>
      description: a new, empty <code>EnumMap</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newEnumMap(java.util.Map<K,? extends V>)
  id: <K,V>newEnumMap(java.util.Map<K,? extends V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newEnumMap(Map<K,? extends V> map)
  nameWithType: Maps.<K,V>newEnumMap(Map<K,? extends V> map)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newEnumMap(Map<K,? extends V> map)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newEnumMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates an `EnumMap` with the same mappings as the specified map.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `EnumMap` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static EnumMap<K,V> <K,V>newEnumMap(Map<K,? extends V> map)
    parameters:
    - id: map
      type: java.util.Map<K,? extends V>
      description: the map from which to initialize this <code>EnumMap</code>
    return:
      type: java.util.EnumMap<K,V>
      description: a new <code>EnumMap</code> initialized with the mappings from <code>map</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newHashMap()
  id: <K,V>newHashMap()
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newHashMap()
  nameWithType: Maps.<K,V>newHashMap()
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newHashMap()
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newHashMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable*, empty `HashMap` instance.


    **Note:** if mutability is not required, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableMap.&lt;K,V&gt;of()" data-throw-if-not-resolved="false">ImmutableMap#of()</xref> instead.


    **Note:** if `K` is an `enum` type, use <xref uid="com.azure.cosmos.implementation.guava25.collect.Maps.newEnumMap" data-throw-if-not-resolved="false">#newEnumMap</xref> instead.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `HashMap` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static HashMap<K,V> <K,V>newHashMap()
    return:
      type: java.util.HashMap<K,V>
      description: a new, empty <code>HashMap</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newHashMap(java.util.Map<? extends K,? extends V>)
  id: <K,V>newHashMap(java.util.Map<? extends K,? extends V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newHashMap(Map<? extends K,? extends V> map)
  nameWithType: Maps.<K,V>newHashMap(Map<? extends K,? extends V> map)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newHashMap(Map<? extends K,? extends V> map)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newHashMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable* `HashMap` instance with the same mappings as the specified map.


    **Note:** if mutability is not required, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableMap.&lt;K,V&gt;copyOf(java.util.Map&lt;? extends K,? extends V&gt;)" data-throw-if-not-resolved="false">ImmutableMap#copyOf(Map)</xref> instead.


    **Note:** if `K` is an <xref uid="java.lang.Enum" data-throw-if-not-resolved="false">Enum</xref> type, use <xref uid="com.azure.cosmos.implementation.guava25.collect.Maps.newEnumMap" data-throw-if-not-resolved="false">#newEnumMap</xref> instead.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `HashMap` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static HashMap<K,V> <K,V>newHashMap(Map<? extends K,? extends V> map)
    parameters:
    - id: map
      type: java.util.Map<? extends K,? extends V>
      description: the mappings to be placed in the new map
    return:
      type: java.util.HashMap<K,V>
      description: a new <code>HashMap</code> initialized with the mappings from <code>map</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newHashMapWithExpectedSize(int)
  id: <K,V>newHashMapWithExpectedSize(int)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newHashMapWithExpectedSize(int expectedSize)
  nameWithType: Maps.<K,V>newHashMapWithExpectedSize(int expectedSize)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newHashMapWithExpectedSize(int expectedSize)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newHashMapWithExpectedSize*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Creates a `HashMap` instance, with a high enough "initial capacity" that it *should* hold `expectedSize` elements without growth. This behavior cannot be broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the method isn't inadvertently *oversizing* the returned map.
  syntax:
    content: public static HashMap<K,V> <K,V>newHashMapWithExpectedSize(int expectedSize)
    parameters:
    - id: expectedSize
      type: int
      description: the number of entries you expect to add to the returned map
    return:
      type: java.util.HashMap<K,V>
      description: >-
        a new, empty <code>HashMap</code> with enough capacity to hold <code>expectedSize</code> entries
             without resizing
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newIdentityHashMap()
  id: <K,V>newIdentityHashMap()
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newIdentityHashMap()
  nameWithType: Maps.<K,V>newIdentityHashMap()
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newIdentityHashMap()
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newIdentityHashMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates an `IdentityHashMap` instance.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `IdentityHashMap` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static IdentityHashMap<K,V> <K,V>newIdentityHashMap()
    return:
      type: java.util.IdentityHashMap<K,V>
      description: a new, empty <code>IdentityHashMap</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newLinkedHashMap()
  id: <K,V>newLinkedHashMap()
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newLinkedHashMap()
  nameWithType: Maps.<K,V>newLinkedHashMap()
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newLinkedHashMap()
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newLinkedHashMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable*, empty, insertion-ordered `LinkedHashMap` instance.


    **Note:** if mutability is not required, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableMap.&lt;K,V&gt;of()" data-throw-if-not-resolved="false">ImmutableMap#of()</xref> instead.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `LinkedHashMap` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static LinkedHashMap<K,V> <K,V>newLinkedHashMap()
    return:
      type: java.util.LinkedHashMap<K,V>
      description: a new, empty <code>LinkedHashMap</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newLinkedHashMap(java.util.Map<? extends K,? extends V>)
  id: <K,V>newLinkedHashMap(java.util.Map<? extends K,? extends V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newLinkedHashMap(Map<? extends K,? extends V> map)
  nameWithType: Maps.<K,V>newLinkedHashMap(Map<? extends K,? extends V> map)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newLinkedHashMap(Map<? extends K,? extends V> map)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newLinkedHashMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable*, insertion-ordered `LinkedHashMap` instance with the same mappings as the specified map.


    **Note:** if mutability is not required, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableMap.&lt;K,V&gt;copyOf(java.util.Map&lt;? extends K,? extends V&gt;)" data-throw-if-not-resolved="false">ImmutableMap#copyOf(Map)</xref> instead.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `LinkedHashMap` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static LinkedHashMap<K,V> <K,V>newLinkedHashMap(Map<? extends K,? extends V> map)
    parameters:
    - id: map
      type: java.util.Map<? extends K,? extends V>
      description: the mappings to be placed in the new map
    return:
      type: java.util.LinkedHashMap<K,V>
      description: a new, <code>LinkedHashMap</code> initialized with the mappings from <code>map</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newLinkedHashMapWithExpectedSize(int)
  id: <K,V>newLinkedHashMapWithExpectedSize(int)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newLinkedHashMapWithExpectedSize(int expectedSize)
  nameWithType: Maps.<K,V>newLinkedHashMapWithExpectedSize(int expectedSize)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newLinkedHashMapWithExpectedSize(int expectedSize)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newLinkedHashMapWithExpectedSize*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Creates a `LinkedHashMap` instance, with a high enough "initial capacity" that it *should* hold `expectedSize` elements without growth. This behavior cannot be broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the method isn't inadvertently *oversizing* the returned map.
  syntax:
    content: public static LinkedHashMap<K,V> <K,V>newLinkedHashMapWithExpectedSize(int expectedSize)
    parameters:
    - id: expectedSize
      type: int
      description: the number of entries you expect to add to the returned map
    return:
      type: java.util.LinkedHashMap<K,V>
      description: >-
        a new, empty <code>LinkedHashMap</code> with enough capacity to hold <code>expectedSize</code>
             entries without resizing
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newTreeMap()
  id: <K,V>newTreeMap()
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newTreeMap()
  nameWithType: Maps.<K,V>newTreeMap()
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newTreeMap()
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newTreeMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable*, empty `TreeMap` instance using the natural ordering of its elements.


    **Note:** if mutability is not required, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSortedMap.&lt;K,V&gt;of()" data-throw-if-not-resolved="false">ImmutableSortedMap#of()</xref> instead.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `TreeMap` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static TreeMap<K,V> <K,V>newTreeMap()
    return:
      type: java.util.TreeMap<K,V>
      description: a new, empty <code>TreeMap</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newTreeMap(java.util.SortedMap<K,? extends V>)
  id: <K,V>newTreeMap(java.util.SortedMap<K,? extends V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>newTreeMap(SortedMap<K,? extends V> map)
  nameWithType: Maps.<K,V>newTreeMap(SortedMap<K,? extends V> map)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newTreeMap(SortedMap<K,? extends V> map)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.newTreeMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable* `TreeMap` instance with the same mappings as the specified map and using the same ordering as the specified map.


    **Note:** if mutability is not required, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSortedMap.&lt;K,V&gt;copyOfSorted(java.util.SortedMap&lt;K,? extends V&gt;)" data-throw-if-not-resolved="false">ImmutableSortedMap#copyOfSorted(SortedMap)</xref> instead.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `TreeMap` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static TreeMap<K,V> <K,V>newTreeMap(SortedMap<K,? extends V> map)
    parameters:
    - id: map
      type: java.util.SortedMap<K,? extends V>
      description: >-
        the sorted map whose mappings are to be placed in the new map and whose comparator
             is to be used to sort the new map
    return:
      type: java.util.TreeMap<K,V>
      description: >-
        a new <code>TreeMap</code> initialized with the mappings from <code>map</code> and using the
             comparator of <code>map</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>subMap(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.collect.Range<K>)
  id: <K,V>subMap(java.util.NavigableMap<K,V>,com.azure.cosmos.implementation.guava25.collect.Range<K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>subMap(NavigableMap<K,V> map, Range<K> range)
  nameWithType: Maps.<K,V>subMap(NavigableMap<K,V> map, Range<K> range)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>subMap(NavigableMap<K,V> map, Range<K> range)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.subMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of the portion of `map` whose keys are contained by `range`.


    This method delegates to the appropriate methods of <xref uid="java.util.NavigableMap" data-throw-if-not-resolved="false">NavigableMap</xref> (namely <xref uid="java.util.NavigableMap.subMap*" data-throw-if-not-resolved="false">subMap()</xref>, <xref uid="java.util.NavigableMap.tailMap*" data-throw-if-not-resolved="false">tailMap()</xref>, and <xref uid="NavigableMap#headMap(Object,
     boolean)" data-throw-if-not-resolved="false">headMap()</xref>) to actually construct the view. Consult these methods for a full description of the returned view's behavior.

    **Warning:** `Range`s always represent a range of values using the values' natural ordering. `NavigableMap` on the other hand can specify a custom ordering via a <xref uid="java.util.Comparator" data-throw-if-not-resolved="false">Comparator</xref>, which can violate the natural ordering. Using this method (or in general using `Range`) with unnaturally-ordered maps can lead to unexpected and undefined behavior.
  syntax:
    content: public static NavigableMap<K,V> <K,V>subMap(NavigableMap<K,V> map, Range<K> range)
    parameters:
    - id: map
      type: java.util.NavigableMap<K,V>
    - id: range
      type: com.azure.cosmos.implementation.guava25.collect.Range<K>
    return:
      type: java.util.NavigableMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>synchronizedBiMap(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>)
  id: <K,V>synchronizedBiMap(com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>synchronizedBiMap(BiMap<K,V> bimap)
  nameWithType: Maps.<K,V>synchronizedBiMap(BiMap<K,V> bimap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>synchronizedBiMap(BiMap<K,V> bimap)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.synchronizedBiMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a synchronized (thread-safe) bimap backed by the specified bimap. In order to guarantee serial access, it is critical that **all** access to the backing bimap is accomplished through the returned bimap.


    It is imperative that the user manually synchronize on the returned map when accessing any of its collection views:


    ```java

    BiMap map = Maps.synchronizedBiMap(
         HashBiMap.create());
     ...
     Set set = map.keySet();  // Needn't be in synchronized block
     ...
     synchronized (map) {  // Synchronizing on map, not set!
       Iterator it = set.iterator(); // Must be in synchronized block
       while (it.hasNext()) {
         foo(it.next());
       }
     }
    ```


    Failure to follow this advice may result in non-deterministic behavior.


    The returned bimap will be serializable if the specified bimap is serializable.
  syntax:
    content: public static BiMap<K,V> <K,V>synchronizedBiMap(BiMap<K,V> bimap)
    parameters:
    - id: bimap
      type: com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>
      description: the bimap to be wrapped in a synchronized view
    return:
      type: com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>
      description: a synchronized view of the specified bimap
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>synchronizedNavigableMap(java.util.NavigableMap<K,V>)
  id: <K,V>synchronizedNavigableMap(java.util.NavigableMap<K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>synchronizedNavigableMap(NavigableMap<K,V> navigableMap)
  nameWithType: Maps.<K,V>synchronizedNavigableMap(NavigableMap<K,V> navigableMap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>synchronizedNavigableMap(NavigableMap<K,V> navigableMap)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.synchronizedNavigableMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In order to guarantee serial access, it is critical that **all** access to the backing navigable map is accomplished through the returned navigable map (or its views).


    It is imperative that the user manually synchronize on the returned navigable map when iterating over any of its collection views, or the collections views of any of its `descendingMap`, `subMap`, `headMap` or `tailMap` views.


    ```java

    NavigableMap map = synchronizedNavigableMap(new TreeMap());

     // Needn't be in synchronized block
     NavigableSet set = map.navigableKeySet();

     synchronized (map) { // Synchronizing on map, not set!
       Iterator it = set.iterator(); // Must be in synchronized block
       while (it.hasNext()) {
         foo(it.next());
       }
     }
    ```


    or:


    ```java

    NavigableMap map = synchronizedNavigableMap(new TreeMap());
     NavigableMap map2 = map.subMap(foo, false, bar, true);

     // Needn't be in synchronized block
     NavigableSet set2 = map2.descendingKeySet();

     synchronized (map) { // Synchronizing on map, not map2 or set2!
       Iterator it = set2.iterator(); // Must be in synchronized block
       while (it.hasNext()) {
         foo(it.next());
       }
     }
    ```


    Failure to follow this advice may result in non-deterministic behavior.


    The returned navigable map will be serializable if the specified navigable map is serializable.
  syntax:
    content: public static NavigableMap<K,V> <K,V>synchronizedNavigableMap(NavigableMap<K,V> navigableMap)
    parameters:
    - id: navigableMap
      type: java.util.NavigableMap<K,V>
      description: the navigable map to be "wrapped" in a synchronized navigable map.
    return:
      type: java.util.NavigableMap<K,V>
      description: a synchronized view of the specified navigable map.
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>toMap(java.lang.Iterable<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  id: <K,V>toMap(java.lang.Iterable<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>toMap(Iterable<K> keys, Function<? super K,V> valueFunction)
  nameWithType: Maps.<K,V>toMap(Iterable<K> keys, Function<? super K,V> valueFunction)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>toMap(Iterable<K> keys, Function<? super K,V> valueFunction)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.toMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an immutable map whose keys are the distinct elements of `keys` and whose value for each key was computed by `valueFunction`. The map's iteration order is the order of the first appearance of each key in `keys`.


    When there are multiple instances of a key in `keys`, it is unspecified whether `valueFunction` will be applied to more than one instance of that key and, if it is, which result will be mapped to that key in the returned map.


    If `keys` is a <xref uid="java.util.Set" data-throw-if-not-resolved="false">Set</xref>, a live view can be obtained instead of a copy using <xref uid="com.azure.cosmos.implementation.guava25.collect.Maps.&lt;K,V&gt;asMap(java.util.Set&lt;K&gt;,com.azure.cosmos.implementation.guava25.base.Function&lt;? super K,V&gt;)" data-throw-if-not-resolved="false">Maps#asMap(Set, Function)</xref>.
  syntax:
    content: public static ImmutableMap<K,V> <K,V>toMap(Iterable<K> keys, Function<? super K,V> valueFunction)
    parameters:
    - id: keys
      type: java.lang.Iterable<K>
    - id: valueFunction
      type: com.azure.cosmos.implementation.guava25.base.Function<? super K,V>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>toMap(java.util.Iterator<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  id: <K,V>toMap(java.util.Iterator<K>,com.azure.cosmos.implementation.guava25.base.Function<? super K,V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>toMap(Iterator<K> keys, Function<? super K,V> valueFunction)
  nameWithType: Maps.<K,V>toMap(Iterator<K> keys, Function<? super K,V> valueFunction)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>toMap(Iterator<K> keys, Function<? super K,V> valueFunction)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.toMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an immutable map whose keys are the distinct elements of `keys` and whose value for each key was computed by `valueFunction`. The map's iteration order is the order of the first appearance of each key in `keys`.


    When there are multiple instances of a key in `keys`, it is unspecified whether `valueFunction` will be applied to more than one instance of that key and, if it is, which result will be mapped to that key in the returned map.
  syntax:
    content: public static ImmutableMap<K,V> <K,V>toMap(Iterator<K> keys, Function<? super K,V> valueFunction)
    parameters:
    - id: keys
      type: java.util.Iterator<K>
    - id: valueFunction
      type: com.azure.cosmos.implementation.guava25.base.Function<? super K,V>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableMap<K,V>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex(java.lang.Iterable<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  id: <K,V>uniqueIndex(java.lang.Iterable<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>uniqueIndex(Iterable<V> values, Function<? super V,K> keyFunction)
  nameWithType: Maps.<K,V>uniqueIndex(Iterable<V> values, Function<? super V,K> keyFunction)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex(Iterable<V> values, Function<? super V,K> keyFunction)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.uniqueIndex*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a map with the given `values`, indexed by keys derived from those values. In other words, each input value produces an entry in the map whose key is the result of applying `keyFunction` to that value. These entries appear in the same order as the input values. Example usage:


    ```java

    Color red = new Color("red", 255, 0, 0);
     ...
     ImmutableSet allColors = ImmutableSet.of(red, green, blue);

     Map colorForName =
         uniqueIndex(allColors, toStringFunction());
     assertThat(colorForName).containsEntry("red", red);
    ```


    If your index may associate multiple values with each key, use <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.&lt;K,V&gt;index(java.lang.Iterable&lt;V&gt;,com.azure.cosmos.implementation.guava25.base.Function&lt;? super V,K&gt;)" data-throw-if-not-resolved="false">Multimaps.index</xref>.
  syntax:
    content: public static ImmutableMap<K,V> <K,V>uniqueIndex(Iterable<V> values, Function<? super V,K> keyFunction)
    parameters:
    - id: values
      type: java.lang.Iterable<V>
      description: the values to use when constructing the <code>Map</code>
    - id: keyFunction
      type: com.azure.cosmos.implementation.guava25.base.Function<? super V,K>
      description: the function used to produce the key for each value
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableMap<K,V>
      description: >-
        a map mapping the result of evaluating the function <code>keyFunction</code> on each value
             in the input collection to that value
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex(java.util.Iterator<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  id: <K,V>uniqueIndex(java.util.Iterator<V>,com.azure.cosmos.implementation.guava25.base.Function<? super V,K>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>uniqueIndex(Iterator<V> values, Function<? super V,K> keyFunction)
  nameWithType: Maps.<K,V>uniqueIndex(Iterator<V> values, Function<? super V,K> keyFunction)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex(Iterator<V> values, Function<? super V,K> keyFunction)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.uniqueIndex*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a map with the given `values`, indexed by keys derived from those values. In other words, each input value produces an entry in the map whose key is the result of applying `keyFunction` to that value. These entries appear in the same order as the input values. Example usage:


    ```java

    Color red = new Color("red", 255, 0, 0);
     ...
     Iterator allColors = ImmutableSet.of(red, green, blue).iterator();

     Map colorForName =
         uniqueIndex(allColors, toStringFunction());
     assertThat(colorForName).containsEntry("red", red);
    ```


    If your index may associate multiple values with each key, use <xref uid="com.azure.cosmos.implementation.guava25.collect.Multimaps.&lt;K,V&gt;index(java.util.Iterator&lt;V&gt;,com.azure.cosmos.implementation.guava25.base.Function&lt;? super V,K&gt;)" data-throw-if-not-resolved="false">Multimaps.index</xref>.
  syntax:
    content: public static ImmutableMap<K,V> <K,V>uniqueIndex(Iterator<V> values, Function<? super V,K> keyFunction)
    parameters:
    - id: values
      type: java.util.Iterator<V>
      description: the values to use when constructing the <code>Map</code>
    - id: keyFunction
      type: com.azure.cosmos.implementation.guava25.base.Function<? super V,K>
      description: the function used to produce the key for each value
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableMap<K,V>
      description: >-
        a map mapping the result of evaluating the function <code>keyFunction</code> on each value
             in the input collection to that value
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>unmodifiableBiMap(com.azure.cosmos.implementation.guava25.collect.BiMap<? extends K,? extends V>)
  id: <K,V>unmodifiableBiMap(com.azure.cosmos.implementation.guava25.collect.BiMap<? extends K,? extends V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>unmodifiableBiMap(BiMap<? extends K,? extends V> bimap)
  nameWithType: Maps.<K,V>unmodifiableBiMap(BiMap<? extends K,? extends V> bimap)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>unmodifiableBiMap(BiMap<? extends K,? extends V> bimap)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.unmodifiableBiMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an unmodifiable view of the specified bimap. This method allows modules to provide users with "read-only" access to internal bimaps. Query operations on the returned bimap "read through" to the specified bimap, and attempts to modify the returned map, whether direct or via its collection views, result in an `UnsupportedOperationException`.


    The returned bimap will be serializable if the specified bimap is serializable.
  syntax:
    content: public static BiMap<K,V> <K,V>unmodifiableBiMap(BiMap<? extends K,? extends V> bimap)
    parameters:
    - id: bimap
      type: com.azure.cosmos.implementation.guava25.collect.BiMap<? extends K,? extends V>
      description: the bimap for which an unmodifiable view is to be returned
    return:
      type: com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>
      description: an unmodifiable view of the specified bimap
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>unmodifiableNavigableMap(java.util.NavigableMap<K,? extends V>)
  id: <K,V>unmodifiableNavigableMap(java.util.NavigableMap<K,? extends V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <K,V>unmodifiableNavigableMap(NavigableMap<K,? extends V> map)
  nameWithType: Maps.<K,V>unmodifiableNavigableMap(NavigableMap<K,? extends V> map)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>unmodifiableNavigableMap(NavigableMap<K,? extends V> map)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.unmodifiableNavigableMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an unmodifiable view of the specified navigable map. Query operations on the returned map read through to the specified map, and attempts to modify the returned map, whether direct or via its views, result in an `UnsupportedOperationException`.


    The returned navigable map will be serializable if the specified navigable map is serializable.


    This method's signature will not permit you to convert a `NavigableMap` to a `NavigableMap`. If it permitted this, the returned map's `comparator()` method might return a `Comparator`, which works only on a particular subtype of `K`, but promise that it's a `Comparator`, which must work on any type of `K`.
  syntax:
    content: public static NavigableMap<K,V> <K,V>unmodifiableNavigableMap(NavigableMap<K,? extends V> map)
    parameters:
    - id: map
      type: java.util.NavigableMap<K,? extends V>
      description: the navigable map for which an unmodifiable view is to be returned
    return:
      type: java.util.NavigableMap<K,V>
      description: an unmodifiable view of the specified navigable map
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<T,K,V>toImmutableEnumMap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>)
  id: <T,K,V>toImmutableEnumMap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <T,K,V>toImmutableEnumMap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction)
  nameWithType: Maps.<T,K,V>toImmutableEnumMap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<T,K,V>toImmutableEnumMap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.toImmutableEnumMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a <xref uid="java.util.stream.Collector" data-throw-if-not-resolved="false">Collector</xref> that accumulates elements into an `ImmutableMap` whose keys and values are the result of applying the provided mapping functions to the input elements. The resulting implementation is specialized for enum key types. The returned map and its views will iterate over keys in their enum definition order, not encounter order.


    If the mapped keys contain duplicates, an `IllegalArgumentException` is thrown when the collection operation is performed. (This differs from the `Collector` returned by <xref uid="java.util.stream.Collectors#toMap(java.util.function.Function,
     java.util.function.Function)" data-throw-if-not-resolved="false">Collectors.toMap(Function, Function)</xref>, which throws an `IllegalStateException`.)
  syntax:
    content: public static Collector<T,?,ImmutableMap<K,V>> <T,K,V>toImmutableEnumMap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction)
    parameters:
    - id: keyFunction
      type: java.util.function.Function<? super T,? extends K>
    - id: valueFunction
      type: java.util.function.Function<? super T,? extends V>
    return:
      type: java.util.stream.Collector<T,?,com.azure.cosmos.implementation.guava25.collect.ImmutableMap<K,V>>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.<T,K,V>toImmutableEnumMap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>,java.util.function.BinaryOperator<V>)
  id: <T,K,V>toImmutableEnumMap(java.util.function.Function<? super T,? extends K>,java.util.function.Function<? super T,? extends V>,java.util.function.BinaryOperator<V>)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: <T,K,V>toImmutableEnumMap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction, BinaryOperator<V> mergeFunction)
  nameWithType: Maps.<T,K,V>toImmutableEnumMap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction, BinaryOperator<V> mergeFunction)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<T,K,V>toImmutableEnumMap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction, BinaryOperator<V> mergeFunction)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.toImmutableEnumMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a <xref uid="java.util.stream.Collector" data-throw-if-not-resolved="false">Collector</xref> that accumulates elements into an `ImmutableMap` whose keys and values are the result of applying the provided mapping functions to the input elements. The resulting implementation is specialized for enum key types. The returned map and its views will iterate over keys in their enum definition order, not encounter order.


    If the mapped keys contain duplicates, the values are merged using the specified merging function.
  syntax:
    content: public static Collector<T,?,ImmutableMap<K,V>> <T,K,V>toImmutableEnumMap(Function<? super T,? extends K> keyFunction, Function<? super T,? extends V> valueFunction, BinaryOperator<V> mergeFunction)
    parameters:
    - id: keyFunction
      type: java.util.function.Function<? super T,? extends K>
    - id: valueFunction
      type: java.util.function.Function<? super T,? extends V>
    - id: mergeFunction
      type: java.util.function.BinaryOperator<V>
    return:
      type: java.util.stream.Collector<T,?,com.azure.cosmos.implementation.guava25.collect.ImmutableMap<K,V>>
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.Maps()
  id: Maps()
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: Maps()
  nameWithType: Maps.Maps()
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.Maps()
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.Maps*
  type: Constructor
  package: com.azure.cosmos.implementation.guava25.collect
  syntax:
    content: private Maps()
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.fromProperties(java.util.Properties)
  id: fromProperties(java.util.Properties)
  artifact: com.azure:azure-cosmos:4.0.1
  parent: com.azure.cosmos.implementation.guava25.collect.Maps
  langs:
  - java
  name: fromProperties(Properties properties)
  nameWithType: Maps.fromProperties(Properties properties)
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.fromProperties(Properties properties)
  overload: com.azure.cosmos.implementation.guava25.collect.Maps.fromProperties*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Creates an `ImmutableMap` from a `Properties` instance. Properties normally derive from `Map`, but they typically contain strings, which is awkward. This method lets you get a plain-old-`Map` out of a `Properties`.
  syntax:
    content: public static ImmutableMap<String,String> fromProperties(Properties properties)
    parameters:
    - id: properties
      type: java.util.Properties
      description: a <code>Properties</code> object to be converted
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableMap<java.lang.String,java.lang.String>
      description: an immutable map containing all the entries in <code>properties</code>
references:
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.Maps*
  name: Maps
  nameWithType: Maps.Maps
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.Maps
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Map<K,? extends V>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: '? extends V'
    name: '? extends V'
    fullName: '? extends V'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.ImmutableMap<K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.ImmutableMap
    name: ImmutableMap
    fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.immutableEnumMap*
  name: <K,V>immutableEnumMap
  nameWithType: Maps.<K,V>immutableEnumMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>immutableEnumMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.function.Function<? super T,? extends K>
  spec.java:
  - uid: java.util.function.Function
    name: Function
    fullName: java.util.function.Function
  - name: <
    fullName: <
  - uid: '? super T'
    name: '? super T'
    fullName: '? super T'
  - name: ','
    fullName: ','
  - uid: '? extends K'
    name: '? extends K'
    fullName: '? extends K'
  - name: '>'
    fullName: '>'
- uid: java.util.function.Function<? super T,? extends V>
  spec.java:
  - uid: java.util.function.Function
    name: Function
    fullName: java.util.function.Function
  - name: <
    fullName: <
  - uid: '? super T'
    name: '? super T'
    fullName: '? super T'
  - name: ','
    fullName: ','
  - uid: '? extends V'
    name: '? extends V'
    fullName: '? extends V'
  - name: '>'
    fullName: '>'
- uid: java.util.stream.Collector<T,?,com.azure.cosmos.implementation.guava25.collect.ImmutableMap<K,V>>
  spec.java:
  - uid: java.util.stream.Collector
    name: Collector
    fullName: java.util.stream.Collector
  - name: <
    fullName: <
  - uid: T
    name: T
    fullName: T
  - name: ','
    fullName: ','
  - uid: '?'
    name: '?'
    fullName: '?'
  - name: ','
    fullName: ','
  - uid: com.azure.cosmos.implementation.guava25.collect.ImmutableMap
    name: ImmutableMap
    fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.toImmutableEnumMap*
  name: <T,K,V>toImmutableEnumMap
  nameWithType: Maps.<T,K,V>toImmutableEnumMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<T,K,V>toImmutableEnumMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.function.BinaryOperator<V>
  spec.java:
  - uid: java.util.function.BinaryOperator
    name: BinaryOperator
    fullName: java.util.function.BinaryOperator
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: java.util.HashMap<K,V>
  spec.java:
  - uid: java.util.HashMap
    name: HashMap
    fullName: java.util.HashMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.newHashMap*
  name: <K,V>newHashMap
  nameWithType: Maps.<K,V>newHashMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newHashMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Map<? extends K,? extends V>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: '? extends K'
    name: '? extends K'
    fullName: '? extends K'
  - name: ','
    fullName: ','
  - uid: '? extends V'
    name: '? extends V'
    fullName: '? extends V'
  - name: '>'
    fullName: '>'
- uid: int
  spec.java:
  - uid: int
    name: int
    fullName: int
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.newHashMapWithExpectedSize*
  name: <K,V>newHashMapWithExpectedSize
  nameWithType: Maps.<K,V>newHashMapWithExpectedSize
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newHashMapWithExpectedSize
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.LinkedHashMap<K,V>
  spec.java:
  - uid: java.util.LinkedHashMap
    name: LinkedHashMap
    fullName: java.util.LinkedHashMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.newLinkedHashMap*
  name: <K,V>newLinkedHashMap
  nameWithType: Maps.<K,V>newLinkedHashMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newLinkedHashMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.newLinkedHashMapWithExpectedSize*
  name: <K,V>newLinkedHashMapWithExpectedSize
  nameWithType: Maps.<K,V>newLinkedHashMapWithExpectedSize
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newLinkedHashMapWithExpectedSize
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.concurrent.ConcurrentMap<K,V>
  spec.java:
  - uid: java.util.concurrent.ConcurrentMap
    name: ConcurrentMap
    fullName: java.util.concurrent.ConcurrentMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.newConcurrentMap*
  name: <K,V>newConcurrentMap
  nameWithType: Maps.<K,V>newConcurrentMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newConcurrentMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.TreeMap<K,V>
  spec.java:
  - uid: java.util.TreeMap
    name: TreeMap
    fullName: java.util.TreeMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.newTreeMap*
  name: <K,V>newTreeMap
  nameWithType: Maps.<K,V>newTreeMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newTreeMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.SortedMap<K,? extends V>
  spec.java:
  - uid: java.util.SortedMap
    name: SortedMap
    fullName: java.util.SortedMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: '? extends V'
    name: '? extends V'
    fullName: '? extends V'
  - name: '>'
    fullName: '>'
- uid: java.util.Comparator<C>
  spec.java:
  - uid: java.util.Comparator
    name: Comparator
    fullName: java.util.Comparator
  - name: <
    fullName: <
  - uid: C
    name: C
    fullName: C
  - name: '>'
    fullName: '>'
- uid: java.lang.Class<K>
  spec.java:
  - uid: java.lang.Class
    name: Class
    fullName: java.lang.Class
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: '>'
    fullName: '>'
- uid: java.util.EnumMap<K,V>
  spec.java:
  - uid: java.util.EnumMap
    name: EnumMap
    fullName: java.util.EnumMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.newEnumMap*
  name: <K,V>newEnumMap
  nameWithType: Maps.<K,V>newEnumMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newEnumMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.IdentityHashMap<K,V>
  spec.java:
  - uid: java.util.IdentityHashMap
    name: IdentityHashMap
    fullName: java.util.IdentityHashMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.newIdentityHashMap*
  name: <K,V>newIdentityHashMap
  nameWithType: Maps.<K,V>newIdentityHashMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>newIdentityHashMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.MapDifference<K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.MapDifference
    name: MapDifference
    fullName: com.azure.cosmos.implementation.guava25.collect.MapDifference
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.difference*
  name: <K,V>difference
  nameWithType: Maps.<K,V>difference
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>difference
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.base.Equivalence<? super V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Equivalence
    name: Equivalence
    fullName: com.azure.cosmos.implementation.guava25.base.Equivalence
  - name: <
    fullName: <
  - uid: '? super V'
    name: '? super V'
    fullName: '? super V'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.SortedMapDifference<K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.SortedMapDifference
    name: SortedMapDifference
    fullName: com.azure.cosmos.implementation.guava25.collect.SortedMapDifference
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: java.util.Set<K>
  spec.java:
  - uid: java.util.Set
    name: Set
    fullName: java.util.Set
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.base.Function<? super K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Function
    name: Function
    fullName: com.azure.cosmos.implementation.guava25.base.Function
  - name: <
    fullName: <
  - uid: '? super K'
    name: '? super K'
    fullName: '? super K'
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: java.util.Map<K,V>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.asMap*
  name: <K,V>asMap
  nameWithType: Maps.<K,V>asMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>asMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.SortedSet<K>
  spec.java:
  - uid: java.util.SortedSet
    name: SortedSet
    fullName: java.util.SortedSet
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: '>'
    fullName: '>'
- uid: java.util.SortedMap<K,V>
  spec.java:
  - uid: java.util.SortedMap
    name: SortedMap
    fullName: java.util.SortedMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: java.util.NavigableSet<K>
  spec.java:
  - uid: java.util.NavigableSet
    name: NavigableSet
    fullName: java.util.NavigableSet
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: '>'
    fullName: '>'
- uid: java.util.NavigableMap<K,V>
  spec.java:
  - uid: java.util.NavigableMap
    name: NavigableMap
    fullName: java.util.NavigableMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: java.lang.Iterable<K>
  spec.java:
  - uid: java.lang.Iterable
    name: Iterable
    fullName: java.lang.Iterable
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.toMap*
  name: <K,V>toMap
  nameWithType: Maps.<K,V>toMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>toMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Iterator<K>
  spec.java:
  - uid: java.util.Iterator
    name: Iterator
    fullName: java.util.Iterator
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: '>'
    fullName: '>'
- uid: java.lang.Iterable<V>
  spec.java:
  - uid: java.lang.Iterable
    name: Iterable
    fullName: java.lang.Iterable
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.base.Function<? super V,K>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Function
    name: Function
    fullName: com.azure.cosmos.implementation.guava25.base.Function
  - name: <
    fullName: <
  - uid: '? super V'
    name: '? super V'
    fullName: '? super V'
  - name: ','
    fullName: ','
  - uid: K
    name: K
    fullName: K
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.uniqueIndex*
  name: <K,V>uniqueIndex
  nameWithType: Maps.<K,V>uniqueIndex
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>uniqueIndex
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Iterator<V>
  spec.java:
  - uid: java.util.Iterator
    name: Iterator
    fullName: java.util.Iterator
  - name: <
    fullName: <
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: java.util.Properties
  spec.java:
  - uid: java.util.Properties
    name: Properties
    fullName: java.util.Properties
- uid: com.azure.cosmos.implementation.guava25.collect.ImmutableMap<java.lang.String,java.lang.String>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.ImmutableMap
    name: ImmutableMap
    fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableMap
  - name: <
    fullName: <
  - uid: java.lang.String
    name: String
    fullName: java.lang.String
  - name: ','
    fullName: ','
  - uid: java.lang.String
    name: String
    fullName: java.lang.String
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.fromProperties*
  name: fromProperties
  nameWithType: Maps.fromProperties
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.fromProperties
  package: com.azure.cosmos.implementation.guava25.collect
- uid: K
  spec.java:
  - uid: K
    name: K
    fullName: K
- uid: V
  spec.java:
  - uid: V
    name: V
    fullName: V
- uid: java.util.Map.Entry<K,V>
  spec.java:
  - uid: java.util.Map.Entry
    name: Entry
    fullName: java.util.Map.Entry
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.immutableEntry*
  name: <K,V>immutableEntry
  nameWithType: Maps.<K,V>immutableEntry
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>immutableEntry
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.BiMap<A,B>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.BiMap
    name: BiMap
    fullName: com.azure.cosmos.implementation.guava25.collect.BiMap
  - name: <
    fullName: <
  - uid: A
    name: A
    fullName: A
  - name: ','
    fullName: ','
  - uid: B
    name: B
    fullName: B
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.base.Converter<A,B>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Converter
    name: Converter
    fullName: com.azure.cosmos.implementation.guava25.base.Converter
  - name: <
    fullName: <
  - uid: A
    name: A
    fullName: A
  - name: ','
    fullName: ','
  - uid: B
    name: B
    fullName: B
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.asConverter*
  name: <A,B>asConverter
  nameWithType: Maps.<A,B>asConverter
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<A,B>asConverter
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.BiMap<K,V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.BiMap
    name: BiMap
    fullName: com.azure.cosmos.implementation.guava25.collect.BiMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.synchronizedBiMap*
  name: <K,V>synchronizedBiMap
  nameWithType: Maps.<K,V>synchronizedBiMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>synchronizedBiMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.BiMap<? extends K,? extends V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.BiMap
    name: BiMap
    fullName: com.azure.cosmos.implementation.guava25.collect.BiMap
  - name: <
    fullName: <
  - uid: '? extends K'
    name: '? extends K'
    fullName: '? extends K'
  - name: ','
    fullName: ','
  - uid: '? extends V'
    name: '? extends V'
    fullName: '? extends V'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.unmodifiableBiMap*
  name: <K,V>unmodifiableBiMap
  nameWithType: Maps.<K,V>unmodifiableBiMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>unmodifiableBiMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Map<K,V1>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V1
    name: V1
    fullName: V1
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.base.Function<? super V1,V2>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Function
    name: Function
    fullName: com.azure.cosmos.implementation.guava25.base.Function
  - name: <
    fullName: <
  - uid: '? super V1'
    name: '? super V1'
    fullName: '? super V1'
  - name: ','
    fullName: ','
  - uid: V2
    name: V2
    fullName: V2
  - name: '>'
    fullName: '>'
- uid: java.util.Map<K,V2>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V2
    name: V2
    fullName: V2
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.transformValues*
  name: <K,V1,V2>transformValues
  nameWithType: Maps.<K,V1,V2>transformValues
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformValues
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.SortedMap<K,V1>
  spec.java:
  - uid: java.util.SortedMap
    name: SortedMap
    fullName: java.util.SortedMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V1
    name: V1
    fullName: V1
  - name: '>'
    fullName: '>'
- uid: java.util.SortedMap<K,V2>
  spec.java:
  - uid: java.util.SortedMap
    name: SortedMap
    fullName: java.util.SortedMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V2
    name: V2
    fullName: V2
  - name: '>'
    fullName: '>'
- uid: java.util.NavigableMap<K,V1>
  spec.java:
  - uid: java.util.NavigableMap
    name: NavigableMap
    fullName: java.util.NavigableMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V1
    name: V1
    fullName: V1
  - name: '>'
    fullName: '>'
- uid: java.util.NavigableMap<K,V2>
  spec.java:
  - uid: java.util.NavigableMap
    name: NavigableMap
    fullName: java.util.NavigableMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V2
    name: V2
    fullName: V2
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer
    name: EntryTransformer
    fullName: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer
  - name: <
    fullName: <
  - uid: '? super K'
    name: '? super K'
    fullName: '? super K'
  - name: ','
    fullName: ','
  - uid: '? super V1'
    name: '? super V1'
    fullName: '? super V1'
  - name: ','
    fullName: ','
  - uid: V2
    name: V2
    fullName: V2
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.transformEntries*
  name: <K,V1,V2>transformEntries
  nameWithType: Maps.<K,V1,V2>transformEntries
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.base.Predicate<? super K>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Predicate
    name: Predicate
    fullName: com.azure.cosmos.implementation.guava25.base.Predicate
  - name: <
    fullName: <
  - uid: '? super K'
    name: '? super K'
    fullName: '? super K'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.filterKeys*
  name: <K,V>filterKeys
  nameWithType: Maps.<K,V>filterKeys
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterKeys
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.base.Predicate<? super V>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Predicate
    name: Predicate
    fullName: com.azure.cosmos.implementation.guava25.base.Predicate
  - name: <
    fullName: <
  - uid: '? super V'
    name: '? super V'
    fullName: '? super V'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.filterValues*
  name: <K,V>filterValues
  nameWithType: Maps.<K,V>filterValues
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterValues
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.base.Predicate<? super java.util.Map.Entry<K,V>>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Predicate
    name: Predicate
    fullName: com.azure.cosmos.implementation.guava25.base.Predicate
  - name: <
    fullName: <
  - uid: '? super java.util.Map.Entry'
    name: Entry
    fullName: '? super java.util.Map.Entry'
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: V
    name: V
    fullName: V
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.filterEntries*
  name: <K,V>filterEntries
  nameWithType: Maps.<K,V>filterEntries
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>filterEntries
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.NavigableMap<K,? extends V>
  spec.java:
  - uid: java.util.NavigableMap
    name: NavigableMap
    fullName: java.util.NavigableMap
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: ','
    fullName: ','
  - uid: '? extends V'
    name: '? extends V'
    fullName: '? extends V'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.unmodifiableNavigableMap*
  name: <K,V>unmodifiableNavigableMap
  nameWithType: Maps.<K,V>unmodifiableNavigableMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>unmodifiableNavigableMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.synchronizedNavigableMap*
  name: <K,V>synchronizedNavigableMap
  nameWithType: Maps.<K,V>synchronizedNavigableMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>synchronizedNavigableMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Range<K>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.Range
    name: Range
    fullName: com.azure.cosmos.implementation.guava25.collect.Range
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.subMap*
  name: <K,V>subMap
  nameWithType: Maps.<K,V>subMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.<K,V>subMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.lang.Object.notify()
  name: Object.notify()
  nameWithType: Object.notify()
  fullName: java.lang.Object.notify()
- uid: java.lang.Object.wait()
  name: Object.wait()
  nameWithType: Object.wait()
  fullName: java.lang.Object.wait()
- uid: java.lang.Object.finalize()
  name: Object.finalize()
  nameWithType: Object.finalize()
  fullName: java.lang.Object.finalize()
- uid: java.lang.Object.clone()
  name: Object.clone()
  nameWithType: Object.clone()
  fullName: java.lang.Object.clone()
- uid: java.lang.Object.notifyAll()
  name: Object.notifyAll()
  nameWithType: Object.notifyAll()
  fullName: java.lang.Object.notifyAll()
- uid: java.lang.Object.equals(java.lang.Object)
  name: Object.equals(Object)
  nameWithType: Object.equals(Object)
  fullName: java.lang.Object.equals(java.lang.Object)
- uid: java.lang.Object.getClass()
  name: Object.getClass()
  nameWithType: Object.getClass()
  fullName: java.lang.Object.getClass()
- uid: java.lang.Object.wait(long)
  name: Object.wait(long)
  nameWithType: Object.wait(long)
  fullName: java.lang.Object.wait(long)
- uid: java.lang.Object.hashCode()
  name: Object.hashCode()
  nameWithType: Object.hashCode()
  fullName: java.lang.Object.hashCode()
- uid: java.lang.Object.wait(long,int)
  name: Object.wait(long,int)
  nameWithType: Object.wait(long,int)
  fullName: java.lang.Object.wait(long,int)
- uid: java.lang.Object.toString()
  name: Object.toString()
  nameWithType: Object.toString()
  fullName: java.lang.Object.toString()
- uid: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer
  name: Maps.EntryTransformer<K,V1,V2>
  nameWithType: Maps.EntryTransformer<K,V1,V2>
  fullName: com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<K,V1,V2>
- uid: java.util.Map
  name: Map
  nameWithType: Map
  fullName: java.util.Map
- uid: K,? extends V
  name: K,? extends V
  nameWithType: K,? extends V
  fullName: K,? extends V
- uid: com.azure.cosmos.implementation.guava25.collect.ImmutableMap
  name: ImmutableMap
  nameWithType: ImmutableMap
  fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableMap
- uid: K,V
  name: K,V
  nameWithType: K,V
  fullName: K,V
- uid: '? super T,? extends K'
  name: '? super T,? extends K'
  nameWithType: '? super T,? extends K'
  fullName: '? super T,? extends K'
- uid: java.util.function.Function
  name: Function
  nameWithType: Function
  fullName: java.util.function.Function
- uid: '? super T,? extends V'
  name: '? super T,? extends V'
  nameWithType: '? super T,? extends V'
  fullName: '? super T,? extends V'
- uid: T,?,com.azure.cosmos.implementation.guava25.collect.ImmutableMap
  name: T,?,ImmutableMap
  nameWithType: T,?,ImmutableMap
  fullName: T,?,com.azure.cosmos.implementation.guava25.collect.ImmutableMap
- uid: java.util.stream.Collector
  name: Collector
  nameWithType: Collector
  fullName: java.util.stream.Collector
- uid: java.util.function.BinaryOperator
  name: BinaryOperator
  nameWithType: BinaryOperator
  fullName: java.util.function.BinaryOperator
- uid: java.util.HashMap
  name: HashMap
  nameWithType: HashMap
  fullName: java.util.HashMap
- uid: '? extends K,? extends V'
  name: '? extends K,? extends V'
  nameWithType: '? extends K,? extends V'
  fullName: '? extends K,? extends V'
- uid: java.util.LinkedHashMap
  name: LinkedHashMap
  nameWithType: LinkedHashMap
  fullName: java.util.LinkedHashMap
- uid: java.util.concurrent.ConcurrentMap
  name: ConcurrentMap
  nameWithType: ConcurrentMap
  fullName: java.util.concurrent.ConcurrentMap
- uid: java.util.TreeMap
  name: TreeMap
  nameWithType: TreeMap
  fullName: java.util.TreeMap
- uid: java.util.SortedMap
  name: SortedMap
  nameWithType: SortedMap
  fullName: java.util.SortedMap
- uid: C
  name: C
  nameWithType: C
  fullName: C
- uid: java.util.Comparator
  name: Comparator
  nameWithType: Comparator
  fullName: java.util.Comparator
- uid: java.lang.Class
  name: Class
  nameWithType: Class
  fullName: java.lang.Class
- uid: java.util.EnumMap
  name: EnumMap
  nameWithType: EnumMap
  fullName: java.util.EnumMap
- uid: java.util.IdentityHashMap
  name: IdentityHashMap
  nameWithType: IdentityHashMap
  fullName: java.util.IdentityHashMap
- uid: com.azure.cosmos.implementation.guava25.collect.MapDifference
  name: MapDifference
  nameWithType: MapDifference
  fullName: com.azure.cosmos.implementation.guava25.collect.MapDifference
- uid: com.azure.cosmos.implementation.guava25.base.Equivalence
  name: Equivalence
  nameWithType: Equivalence
  fullName: com.azure.cosmos.implementation.guava25.base.Equivalence
- uid: '? super V'
  name: '? super V'
  nameWithType: '? super V'
  fullName: '? super V'
- uid: com.azure.cosmos.implementation.guava25.collect.SortedMapDifference
  name: SortedMapDifference
  nameWithType: SortedMapDifference
  fullName: com.azure.cosmos.implementation.guava25.collect.SortedMapDifference
- uid: java.util.Set
  name: Set
  nameWithType: Set
  fullName: java.util.Set
- uid: com.azure.cosmos.implementation.guava25.base.Function
  name: Function
  nameWithType: Function
  fullName: com.azure.cosmos.implementation.guava25.base.Function
- uid: '? super K,V'
  name: '? super K,V'
  nameWithType: '? super K,V'
  fullName: '? super K,V'
- uid: java.util.SortedSet
  name: SortedSet
  nameWithType: SortedSet
  fullName: java.util.SortedSet
- uid: java.util.NavigableSet
  name: NavigableSet
  nameWithType: NavigableSet
  fullName: java.util.NavigableSet
- uid: java.util.NavigableMap
  name: NavigableMap
  nameWithType: NavigableMap
  fullName: java.util.NavigableMap
- uid: java.lang.Iterable
  name: Iterable
  nameWithType: Iterable
  fullName: java.lang.Iterable
- uid: java.util.Iterator
  name: Iterator
  nameWithType: Iterator
  fullName: java.util.Iterator
- uid: '? super V,K'
  name: '? super V,K'
  nameWithType: '? super V,K'
  fullName: '? super V,K'
- uid: java.lang.String,java.lang.String
  name: String,String
  nameWithType: String,String
  fullName: java.lang.String,java.lang.String
- uid: java.util.Map.Entry
  name: Map.Entry
  nameWithType: Map.Entry
  fullName: java.util.Map.Entry
- uid: A,B
  name: A,B
  nameWithType: A,B
  fullName: A,B
- uid: com.azure.cosmos.implementation.guava25.collect.BiMap
  name: BiMap
  nameWithType: BiMap
  fullName: com.azure.cosmos.implementation.guava25.collect.BiMap
- uid: com.azure.cosmos.implementation.guava25.base.Converter
  name: Converter
  nameWithType: Converter
  fullName: com.azure.cosmos.implementation.guava25.base.Converter
- uid: K,V1
  name: K,V1
  nameWithType: K,V1
  fullName: K,V1
- uid: '? super V1,V2'
  name: '? super V1,V2'
  nameWithType: '? super V1,V2'
  fullName: '? super V1,V2'
- uid: K,V2
  name: K,V2
  nameWithType: K,V2
  fullName: K,V2
- uid: '? super K,? super V1,V2'
  name: '? super K,? super V1,V2'
  nameWithType: '? super K,? super V1,V2'
  fullName: '? super K,? super V1,V2'
- uid: com.azure.cosmos.implementation.guava25.base.Predicate
  name: Predicate
  nameWithType: Predicate
  fullName: com.azure.cosmos.implementation.guava25.base.Predicate
- uid: '? super K'
  name: '? super K'
  nameWithType: '? super K'
  fullName: '? super K'
- uid: '? super java.util.Map.Entry'
  name: '? super Map.Entry'
  nameWithType: '? super Map.Entry'
  fullName: '? super java.util.Map.Entry'
- uid: com.azure.cosmos.implementation.guava25.collect.Range
  name: Range
  nameWithType: Range
  fullName: com.azure.cosmos.implementation.guava25.collect.Range
