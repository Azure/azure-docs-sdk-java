### YamlMime:JavaType
uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
name: "ServiceBusReceiverAsyncClient"
nameWithType: "ServiceBusReceiverAsyncClient"
summary: "An **asynchronous** receiver responsible for receiving <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"messages\"></xref> from a specific queue or topic subscription.\n\n**Create an instance of receiver**\n\n```java\n// The required parameters is connectionString, a way to authenticate with Service Bus using credentials.\n ServiceBusReceiverAsyncClient consumer = new ServiceBusClientBuilder()\n     .connectionString(\n         \"Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};SharedAccessKey={key}\")\n     .receiver()\n     .queueName(\"<< QUEUE NAME >>\")\n     .buildAsyncClient();\n```\n\n**Create an instance of receiver using default credential**\n\n```java\n// The required parameters is connectionString, a way to authenticate with Service Bus using credentials.\n ServiceBusReceiverAsyncClient receiver = new ServiceBusClientBuilder()\n     .credential(\"<<fully-qualified-namespace>>\",\n         new DefaultAzureCredentialBuilder().build())\n     .receiver()\n     .queueName(\"<< QUEUE NAME >>\")\n     .buildAsyncClient();\n```\n\n**Receive all messages from Service Bus resource**\n\nThis returns an infinite stream of messages from Service Bus. The stream ends when the subscription is disposed or other terminal scenarios. See <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveMessages()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#receiveMessages()\"></xref> for more information.\n\n```java\nDisposable subscription = receiver.receiveMessages()\n     .subscribe(message -> {\n         System.out.printf(\"Received Seq #: %s%n\", message.getSequenceNumber());\n         System.out.printf(\"Contents of message as string: %s%n\", message.getBody());\n     },\n         error -> System.out.println(\"Error occurred: \" + error),\n         () -> System.out.println(\"Receiving complete.\"));\n \n // When program ends, or you're done receiving all messages.\n subscription.dispose();\n receiver.close();\n```\n\n**Receive messages in <xref uid=\"com.azure.messaging.servicebus.models.ServiceBusReceiveMode.RECEIVE_AND_DELETE\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiveMode#RECEIVE_AND_DELETE\"></xref> mode from a Service Bus entity**\n\n```java\n// Keep a reference to `subscription`. When the program is finished receiving messages, call\n // subscription.dispose(). This will stop fetching messages from the Service Bus.\n Disposable subscription = receiver.receiveMessages()\n     .subscribe(message -> {\n         System.out.printf(\"Received Seq #: %s%n\", message.getSequenceNumber());\n         System.out.printf(\"Contents of message as string: %s%n\", message.getBody().toString());\n     }, error -> System.err.print(error));\n```\n\n**Receive messages from a specific session**\n\nTo fetch messages from a specific session, switch to <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusSessionReceiverClientBuilder\"></xref> and build the session receiver client. Use <xref uid=\"com.azure.messaging.servicebus.ServiceBusSessionReceiverAsyncClient.acceptSession(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusSessionReceiverAsyncClient#acceptSession(String)\"></xref> to create a session-bound <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiverAsyncClient\"></xref>.\n\n```java\nServiceBusSessionReceiverAsyncClient sessionReceiver = new ServiceBusClientBuilder()\n     .connectionString(\"Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};\"\n         + \"SharedAccessKey={key}\")\n     .sessionReceiver()\n     .queueName(\"<< QUEUE NAME >>\")\n     .buildAsyncClient();\n \n // acceptSession(String) completes successfully with a receiver when \"<< my-session-id >>\" session is\n // successfully locked.\n // `Flux.usingWhen` is used so we dispose of the receiver resource after `receiveMessages()` completes.\n // `Mono.usingWhen` can also be used if the resource closure only returns a single item.\n Flux<ServiceBusReceivedMessage> sessionMessages = Flux.usingWhen(\n     sessionReceiver.acceptSession(\"<< my-session-id >>\"),\n     receiver -> receiver.receiveMessages(),\n     receiver -> Mono.fromRunnable(() -> receiver.close()));\n \n // When program ends, or you're done receiving all messages, the `subscription` can be disposed of. This code\n // is non-blocking and kicks off the operation.\n Disposable subscription = sessionMessages.subscribe(\n     message -> System.out.printf(\"Received Sequence #: %s. Contents: %s%n\",\n         message.getSequenceNumber(), message.getBody()),\n     error -> System.err.print(error));\n```\n\n**Receive messages from the first available session**\n\nTo process messages from the first available session, switch to <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusSessionReceiverClientBuilder\"></xref> and build the session receiver client. Use <xref uid=\"com.azure.messaging.servicebus.ServiceBusSessionReceiverAsyncClient.acceptNextSession()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"acceptNextSession()\"></xref> to find the first available session to process messages from.\n\n```java\nServiceBusSessionReceiverAsyncClient sessionReceiver = new ServiceBusClientBuilder()\n     .connectionString(\"Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};\"\n         + \"SharedAccessKey={key}\")\n     .sessionReceiver()\n     .queueName(\"<< QUEUE NAME >>\")\n     .buildAsyncClient();\n \n // acceptNextSession() completes successfully with a receiver when it acquires the next available session.\n // `Flux.usingWhen` is used so we dispose of the receiver resource after `receiveMessages()` completes.\n // `Mono.usingWhen` can also be used if the resource closure only returns a single item.\n Flux<ServiceBusReceivedMessage> sessionMessages = Flux.usingWhen(\n     sessionReceiver.acceptNextSession(),\n     receiver -> receiver.receiveMessages(),\n     receiver -> Mono.fromRunnable(() -> receiver.close()));\n \n // When program ends, or you're done receiving all messages, the `subscription` can be disposed of. This code\n // is non-blocking and kicks off the operation.\n Disposable subscription = sessionMessages.subscribe(\n     message -> System.out.printf(\"Received Sequence #: %s. Contents: %s%n\",\n         message.getSequenceNumber(), message.getBody()),\n     error -> System.err.print(error));\n```\n\n**Rate limiting consumption of messages from a Service Bus entity**\n\nFor message receivers that need to limit the number of messages they receive at a given time, they can use <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BaseSubscriber#request(long)\"></xref>.\n\n```java\nreceiver.receiveMessages().subscribe(new BaseSubscriber<ServiceBusReceivedMessage>() {\n     private static final int NUMBER_OF_MESSAGES = 5;\n     private final AtomicInteger currentNumberOfMessages = new AtomicInteger();\n \n     {@literal @}Override\n     protected void hookOnSubscribe(Subscription subscription) {\n         // Tell the Publisher we only want 5 message at a time.\n         request(NUMBER_OF_MESSAGES);\n     }\n \n     {@literal @}Override\n     protected void hookOnNext(ServiceBusReceivedMessage message) {\n         // Process the ServiceBusReceivedMessage\n         // If the number of messages we have currently received is a multiple of 5, that means we have reached\n         // the last message the Subscriber will provide to us. Invoking request(long) here, tells the Publisher\n         // that the subscriber is ready to get more messages from upstream.\n         if (currentNumberOfMessages.incrementAndGet() % 5 == 0) {\n             request(NUMBER_OF_MESSAGES);\n         }\n     }\n });\n```"
inheritances:
- "<xref href=\"java.lang.Object\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
syntax: "public final class ServiceBusReceiverAsyncClient implements AutoCloseable"
methods:
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.models.AbandonOptions)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.close()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.commitTransaction(com.azure.messaging.servicebus.ServiceBusTransactionContext)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.models.CompleteOptions)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.createTransaction()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.models.DeadLetterOptions)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.models.DeferOptions)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getEntityPath()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getSessionState()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessage()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessage(long)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessages(int)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessages(int,long)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessage(long)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessages(java.lang.Iterable<java.lang.Long>)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveMessages()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(com.azure.messaging.servicebus.ServiceBusReceivedMessage,java.time.Duration)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewSessionLock()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewSessionLock(java.time.Duration)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.rollbackTransaction(com.azure.messaging.servicebus.ServiceBusTransactionContext)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.setSessionState(byte[])"
type: "class"
implements:
- "<xref href=\"java.lang.AutoCloseable?alt=java.lang.AutoCloseable&text=AutoCloseable\" data-throw-if-not-resolved=\"False\" />"
metadata: {}
package: "com.azure.messaging.servicebus"
artifact: com.azure:azure-messaging-servicebus:7.0.1
