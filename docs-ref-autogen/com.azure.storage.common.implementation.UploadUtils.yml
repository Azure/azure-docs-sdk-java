### YamlMime:ManagedReference
items:
- uid: "com.azure.storage.common.implementation.UploadUtils"
  id: "UploadUtils"
  parent: "com.azure.storage.common.implementation"
  children:
  - "com.azure.storage.common.implementation.UploadUtils.<T>uploadFullOrChunked(reactor.core.publisher.Flux<java.nio.ByteBuffer>,com.azure.storage.common.ParallelTransferOptions,java.util.function.Function<reactor.core.publisher.Flux<java.nio.ByteBuffer>,reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>>,java.util.function.BiFunction<reactor.core.publisher.Flux<java.nio.ByteBuffer>,java.lang.Long,reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>>)"
  - "com.azure.storage.common.implementation.UploadUtils.UploadUtils()"
  - "com.azure.storage.common.implementation.UploadUtils.chunkSource(reactor.core.publisher.Flux<java.nio.ByteBuffer>,com.azure.storage.common.ParallelTransferOptions)"
  - "com.azure.storage.common.implementation.UploadUtils.shouldUploadInChunks(java.lang.String,java.lang.Integer,com.azure.core.util.logging.ClientLogger)"
  - "com.azure.storage.common.implementation.UploadUtils.uploadFileCleanup(java.nio.channels.AsynchronousFileChannel,com.azure.core.util.logging.ClientLogger)"
  - "com.azure.storage.common.implementation.UploadUtils.uploadFileResourceSupplier(java.lang.String,com.azure.core.util.logging.ClientLogger)"
  langs:
  - "java"
  name: "UploadUtils"
  nameWithType: "UploadUtils"
  fullName: "com.azure.storage.common.implementation.UploadUtils"
  type: "Class"
  package: "com.azure.storage.common.implementation"
  summary: "This class provides helper methods for buffered upload. RESERVED FOR INTERNAL USE."
  syntax:
    content: "public class UploadUtils"
  inheritance:
  - "java.lang.Object"
  inheritedMembers:
  - "java.lang.Object.clone()"
  - "java.lang.Object.equals(java.lang.Object)"
  - "java.lang.Object.finalize()"
  - "java.lang.Object.getClass()"
  - "java.lang.Object.hashCode()"
  - "java.lang.Object.notify()"
  - "java.lang.Object.notifyAll()"
  - "java.lang.Object.toString()"
  - "java.lang.Object.wait()"
  - "java.lang.Object.wait(long)"
  - "java.lang.Object.wait(long,int)"
- uid: "com.azure.storage.common.implementation.UploadUtils.<T>uploadFullOrChunked(reactor.core.publisher.Flux<java.nio.ByteBuffer>,com.azure.storage.common.ParallelTransferOptions,java.util.function.Function<reactor.core.publisher.Flux<java.nio.ByteBuffer>,reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>>,java.util.function.BiFunction<reactor.core.publisher.Flux<java.nio.ByteBuffer>,java.lang.Long,reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>>)"
  id: "<T>uploadFullOrChunked(reactor.core.publisher.Flux<java.nio.ByteBuffer>,com.azure.storage.common.ParallelTransferOptions,java.util.function.Function<reactor.core.publisher.Flux<java.nio.ByteBuffer>,reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>>,java.util.function.BiFunction<reactor.core.publisher.Flux<java.nio.ByteBuffer>,java.lang.Long,reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>>)"
  parent: "com.azure.storage.common.implementation.UploadUtils"
  langs:
  - "java"
  name: "<T>uploadFullOrChunked(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, Function<Flux<ByteBuffer>,Mono<Response<T>>> uploadInChunks, BiFunction<Flux<ByteBuffer>,Long,Mono<Response<T>>> uploadFull)"
  nameWithType: "UploadUtils.<T>uploadFullOrChunked(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, Function<Flux<ByteBuffer>,Mono<Response<T>>> uploadInChunks, BiFunction<Flux<ByteBuffer>,Long,Mono<Response<T>>> uploadFull)"
  fullName: "com.azure.storage.common.implementation.UploadUtils.<T>uploadFullOrChunked(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, Function<Flux<ByteBuffer>,Mono<Response<T>>> uploadInChunks, BiFunction<Flux<ByteBuffer>,Long,Mono<Response<T>>> uploadFull)"
  overload: "com.azure.storage.common.implementation.UploadUtils.uploadFullOrChunked*"
  type: "Method"
  package: "com.azure.storage.common.implementation"
  summary: "Determines whether the upload should happen in full or chunked."
  syntax:
    content: "public static Mono<Response<T>> <T>uploadFullOrChunked(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, Function<Flux<ByteBuffer>,Mono<Response<T>>> uploadInChunks, BiFunction<Flux<ByteBuffer>,Long,Mono<Response<T>>> uploadFull)"
    parameters:
    - id: "data"
      type: "reactor.core.publisher.Flux<java.nio.ByteBuffer>"
      description: "The data to write"
    - id: "parallelTransferOptions"
      type: "com.azure.storage.common.ParallelTransferOptions"
      description: "<xref uid=\"com.azure.storage.common.ParallelTransferOptions\" data-throw-if-not-resolved=\"false\">ParallelTransferOptions</xref>"
    - id: "uploadInChunks"
      type: "java.util.function.Function<reactor.core.publisher.Flux<java.nio.ByteBuffer>,reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>>"
      description: "<xref uid=\"java.util.function.Function\" data-throw-if-not-resolved=\"false\">Function</xref> to upload in chunks."
    - id: "uploadFull"
      type: "java.util.function.BiFunction<reactor.core.publisher.Flux<java.nio.ByteBuffer>,java.lang.Long,reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>>"
      description: "<xref uid=\"java.util.function.BiFunction\" data-throw-if-not-resolved=\"false\">BiFunction</xref> to upload in full."
    return:
      type: "reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>"
      description: "A reactive response containing the information of the uploaded data."
- uid: "com.azure.storage.common.implementation.UploadUtils.UploadUtils()"
  id: "UploadUtils()"
  parent: "com.azure.storage.common.implementation.UploadUtils"
  langs:
  - "java"
  name: "UploadUtils()"
  nameWithType: "UploadUtils.UploadUtils()"
  fullName: "com.azure.storage.common.implementation.UploadUtils.UploadUtils()"
  overload: "com.azure.storage.common.implementation.UploadUtils.UploadUtils*"
  type: "Constructor"
  package: "com.azure.storage.common.implementation"
  syntax:
    content: "public UploadUtils()"
- uid: "com.azure.storage.common.implementation.UploadUtils.chunkSource(reactor.core.publisher.Flux<java.nio.ByteBuffer>,com.azure.storage.common.ParallelTransferOptions)"
  id: "chunkSource(reactor.core.publisher.Flux<java.nio.ByteBuffer>,com.azure.storage.common.ParallelTransferOptions)"
  parent: "com.azure.storage.common.implementation.UploadUtils"
  langs:
  - "java"
  name: "chunkSource(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions)"
  nameWithType: "UploadUtils.chunkSource(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions)"
  fullName: "com.azure.storage.common.implementation.UploadUtils.chunkSource(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions)"
  overload: "com.azure.storage.common.implementation.UploadUtils.chunkSource*"
  type: "Method"
  package: "com.azure.storage.common.implementation"
  summary: "Break the source Flux into chunks that are <= chunk size. This makes filling the pooled buffers much easier as we can guarantee we only need at most two buffers for any call to write (two in the case of one pool buffer filling up with more data to write). We use flatMapSequential because we need to guarantee we preserve the ordering of the buffers, but we don't really care if one is split before another."
  syntax:
    content: "public static Flux<ByteBuffer> chunkSource(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions)"
    parameters:
    - id: "data"
      type: "reactor.core.publisher.Flux<java.nio.ByteBuffer>"
      description: "Data to chunk"
    - id: "parallelTransferOptions"
      type: "com.azure.storage.common.ParallelTransferOptions"
      description: "<xref uid=\"com.azure.storage.common.ParallelTransferOptions\" data-throw-if-not-resolved=\"false\">ParallelTransferOptions</xref>"
    return:
      type: "reactor.core.publisher.Flux<java.nio.ByteBuffer>"
      description: "Chunked data"
- uid: "com.azure.storage.common.implementation.UploadUtils.shouldUploadInChunks(java.lang.String,java.lang.Integer,com.azure.core.util.logging.ClientLogger)"
  id: "shouldUploadInChunks(java.lang.String,java.lang.Integer,com.azure.core.util.logging.ClientLogger)"
  parent: "com.azure.storage.common.implementation.UploadUtils"
  langs:
  - "java"
  name: "shouldUploadInChunks(String filePath, Integer maxSingleUploadSize, ClientLogger logger)"
  nameWithType: "UploadUtils.shouldUploadInChunks(String filePath, Integer maxSingleUploadSize, ClientLogger logger)"
  fullName: "com.azure.storage.common.implementation.UploadUtils.shouldUploadInChunks(String filePath, Integer maxSingleUploadSize, ClientLogger logger)"
  overload: "com.azure.storage.common.implementation.UploadUtils.shouldUploadInChunks*"
  type: "Method"
  package: "com.azure.storage.common.implementation"
  syntax:
    content: "public static boolean shouldUploadInChunks(String filePath, Integer maxSingleUploadSize, ClientLogger logger)"
    parameters:
    - id: "filePath"
      type: "java.lang.String"
    - id: "maxSingleUploadSize"
      type: "java.lang.Integer"
    - id: "logger"
      type: "com.azure.core.util.logging.ClientLogger"
    return:
      type: "boolean"
- uid: "com.azure.storage.common.implementation.UploadUtils.uploadFileCleanup(java.nio.channels.AsynchronousFileChannel,com.azure.core.util.logging.ClientLogger)"
  id: "uploadFileCleanup(java.nio.channels.AsynchronousFileChannel,com.azure.core.util.logging.ClientLogger)"
  parent: "com.azure.storage.common.implementation.UploadUtils"
  langs:
  - "java"
  name: "uploadFileCleanup(AsynchronousFileChannel channel, ClientLogger logger)"
  nameWithType: "UploadUtils.uploadFileCleanup(AsynchronousFileChannel channel, ClientLogger logger)"
  fullName: "com.azure.storage.common.implementation.UploadUtils.uploadFileCleanup(AsynchronousFileChannel channel, ClientLogger logger)"
  overload: "com.azure.storage.common.implementation.UploadUtils.uploadFileCleanup*"
  type: "Method"
  package: "com.azure.storage.common.implementation"
  syntax:
    content: "public static void uploadFileCleanup(AsynchronousFileChannel channel, ClientLogger logger)"
    parameters:
    - id: "channel"
      type: "java.nio.channels.AsynchronousFileChannel"
    - id: "logger"
      type: "com.azure.core.util.logging.ClientLogger"
- uid: "com.azure.storage.common.implementation.UploadUtils.uploadFileResourceSupplier(java.lang.String,com.azure.core.util.logging.ClientLogger)"
  id: "uploadFileResourceSupplier(java.lang.String,com.azure.core.util.logging.ClientLogger)"
  parent: "com.azure.storage.common.implementation.UploadUtils"
  langs:
  - "java"
  name: "uploadFileResourceSupplier(String filePath, ClientLogger logger)"
  nameWithType: "UploadUtils.uploadFileResourceSupplier(String filePath, ClientLogger logger)"
  fullName: "com.azure.storage.common.implementation.UploadUtils.uploadFileResourceSupplier(String filePath, ClientLogger logger)"
  overload: "com.azure.storage.common.implementation.UploadUtils.uploadFileResourceSupplier*"
  type: "Method"
  package: "com.azure.storage.common.implementation"
  summary: "RESERVED FOR INTERNAL USE. Resource Supplier for UploadFile."
  syntax:
    content: "public static AsynchronousFileChannel uploadFileResourceSupplier(String filePath, ClientLogger logger)"
    parameters:
    - id: "filePath"
      type: "java.lang.String"
      description: "The path for the file"
    - id: "logger"
      type: "com.azure.core.util.logging.ClientLogger"
    return:
      type: "java.nio.channels.AsynchronousFileChannel"
      description: "<code>AsynchronousFileChannel</code>"
references:
- uid: "com.azure.storage.common.implementation.UploadUtils.UploadUtils*"
  name: "UploadUtils"
  nameWithType: "UploadUtils.UploadUtils"
  fullName: "com.azure.storage.common.implementation.UploadUtils.UploadUtils"
  package: "com.azure.storage.common.implementation"
- uid: "reactor.core.publisher.Flux<java.nio.ByteBuffer>"
  spec.java:
  - uid: "reactor.core.publisher.Flux"
    name: "Flux"
    fullName: "reactor.core.publisher.Flux"
  - name: "<"
    fullName: "<"
  - uid: "java.nio.ByteBuffer"
    name: "ByteBuffer"
    fullName: "java.nio.ByteBuffer"
  - name: ">"
    fullName: ">"
- uid: "com.azure.storage.common.ParallelTransferOptions"
  name: "ParallelTransferOptions"
  nameWithType: "ParallelTransferOptions"
  fullName: "com.azure.storage.common.ParallelTransferOptions"
- uid: "java.util.function.Function<reactor.core.publisher.Flux<java.nio.ByteBuffer>,reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>>"
  spec.java:
  - uid: "java.util.function.Function"
    name: "Function"
    fullName: "java.util.function.Function"
  - name: "<"
    fullName: "<"
  - uid: "reactor.core.publisher.Flux"
    name: "Flux"
    fullName: "reactor.core.publisher.Flux"
  - name: "<"
    fullName: "<"
  - uid: "java.nio.ByteBuffer"
    name: "ByteBuffer"
    fullName: "java.nio.ByteBuffer"
  - name: ">"
    fullName: ">"
  - name: ","
    fullName: ","
  - uid: "reactor.core.publisher.Mono"
    name: "Mono"
    fullName: "reactor.core.publisher.Mono"
  - name: "<"
    fullName: "<"
  - uid: "com.azure.core.http.rest.Response"
    name: "Response"
    fullName: "com.azure.core.http.rest.Response"
  - name: "<"
    fullName: "<"
  - uid: "T"
    name: "T"
    fullName: "T"
  - name: ">"
    fullName: ">"
  - name: ">"
    fullName: ">"
  - name: ">"
    fullName: ">"
- uid: "java.util.function.BiFunction<reactor.core.publisher.Flux<java.nio.ByteBuffer>,java.lang.Long,reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>>"
  spec.java:
  - uid: "java.util.function.BiFunction"
    name: "BiFunction"
    fullName: "java.util.function.BiFunction"
  - name: "<"
    fullName: "<"
  - uid: "reactor.core.publisher.Flux"
    name: "Flux"
    fullName: "reactor.core.publisher.Flux"
  - name: "<"
    fullName: "<"
  - uid: "java.nio.ByteBuffer"
    name: "ByteBuffer"
    fullName: "java.nio.ByteBuffer"
  - name: ">"
    fullName: ">"
  - name: ","
    fullName: ","
  - uid: "java.lang.Long"
    name: "Long"
    fullName: "java.lang.Long"
  - name: ","
    fullName: ","
  - uid: "reactor.core.publisher.Mono"
    name: "Mono"
    fullName: "reactor.core.publisher.Mono"
  - name: "<"
    fullName: "<"
  - uid: "com.azure.core.http.rest.Response"
    name: "Response"
    fullName: "com.azure.core.http.rest.Response"
  - name: "<"
    fullName: "<"
  - uid: "T"
    name: "T"
    fullName: "T"
  - name: ">"
    fullName: ">"
  - name: ">"
    fullName: ">"
  - name: ">"
    fullName: ">"
- uid: "reactor.core.publisher.Mono<com.azure.core.http.rest.Response<T>>"
  spec.java:
  - uid: "reactor.core.publisher.Mono"
    name: "Mono"
    fullName: "reactor.core.publisher.Mono"
  - name: "<"
    fullName: "<"
  - uid: "com.azure.core.http.rest.Response"
    name: "Response"
    fullName: "com.azure.core.http.rest.Response"
  - name: "<"
    fullName: "<"
  - uid: "T"
    name: "T"
    fullName: "T"
  - name: ">"
    fullName: ">"
  - name: ">"
    fullName: ">"
- uid: "com.azure.storage.common.implementation.UploadUtils.uploadFullOrChunked*"
  name: "<T>uploadFullOrChunked"
  nameWithType: "UploadUtils.<T>uploadFullOrChunked"
  fullName: "com.azure.storage.common.implementation.UploadUtils.<T>uploadFullOrChunked"
  package: "com.azure.storage.common.implementation"
- uid: "com.azure.storage.common.implementation.UploadUtils.chunkSource*"
  name: "chunkSource"
  nameWithType: "UploadUtils.chunkSource"
  fullName: "com.azure.storage.common.implementation.UploadUtils.chunkSource"
  package: "com.azure.storage.common.implementation"
- uid: "java.lang.String"
  spec.java:
  - uid: "java.lang.String"
    name: "String"
    fullName: "java.lang.String"
- uid: "java.lang.Integer"
  spec.java:
  - uid: "java.lang.Integer"
    name: "Integer"
    fullName: "java.lang.Integer"
- uid: "com.azure.core.util.logging.ClientLogger"
  spec.java:
  - uid: "com.azure.core.util.logging.ClientLogger"
    name: "ClientLogger"
    fullName: "com.azure.core.util.logging.ClientLogger"
- uid: "boolean"
  spec.java:
  - uid: "boolean"
    name: "boolean"
    fullName: "boolean"
- uid: "com.azure.storage.common.implementation.UploadUtils.shouldUploadInChunks*"
  name: "shouldUploadInChunks"
  nameWithType: "UploadUtils.shouldUploadInChunks"
  fullName: "com.azure.storage.common.implementation.UploadUtils.shouldUploadInChunks"
  package: "com.azure.storage.common.implementation"
- uid: "java.nio.channels.AsynchronousFileChannel"
  spec.java:
  - uid: "java.nio.channels.AsynchronousFileChannel"
    name: "AsynchronousFileChannel"
    fullName: "java.nio.channels.AsynchronousFileChannel"
- uid: "com.azure.storage.common.implementation.UploadUtils.uploadFileResourceSupplier*"
  name: "uploadFileResourceSupplier"
  nameWithType: "UploadUtils.uploadFileResourceSupplier"
  fullName: "com.azure.storage.common.implementation.UploadUtils.uploadFileResourceSupplier"
  package: "com.azure.storage.common.implementation"
- uid: "com.azure.storage.common.implementation.UploadUtils.uploadFileCleanup*"
  name: "uploadFileCleanup"
  nameWithType: "UploadUtils.uploadFileCleanup"
  fullName: "com.azure.storage.common.implementation.UploadUtils.uploadFileCleanup"
  package: "com.azure.storage.common.implementation"
- uid: "java.lang.Object.notify()"
  name: "Object.notify()"
  nameWithType: "Object.notify()"
  fullName: "java.lang.Object.notify()"
- uid: "java.lang.Object.wait()"
  name: "Object.wait()"
  nameWithType: "Object.wait()"
  fullName: "java.lang.Object.wait()"
- uid: "java.lang.Object.finalize()"
  name: "Object.finalize()"
  nameWithType: "Object.finalize()"
  fullName: "java.lang.Object.finalize()"
- uid: "java.lang.Object.clone()"
  name: "Object.clone()"
  nameWithType: "Object.clone()"
  fullName: "java.lang.Object.clone()"
- uid: "java.lang.Object.notifyAll()"
  name: "Object.notifyAll()"
  nameWithType: "Object.notifyAll()"
  fullName: "java.lang.Object.notifyAll()"
- uid: "java.lang.Object.equals(java.lang.Object)"
  name: "Object.equals(Object)"
  nameWithType: "Object.equals(Object)"
  fullName: "java.lang.Object.equals(java.lang.Object)"
- uid: "java.lang.Object.getClass()"
  name: "Object.getClass()"
  nameWithType: "Object.getClass()"
  fullName: "java.lang.Object.getClass()"
- uid: "java.lang.Object.wait(long)"
  name: "Object.wait(long)"
  nameWithType: "Object.wait(long)"
  fullName: "java.lang.Object.wait(long)"
- uid: "java.lang.Object.hashCode()"
  name: "Object.hashCode()"
  nameWithType: "Object.hashCode()"
  fullName: "java.lang.Object.hashCode()"
- uid: "java.lang.Object.wait(long,int)"
  name: "Object.wait(long,int)"
  nameWithType: "Object.wait(long,int)"
  fullName: "java.lang.Object.wait(long,int)"
- uid: "java.lang.Object.toString()"
  name: "Object.toString()"
  nameWithType: "Object.toString()"
  fullName: "java.lang.Object.toString()"
- uid: "reactor.core.publisher.Flux"
  name: "Flux"
  nameWithType: "Flux"
  fullName: "reactor.core.publisher.Flux"
- uid: "java.nio.ByteBuffer"
  name: "ByteBuffer"
  nameWithType: "ByteBuffer"
  fullName: "java.nio.ByteBuffer"
- uid: "T"
  name: "T"
  nameWithType: "T"
  fullName: "T"
- uid: "java.nio.ByteBuffer>,reactor.core.publisher.Mono"
  name: "ByteBuffer>,Mono"
  nameWithType: "ByteBuffer>,Mono"
  fullName: "java.nio.ByteBuffer>,reactor.core.publisher.Mono"
- uid: "java.util.function.Function"
  name: "Function"
  nameWithType: "Function"
  fullName: "java.util.function.Function"
- uid: "com.azure.core.http.rest.Response"
  name: "Response"
  nameWithType: "Response"
  fullName: "com.azure.core.http.rest.Response"
- uid: "java.nio.ByteBuffer>,java.lang.Long,reactor.core.publisher.Mono"
  name: "ByteBuffer>,Long,Mono"
  nameWithType: "ByteBuffer>,Long,Mono"
  fullName: "java.nio.ByteBuffer>,java.lang.Long,reactor.core.publisher.Mono"
- uid: "java.util.function.BiFunction"
  name: "BiFunction"
  nameWithType: "BiFunction"
  fullName: "java.util.function.BiFunction"
- uid: "reactor.core.publisher.Mono"
  name: "Mono"
  nameWithType: "Mono"
  fullName: "reactor.core.publisher.Mono"
