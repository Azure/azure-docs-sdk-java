### YamlMime:JavaType
uid: "com.azure.storage.common.StorageInputStream"
fullName: "com.azure.storage.common.StorageInputStream"
name: "StorageInputStream"
nameWithType: "StorageInputStream"
summary: "Provides an input stream to read a given storage resource."
inheritances:
- "<xref href=\"java.lang.Object?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"java.io.InputStream?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.io.InputStream.available()"
- "java.io.InputStream.close()"
- "java.io.InputStream.mark(int)"
- "java.io.InputStream.markSupported()"
- "java.io.InputStream.nullInputStream()"
- "java.io.InputStream.read()"
- "java.io.InputStream.read(byte[])"
- "java.io.InputStream.read(byte[],int,int)"
- "java.io.InputStream.readAllBytes()"
- "java.io.InputStream.readNBytes(byte[],int,int)"
- "java.io.InputStream.readNBytes(int)"
- "java.io.InputStream.reset()"
- "java.io.InputStream.skip(long)"
- "java.io.InputStream.transferTo(java.io.OutputStream)"
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
syntax: "public abstract class StorageInputStream extends InputStream"
constructors:
- uid: "com.azure.storage.common.StorageInputStream.StorageInputStream(int,long)"
  fullName: "com.azure.storage.common.StorageInputStream.StorageInputStream(int chunkSize, long contentLength)"
  name: "StorageInputStream(int chunkSize, long contentLength)"
  nameWithType: "StorageInputStream.StorageInputStream(int chunkSize, long contentLength)"
  summary: "Initializes a new instance of the Storage<wbr>Input<wbr>Stream class."
  modifiers:
  - "protected"
  parameters:
  - description: "the size of chunk allowed to pass for storage service request."
    name: "chunkSize"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  - description: "the actual content length for input data."
    name: "contentLength"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "protected StorageInputStream(int chunkSize, long contentLength)"
  desc: "Initializes a new instance of the StorageInputStream class."
- uid: "com.azure.storage.common.StorageInputStream.StorageInputStream(long,java.lang.Long,int,long)"
  fullName: "com.azure.storage.common.StorageInputStream.StorageInputStream(long rangeOffset, Long rangeLength, int chunkSize, long contentLength)"
  name: "StorageInputStream(long rangeOffset, Long rangeLength, int chunkSize, long contentLength)"
  nameWithType: "StorageInputStream.StorageInputStream(long rangeOffset, Long rangeLength, int chunkSize, long contentLength)"
  summary: "Initializes a new instance of the Storage<wbr>Input<wbr>Stream class."
  modifiers:
  - "protected"
  parameters:
  - description: "The offset of the data to begin stream."
    name: "rangeOffset"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  - description: "How much data the stream should return after blobRangeOffset."
    name: "rangeLength"
    type: "<xref href=\"java.lang.Long?alt=java.lang.Long&text=Long\" data-throw-if-not-resolved=\"False\" />"
  - description: "Holds the stream read size."
    name: "chunkSize"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  - description: "The length of the stream to be transferred."
    name: "contentLength"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "protected StorageInputStream(long rangeOffset, Long rangeLength, int chunkSize, long contentLength)"
  desc: "Initializes a new instance of the StorageInputStream class."
- uid: "com.azure.storage.common.StorageInputStream.StorageInputStream(long,java.lang.Long,int,long,java.nio.ByteBuffer)"
  fullName: "com.azure.storage.common.StorageInputStream.StorageInputStream(long rangeOffset, Long rangeLength, int chunkSize, long contentLength, ByteBuffer initialBuffer)"
  name: "StorageInputStream(long rangeOffset, Long rangeLength, int chunkSize, long contentLength, ByteBuffer initialBuffer)"
  nameWithType: "StorageInputStream.StorageInputStream(long rangeOffset, Long rangeLength, int chunkSize, long contentLength, ByteBuffer initialBuffer)"
  summary: "Initializes a new instance of the Storage<wbr>Input<wbr>Stream class."
  modifiers:
  - "protected"
  parameters:
  - description: "The offset of the data to begin stream."
    name: "rangeOffset"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  - description: "How much data the stream should return after blobRangeOffset."
    name: "rangeLength"
    type: "<xref href=\"java.lang.Long?alt=java.lang.Long&text=Long\" data-throw-if-not-resolved=\"False\" />"
  - description: "Holds the stream read size."
    name: "chunkSize"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  - description: "The length of the stream to be transferred."
    name: "contentLength"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  - description: "The first chunk of the download. Fetched alongside properties for optimization"
    name: "initialBuffer"
    type: "<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />"
  syntax: "protected StorageInputStream(long rangeOffset, Long rangeLength, int chunkSize, long contentLength, ByteBuffer initialBuffer)"
  desc: "Initializes a new instance of the StorageInputStream class."
fields:
- uid: "com.azure.storage.common.StorageInputStream.bufferSize"
  fullName: "com.azure.storage.common.StorageInputStream.bufferSize"
  name: "bufferSize"
  nameWithType: "StorageInputStream.bufferSize"
  summary: "Holds the length of the current buffer in bytes."
  modifiers:
  - "protected"
  field:
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "protected int bufferSize"
  desc: "Holds the length of the current buffer in bytes."
- uid: "com.azure.storage.common.StorageInputStream.bufferStartOffset"
  fullName: "com.azure.storage.common.StorageInputStream.bufferStartOffset"
  name: "bufferStartOffset"
  nameWithType: "StorageInputStream.bufferStartOffset"
  summary: "Holds the absolute byte position of the start of the current buffer."
  modifiers:
  - "protected"
  field:
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "protected long bufferStartOffset"
  desc: "Holds the absolute byte position of the start of the current buffer."
- uid: "com.azure.storage.common.StorageInputStream.lastError"
  fullName: "com.azure.storage.common.StorageInputStream.lastError"
  name: "lastError"
  nameWithType: "StorageInputStream.lastError"
  summary: "Holds the last exception this stream encountered."
  modifiers:
  - "protected"
  field:
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  syntax: "protected IOException lastError"
  desc: "Holds the last exception this stream encountered."
- uid: "com.azure.storage.common.StorageInputStream.streamFaulted"
  fullName: "com.azure.storage.common.StorageInputStream.streamFaulted"
  name: "streamFaulted"
  nameWithType: "StorageInputStream.streamFaulted"
  summary: "A flag to determine if the stream is faulted, if so the last error will be thrown on next operation."
  modifiers:
  - "protected"
  - "volatile"
  field:
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
  syntax: "protected volatile boolean streamFaulted"
  desc: "A flag to determine if the stream is faulted, if so the last error will be thrown on next operation."
methods:
- uid: "com.azure.storage.common.StorageInputStream.available()"
  fullName: "com.azure.storage.common.StorageInputStream.available()"
  name: "available()"
  nameWithType: "StorageInputStream.available()"
  summary: "Returns an estimate of the number of bytes that can be read (or skipped over) from this input stream without blocking by the next invocation of a method for this input stream."
  modifiers:
  - "synchronized"
  overridden: "java.io.InputStream.available()"
  syntax: "public synchronized int available()"
  desc: "Returns an estimate of the number of bytes that can be read (or skipped over) from this input stream without blocking by the next invocation of a method for this input stream. The next invocation might be the same thread or another thread. A single read or skip of this many bytes will not block, but may read or skip fewer bytes."
  returns:
    description: "An <code>int</code> which represents an estimate of the number of bytes that can be read (or skipped\n over) from this input stream without blocking, or 0 when it reaches the end of the input stream."
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.common.StorageInputStream.close()"
  fullName: "com.azure.storage.common.StorageInputStream.close()"
  name: "close()"
  nameWithType: "StorageInputStream.close()"
  summary: "Closes this input stream and releases any system resources associated with the stream."
  modifiers:
  - "synchronized"
  overridden: "java.io.InputStream.close()"
  syntax: "public synchronized void close()"
  desc: "Closes this input stream and releases any system resources associated with the stream."
- uid: "com.azure.storage.common.StorageInputStream.dispatchRead(int,long)"
  fullName: "com.azure.storage.common.StorageInputStream.dispatchRead(int readLength, long offset)"
  name: "dispatchRead(int readLength, long offset)"
  nameWithType: "StorageInputStream.dispatchRead(int readLength, long offset)"
  summary: "Dispatches a read operation of N bytes and updates stream state accordingly."
  modifiers:
  - "protected"
  - "abstract"
  parameters:
  - description: "An <code>int</code> which represents the number of bytes to read."
    name: "readLength"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  - description: "The start point of data to be acquired."
    name: "offset"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "protected abstract ByteBuffer dispatchRead(int readLength, long offset)"
  exceptions:
  - description: "If an I/O error occurs."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Dispatches a read operation of N bytes and updates stream state accordingly."
  returns:
    description: "The bytebuffer which store one chunk size of data."
    type: "<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.common.StorageInputStream.mark(int)"
  fullName: "com.azure.storage.common.StorageInputStream.mark(int readlimit)"
  name: "mark(int readlimit)"
  nameWithType: "StorageInputStream.mark(int readlimit)"
  summary: "Marks the current position in this input stream."
  modifiers:
  - "synchronized"
  overridden: "java.io.InputStream.mark(int)"
  parameters:
  - description: "An <code>int</code> which represents the maximum limit of bytes that can be read before the mark\n position becomes invalid."
    name: "readlimit"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public synchronized void mark(int readlimit)"
  desc: "Marks the current position in this input stream. A subsequent call to the reset method repositions this stream at the last marked position so that subsequent reads re-read the same bytes."
- uid: "com.azure.storage.common.StorageInputStream.markSupported()"
  fullName: "com.azure.storage.common.StorageInputStream.markSupported()"
  name: "markSupported()"
  nameWithType: "StorageInputStream.markSupported()"
  summary: "Tests if this input stream supports the mark and reset methods."
  overridden: "java.io.InputStream.markSupported()"
  syntax: "public boolean markSupported()"
  desc: "Tests if this input stream supports the mark and reset methods. Whether mark and reset are supported is an invariant property of a particular input stream instance. The markSupported method of <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> returns false."
  returns:
    description: "<Code>True</Code> if this stream instance supports the mark and reset methods; <Code>False</Code>\n otherwise."
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.common.StorageInputStream.read()"
  fullName: "com.azure.storage.common.StorageInputStream.read()"
  name: "read()"
  nameWithType: "StorageInputStream.read()"
  summary: "Reads the next byte of data from the input stream."
  overridden: "java.io.InputStream.read()"
  syntax: "public int read()"
  exceptions:
  - description: "when no available bytes to read."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Reads the next byte of data from the input stream. The value byte is returned as an int in the range 0 to 255. If no byte is available because the end of the stream has been reached, the value -1 is returned. This method blocks until input data is available, the end of the stream is detected, or an exception is thrown."
  returns:
    description: "An <code>int</code> which represents the total number of bytes read into the buffer, or -1 if there is no\n more data because the end of the stream has been reached."
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.common.StorageInputStream.read(byte[])"
  fullName: "com.azure.storage.common.StorageInputStream.read(byte[] b)"
  name: "read(byte[] b)"
  nameWithType: "StorageInputStream.read(byte[] b)"
  summary: "Reads some number of bytes from the input stream and stores them into the buffer array `b`."
  overridden: "java.io.InputStream.read(byte[])"
  parameters:
  - description: "A <code>byte</code> array which represents the buffer into which the data is read."
    name: "b"
    type: "<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]"
  syntax: "public int read(byte[] b)"
  exceptions:
  - description: "If the first byte cannot be read for any reason other than the end of the file, if the input\n stream has been closed, or if some other I/O error occurs."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Reads some number of bytes from the input stream and stores them into the buffer array `b`. The number of bytes actually read is returned as an integer. This method blocks until input data is available, end of file is detected, or an exception is thrown. If the length of `b` is zero, then no bytes are read and 0 is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at the end of the file, the value -1 is returned; otherwise, at least one byte is read and stored into `b`. The first byte read is stored into element `b[0]`, the next one into `b[1]`, and so on. The number of bytes read is, at most, equal to the length of `b`. Let `k` be the number of bytes actually read; these bytes will be stored in elements `b[0]` through `b[k-1]`, leaving elements `b[k]` through `b[b.length-1]` unaffected. The `read(b)` method for class <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> has the same effect as: `read(b, 0, b.length)`"
  returns:
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.common.StorageInputStream.read(byte[],int,int)"
  fullName: "com.azure.storage.common.StorageInputStream.read(byte[] b, int off, int len)"
  name: "read(byte[] b, int off, int len)"
  nameWithType: "StorageInputStream.read(byte[] b, int off, int len)"
  summary: "Reads up to `len` bytes of data from the input stream into an array of bytes."
  overridden: "java.io.InputStream.read(byte[],int,int)"
  parameters:
  - description: "A <code>byte</code> array which represents the buffer into which the data is read."
    name: "b"
    type: "<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]"
  - description: "An <code>int</code> which represents the start offset in the <code>byte</code> array at which the data\n is written."
    name: "off"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  - description: "An <code>int</code> which represents the maximum number of bytes to read."
    name: "len"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public int read(byte[] b, int off, int len)"
  exceptions:
  - description: "If the first byte cannot be read for any reason other than end of file, or if the input\n stream has been closed, or if some other I/O error occurs."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Reads up to `len` bytes of data from the input stream into an array of bytes. An attempt is made to read as many as `len` bytes, but a smaller number may be read. The number of bytes actually read is returned as an integer. This method blocks until input data is available, end of file is detected, or an exception is thrown. If `len` is zero, then no bytes are read and 0 is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at end of file, the value -1 is returned; otherwise, at least one byte is read and stored into `b`. The first byte read is stored into element `b[off]`, the next one into `b[off+1]`, and so on. The number of bytes read is, at most, equal to `len`. Let `k` be the number of bytes actually read; these bytes will be stored in elements `b[off]` through `b[off+k-1]`, leaving elements `b[off+k]` through `b[off+len-1]` unaffected. In every case, elements `b[0]` through `b[off]` and elements `b[off+len]` through `b[b.length-1]` are unaffected. The `read(b, off, len)` method for class <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> simply calls the method `read()` repeatedly. If the first such call results in an `IOException`, that exception is returned from the call to the `read(b, off, len)` method. If any subsequent call to `read()` results in a `IOException`, the exception is caught and treated as if it were end of file; the bytes read up to that point are stored into `b` and the number of bytes read before the exception occurred is returned. The default implementation of this method blocks until the requested amount of input data `len` has been read, end of file is detected, or an exception is thrown. Subclasses are encouraged to provide a more efficient implementation of this method."
  returns:
    description: "An <code>int</code> which represents the total number of bytes read into the buffer, or -1 if there is no\n more data because the end of the stream has been reached."
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.common.StorageInputStream.reset()"
  fullName: "com.azure.storage.common.StorageInputStream.reset()"
  name: "reset()"
  nameWithType: "StorageInputStream.reset()"
  summary: "Repositions this stream to the position at the time the mark method was last called on this input stream."
  modifiers:
  - "synchronized"
  overridden: "java.io.InputStream.reset()"
  syntax: "public synchronized void reset()"
  desc: "Repositions this stream to the position at the time the mark method was last called on this input stream. Note repositioning the blob read stream will disable blob MD5 checking."
- uid: "com.azure.storage.common.StorageInputStream.skip(long)"
  fullName: "com.azure.storage.common.StorageInputStream.skip(long n)"
  name: "skip(long n)"
  nameWithType: "StorageInputStream.skip(long n)"
  summary: "Skips over and discards n bytes of data from this input stream."
  modifiers:
  - "synchronized"
  overridden: "java.io.InputStream.skip(long)"
  parameters:
  - description: "A <code>long</code> which represents the number of bytes to skip."
    name: "n"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public synchronized long skip(long n)"
  desc: "Skips over and discards n bytes of data from this input stream. The skip method may, for a variety of reasons, end up skipping over some smaller number of bytes, possibly 0. This may result from any of a number of conditions; reaching end of file before n bytes have been skipped is only one possibility. The actual number of bytes skipped is returned. If n is negative, no bytes are skipped. Note repositioning the blob read stream will disable blob MD5 checking."
  returns:
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
type: "class"
desc: "Provides an input stream to read a given storage resource."
metadata: {}
package: "com.azure.storage.common"
artifact: com.azure:azure-storage-common:12.18.0
