### YamlMime:JavaPackage
uid: "com.azure.json"
fullName: "com.azure.json"
name: "com.azure.json"
summary: "The Azure JSON library provides interfaces for stream-style JSON reading and writing."
classes:
- "com.azure.json.JsonOptions"
- "com.azure.json.JsonProviders"
- "com.azure.json.JsonReader"
- "com.azure.json.JsonWriteContext"
- "com.azure.json.JsonWriter"
enums:
- "com.azure.json.JsonToken"
- "com.azure.json.JsonWriteState"
interfaces:
- "com.azure.json.JsonProvider"
- "com.azure.json.JsonSerializable"
- "com.azure.json.ReadValueCallback"
- "com.azure.json.WriteValueCallback"
desc: "The Azure JSON library provides interfaces for stream-style JSON reading and writing. Stream-style reading and writing has the type itself define how to read JSON to create an instance of itself and how it writes out to JSON. Azure JSON also allows for external implementations for JSON reading and writing by offering a [service provider interface][] to load implementations from the classpath. However, if one is not found, the Azure JSON library provides a default implementation.\n\n## Getting Started ##\n\n<xref uid=\"com.azure.json.JsonSerializable\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonSerializable\"></xref> is the base of Azure JSON: it's the interface that types implement to provide stream-style JSON reading and writing functionality. The interface has a single implementable method <xref uid=\"com.azure.json.JsonSerializable.toJson(com.azure.json.JsonWriter)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"toJson(JsonWriter)\"></xref> that defines how the object is written as JSON, to the <xref uid=\"com.azure.json.JsonWriter\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonWriter\"></xref>, and a static method <xref uid=\"com.azure.json.JsonSerializable.fromJson*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"fromJson(JsonReader)\"></xref> that defines how to read an instance of the object from JSON, being read from the <xref uid=\"com.azure.json.JsonReader\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonReader\"></xref>. The default implementation of <xref uid=\"com.azure.json.JsonSerializable.fromJson*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"fromJson(JsonReader)\"></xref> throws an [UnsupportedOperationException][] if the static method isn't hidden (a static method with the same definition) by the type implementing <xref uid=\"com.azure.json.JsonSerializable\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonSerializable\"></xref>. Given that the type itself manages JSON serialization the type can be fluent, immutable, or a mix of fluent and immutable, it doesn't matter as all logic is self-encapsulated.\n\n**Sample: All JsonSerializable fields are optional**\n\n```java\n/**\n  * Implementation of JsonSerializable where all properties are fluently set.\n  */\n public class ComputerMemory implements JsonSerializable<ComputerMemory> {\n     private long memoryInBytes;\n     private double clockSpeedInHertz;\n     private String manufacturer;\n     private boolean errorCorrecting;\n\n     /**\n      * Sets the memory capacity, in bytes, of the computer memory.\n      *\n      * @param memoryInBytes The memory capacity in bytes.\n      * @return The update ComputerMemory\n      */\n     public ComputerMemory setMemoryInBytes(long memoryInBytes) {\n         this.memoryInBytes = memoryInBytes;\n         return this;\n     }\n\n     /**\n      * Sets the clock speed, in hertz, of the computer memory.\n      *\n      * @param clockSpeedInHertz The clock speed in hertz.\n      * @return The update ComputerMemory\n      */\n     public ComputerMemory setClockSpeedInHertz(double clockSpeedInHertz) {\n         this.clockSpeedInHertz = clockSpeedInHertz;\n         return this;\n     }\n\n     /**\n      * Sets the manufacturer of the computer memory.\n      *\n      * @param manufacturer The manufacturer.\n      * @return The update ComputerMemory\n      */\n     public ComputerMemory setManufacturer(String manufacturer) {\n         this.manufacturer = manufacturer;\n         return this;\n     }\n\n     /**\n      * Sets whether the computer memory is error correcting.\n      *\n      * @param errorCorrecting Whether the computer memory is error correcting.\n      * @return The update ComputerMemory\n      */\n     public ComputerMemory setErrorCorrecting(boolean errorCorrecting) {\n         this.errorCorrecting = errorCorrecting;\n         return this;\n     }\n\n     @Override\n     public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {\n         return jsonWriter.writeStartObject()\n             .writeLongField(\"memoryInBytes\", memoryInBytes)\n             .writeDoubleField(\"clockSpeedInHertz\", clockSpeedInHertz)\n             // Writing fields with nullable types won't write the field if the value is null. If a nullable field needs\n             // to always be written use 'writeNullableField(String, Object, WriteValueCallback<JsonWriter, Object>)'.\n             // This will write 'fieldName: null' if the value is null.\n             .writeStringField(\"manufacturer\", manufacturer)\n             .writeBooleanField(\"errorCorrecting\", errorCorrecting)\n             .writeEndObject();\n     }\n\n     /**\n      * Reads an instance of ComputerMemory from the JsonReader.\n      *\n      * @param jsonReader The JsonReader being read.\n      * @return An instance of ComputerMemory if the JsonReader was pointing to an instance of it, or null if it was\n      * pointing to JSON null.\n      * @throws IOException If an error occurs while reading the ComputerMemory.\n      */\n     public static ComputerMemory fromJson(JsonReader jsonReader) throws IOException {\n         // 'readObject' will initialize reading if the JsonReader hasn't begun JSON reading and validate that the\n         // current state of reading is a JSON start object. If the state isn't JSON start object an exception will be\n         // thrown.\n         return jsonReader.readObject(reader -> {\n             ComputerMemory deserializedValue = new ComputerMemory();\n\n             while (reader.nextToken() != JsonToken.END_OBJECT) {\n                 String fieldName = reader.getFieldName();\n                 reader.nextToken();\n\n                 // In this case field names are case-sensitive but this could be replaced with 'equalsIgnoreCase' to\n                 // make them case-insensitive.\n                 if (\"memoryInBytes\".equals(fieldName)) {\n                     deserializedValue.setMemoryInBytes(reader.getLong());\n                 } else if (\"clockSpeedInHertz\".equals(fieldName)) {\n                     deserializedValue.setClockSpeedInHertz(reader.getDouble());\n                 } else if (\"manufacturer\".equals(fieldName)) {\n                     deserializedValue.setManufacturer(reader.getString());\n                 } else if (\"errorCorrecting\".equals(fieldName)) {\n                     deserializedValue.setErrorCorrecting(reader.getBoolean());\n                 } else {\n                     // Fallthrough case of an unknown property. In this instance the value is skipped, if it's a JSON\n                     // array or object the reader will progress until it terminated. This could also throw an exception\n                     // if unknown properties should cause that or be read into an additional properties Map for further\n                     // usage.\n                     reader.skipChildren();\n                 }\n             }\n\n             return deserializedValue;\n         });\n     }\n }\n```\n\n**Sample: All JsonSerializable fields are required**\n\n```java\n/**\n  * Implementation of JsonSerializable where all properties are set in the constructor.\n  */\n public class ComputerProcessor implements JsonSerializable<ComputerProcessor> {\n     private final int cores;\n     private final int threads;\n     private final String manufacturer;\n     private final double clockSpeedInHertz;\n     private final OffsetDateTime releaseDate;\n\n     /**\n      * Creates an instance of ComputerProcessor.\n      *\n      * @param cores The number of physical cores.\n      * @param threads The number of virtual threads.\n      * @param manufacturer The manufacturer of the processor.\n      * @param clockSpeedInHertz The clock speed, in hertz, of the processor.\n      * @param releaseDate The release date of the processor, if unreleased this is null.\n      */\n     public ComputerProcessor(int cores, int threads, String manufacturer, double clockSpeedInHertz,\n         OffsetDateTime releaseDate) {\n         // This constructor could be made package-private or private as 'fromJson' has access to internal APIs.\n         this.cores = cores;\n         this.threads = threads;\n         this.manufacturer = manufacturer;\n         this.clockSpeedInHertz = clockSpeedInHertz;\n         this.releaseDate = releaseDate;\n     }\n\n     @Override\n     public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {\n         return jsonWriter.writeStartObject()\n             .writeIntField(\"cores\", cores)\n             .writeIntField(\"threads\", threads)\n             .writeStringField(\"manufacturer\", manufacturer)\n             .writeDoubleField(\"clockSpeedInHertz\", clockSpeedInHertz)\n             // 'writeNullableField' will always write a field, even if the value is null.\n             .writeNullableField(\"releaseDate\", releaseDate, (writer, value) -> writer.writeString(value.toString()))\n             .writeEndObject()\n             // In this case 'toJson' eagerly flushes the JsonWriter.\n             // Flushing too often may result in performance penalties.\n             .flush();\n     }\n\n     /**\n      * Reads an instance of ComputerProcessor from the JsonReader.\n      *\n      * @param jsonReader The JsonReader being read.\n      * @return An instance of ComputerProcessor if the JsonReader was pointing to an instance of it, or null if it was\n      * pointing to JSON null.\n      * @throws IOException If an error occurs while reading the ComputerProcessor.\n      * @throws IllegalStateException If any of the required properties to create ComputerProcessor aren't found.\n      */\n     public static ComputerProcessor fromJson(JsonReader jsonReader) throws IOException {\n         return jsonReader.readObject(reader -> {\n             // Local variables to keep track of what values have been found.\n             // Some properties have a corresponding 'boolean found<Name>' to track if a JSON property with that name\n             // was found. If the value wasn't found an exception will be thrown at the end of reading the object.\n             int cores = 0;\n             boolean foundCores = false;\n             int threads = 0;\n             boolean foundThreads = false;\n             String manufacturer = null;\n             boolean foundManufacturer = false;\n             double clockSpeedInHertz = 0.0D;\n             boolean foundClockSpeedInHertz = false;\n             OffsetDateTime releaseDate = null;\n\n             while (reader.nextToken() != JsonToken.END_OBJECT) {\n                 String fieldName = reader.getFieldName();\n                 reader.nextToken();\n\n                 // Example of case-insensitive names.\n                 if (\"cores\".equalsIgnoreCase(fieldName)) {\n                     cores = reader.getInt();\n                     foundCores = true;\n                 } else if (\"threads\".equalsIgnoreCase(fieldName)) {\n                     threads = reader.getInt();\n                     foundThreads = true;\n                 } else if (\"manufacturer\".equalsIgnoreCase(fieldName)) {\n                     manufacturer = reader.getString();\n                     foundManufacturer = true;\n                 } else if (\"clockSpeedInHertz\".equalsIgnoreCase(fieldName)) {\n                     clockSpeedInHertz = reader.getDouble();\n                     foundClockSpeedInHertz = true;\n                 } else if (\"releaseDate\".equalsIgnoreCase(fieldName)) {\n                     // For nullable primitives 'getNullable' must be used as it will return null if the current token\n                     // is JSON null or pass the reader to the non-null callback method for reading, in this case for\n                     // OffsetDateTime it uses 'getString' to call 'OffsetDateTime.parse'.\n                     releaseDate = reader.getNullable(nonNullReader -> OffsetDateTime.parse(nonNullReader.getString()));\n                 } else {\n                     reader.skipChildren();\n                 }\n             }\n\n             // Check that all required fields were found.\n             if (foundCores && foundThreads && foundManufacturer && foundClockSpeedInHertz) {\n                 return new ComputerProcessor(cores, threads, manufacturer, clockSpeedInHertz, releaseDate);\n             }\n\n             // If required fields were missing throw an exception.\n             throw new IOException(\"Missing one, or more, required fields. Required fields are 'cores', 'threads', \"\n                 + \"'manufacturer', and 'clockSpeedInHertz'.\");\n         });\n     }\n }\n```\n\n**Sample: JsonSerializable contains required and optional fields**\n\n```java\n/**\n  * Implementation of JsonSerializable where some properties are set in the constructor and some properties are set using\n  * fluent methods.\n  */\n public class VmStatistics implements JsonSerializable<VmStatistics> {\n     private final String vmSize;\n     private final ComputerProcessor processor;\n     private final ComputerMemory memory;\n     private final boolean acceleratedNetwork;\n     private Map<String, Object> additionalProperties;\n\n     /**\n      * Creates an instance VmStatistics.\n      *\n      * @param vmSize The size, or name, of the VM type.\n      * @param processor The processor of the VM.\n      * @param memory The memory of the VM.\n      * @param acceleratedNetwork Whether the VM has accelerated networking.\n      */\n     public VmStatistics(String vmSize, ComputerProcessor processor, ComputerMemory memory, boolean acceleratedNetwork) {\n         this.vmSize = vmSize;\n         this.processor = processor;\n         this.memory = memory;\n         this.acceleratedNetwork = acceleratedNetwork;\n     }\n\n     /**\n      * Sets additional properties about the VM.\n      *\n      * @param additionalProperties Additional properties of the VM.\n      * @return The update VmStatistics\n      */\n     public VmStatistics setAdditionalProperties(Map<String, Object> additionalProperties) {\n         this.additionalProperties = additionalProperties;\n         return this;\n     }\n\n     @Override\n     public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {\n         jsonWriter.writeStartObject()\n             .writeStringField(\"VMSize\", vmSize)\n             .writeJsonField(\"Processor\", processor)\n             .writeJsonField(\"Memory\", memory)\n             .writeBooleanField(\"AcceleratedNetwork\", acceleratedNetwork);\n\n         // Include additional properties in JSON serialization.\n         if (additionalProperties != null) {\n             for (Map.Entry<String, Object> additionalProperty : additionalProperties.entrySet()) {\n                 jsonWriter.writeUntypedField(additionalProperty.getKey(), additionalProperty.getValue());\n             }\n         }\n\n         return jsonWriter.writeEndObject();\n     }\n\n     /**\n      * Reads an instance of VmStatistics from the JsonReader.\n      *\n      * @param jsonReader The JsonReader being read.\n      * @return An instance of VmStatistics if the JsonReader was pointing to an instance of it, or null if it was\n      * pointing to JSON null.\n      * @throws IOException If an error occurs while reading the VmStatistics.\n      * @throws IllegalStateException If any of the required properties to create VmStatistics aren't found.\n      */\n     public static VmStatistics fromJson(JsonReader jsonReader) throws IOException {\n         return jsonReader.readObject(reader -> {\n             String vmSize = null;\n             boolean foundVmSize = false;\n             ComputerProcessor processor = null;\n             boolean foundProcessor = false;\n             ComputerMemory memory = null;\n             boolean foundMemory = false;\n             boolean acceleratedNetwork = false;\n             boolean foundAcceleratedNetwork = false;\n             Map<String, Object> additionalProperties = null;\n\n             while (reader.nextToken() != JsonToken.END_OBJECT) {\n                 String fieldName = reader.getFieldName();\n                 reader.nextToken();\n\n                 // Example of case-insensitive names and where serialization named don't match field names.\n                 if (\"VMSize\".equalsIgnoreCase(fieldName)) {\n                     vmSize = reader.getString();\n                     foundVmSize = true;\n                 } else if (\"Processor\".equalsIgnoreCase(fieldName)) {\n                     // Pass the JsonReader to another JsonSerializable to read the inner object.\n                     processor = ComputerProcessor.fromJson(reader);\n                     foundProcessor = true;\n                 } else if (\"Memory\".equalsIgnoreCase(fieldName)) {\n                     memory = ComputerMemory.fromJson(reader);\n                     foundMemory = true;\n                 } else if (\"AcceleratedNetwork\".equalsIgnoreCase(fieldName)) {\n                     acceleratedNetwork = reader.getBoolean();\n                     foundAcceleratedNetwork = true;\n                 } else {\n                     // Fallthrough case but the JSON property is maintained.\n                     if (additionalProperties == null) {\n                         // Maintain ordering of additional properties using a LinkedHashMap.\n                         additionalProperties = new LinkedHashMap<>();\n                     }\n\n                     // Additional properties are unknown types, use 'readUntyped'.\n                     additionalProperties.put(fieldName, reader.readUntyped());\n                 }\n             }\n\n             // Check that all required fields were found.\n             if (foundVmSize && foundProcessor && foundMemory && foundAcceleratedNetwork) {\n                 return new VmStatistics(vmSize, processor, memory, acceleratedNetwork)\n                     .setAdditionalProperties(additionalProperties);\n             }\n\n             // If required fields were missing throw an exception.\n             throw new IOException(\"Missing one, or more, required fields. Required fields are 'VMSize', 'Processor',\"\n                 + \"'Memory', and 'AcceleratedNetwork'.\");\n         });\n     }\n }\n```\n\n## Reading and Writing JSON ##\n\n<xref uid=\"com.azure.json.JsonReader\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonReader\"></xref> contains APIs and logic for parsing JSON. The type is abstract and consists of both abstract methods for an implementation to implement as well as final method for commonly shared logic that builds on the abstract methods. Similarly, <xref uid=\"com.azure.json.JsonWriter\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonWriter\"></xref> contains APIs and logic for writing JSON, and as with <xref uid=\"com.azure.json.JsonReader\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonReader\"></xref>, it contains both abstract methods for implementations to implement and final methods for commonly shared logic that builds on the abstract methods. Both types implement [Closeable][] and should be used in try-with-resources blocks to ensure any resources created by the implementations are cleaned up once JSON reading or writing is complete. Both types are used by the <xref uid=\"com.azure.json.JsonProvider\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonProvider\"></xref> service provider interface which is used to create instances of <xref uid=\"com.azure.json.JsonReader\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonReader\"></xref> and <xref uid=\"com.azure.json.JsonWriter\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonWriter\"></xref> implementations.\n\n<xref uid=\"com.azure.json.JsonProviders\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonProviders\"></xref> is a utility class that handles finding <xref uid=\"com.azure.json.JsonProvider\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonProvider\"></xref> implementations on the classpath and should be the default way to create instances of <xref uid=\"com.azure.json.JsonReader\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonReader\"></xref> and <xref uid=\"com.azure.json.JsonWriter\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonWriter\"></xref>. As mentioned earlier, the Azure JSON package provides a default implementation allowing for the library to be used stand-alone. <xref uid=\"com.azure.json.JsonReader\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonReader\"></xref> can be created from `byte[]`, [String][], [InputStream][], and [Reader][] sources, <xref uid=\"com.azure.json.JsonWriter\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.json.JsonWriter\"></xref> can be created from [OutputStream][] and [Writer][] sources. No matter the source the functionality will be the same, the options exist to provide the best convenience and performance by reducing type translations.\n\n**Sample: Reading a JSON byte\\[\\]**\n\n```java\n// Sample uses String.getBytes as a convenience to show the JSON string in a human-readable form.\n byte[] json = (\"{\\\"memoryInBytes\\\":10000000000,\\\"clockSpeedInHertz\\\":4800000000,\"\n     + \"\\\"manufacturer\\\":\\\"Memory Corp\\\",\\\"errorCorrecting\\\":true}\").getBytes(StandardCharsets.UTF_8);\n\n try (JsonReader jsonReader = JsonProviders.createReader(json)) {\n     return ComputerMemory.fromJson(jsonReader);\n }\n```\n\n**Sample: Reading a JSON String**\n\n```java\nString json = \"{\\\"cores\\\":16,\\\"threads\\\":32,\\\"manufacturer\\\":\\\"Processor Corp\\\",\"\n     + \"\\\"clockSpeedInHertz\\\":5000000000,\\\"releaseDate\\\":null}\";\n\n try (JsonReader jsonReader = JsonProviders.createReader(json)) {\n     return ComputerProcessor.fromJson(jsonReader);\n }\n```\n\n**Sample: Reading a JSON InputStream**\n\n```java\n// Sample uses String.getBytes as a convenience to show the JSON string in a human-readable form.\n InputStream json = new ByteArrayInputStream((\"{\\\"VMSize\\\":\\\"large\\\",\\\"Processor\\\":{\\\"cores\\\":8,\"\n     + \"\\\"threads\\\"16\\\",\\\"manufacturer\\\":\\\"Processor Corp\\\",\\\"clockSpeedInHertz\\\":4000000000,\"\n     + \"\\\"releaseDate\\\":\\\"2023-01-01\\\"},\\\"Memory\\\":{\\\"memoryInBytes\\\":10000000000,\"\n     + \"\\\"clockSpeedInHertz\\\":4800000000,\\\"manufacturer\\\":\\\"Memory Corp\\\",\\\"errorCorrecting\\\":true},\"\n     + \"\\\"AcceleratedNetwork\\\":true,\\\"CloudProvider\\\":\\\"Azure\\\",\\\"Available\\\":true}\")\n     .getBytes(StandardCharsets.UTF_8));\n\n try (JsonReader jsonReader = JsonProviders.createReader(json)) {\n     return VmStatistics.fromJson(jsonReader);\n }\n```\n\n**Sample: Reading a JSON Reader**\n\n```java\nReader json = new StringReader(\"{\\\"VMSize\\\":\\\"large\\\",\\\"Processor\\\":{\\\"cores\\\":8,\\\"threads\\\"16\\\",\"\n     + \"\\\"manufacturer\\\":\\\"Processor Corp\\\",\\\"clockSpeedInHertz\\\":4000000000,\\\"releaseDate\\\":\\\"2023-01-01\\\"},\"\n     + \"\\\"Memory\\\":{\\\"memoryInBytes\\\":10000000000,\\\"clockSpeedInHertz\\\":4800000000,\"\n     + \"\\\"manufacturer\\\":\\\"Memory Corp\\\",\\\"errorCorrecting\\\":true},\\\"AcceleratedNetwork\\\":true,\"\n     + \"\\\"CloudProvider\\\":\\\"Azure\\\",\\\"Available\\\":true}\");\n\n try (JsonReader jsonReader = JsonProviders.createReader(json)) {\n     return VmStatistics.fromJson(jsonReader);\n }\n```\n\n**Sample: Writing to a JSON OutputStream**\n\n```java\nMap<String, Object> additionalVmProperties = new LinkedHashMap<>();\n additionalVmProperties.put(\"CloudProvider\", \"Azure\");\n additionalVmProperties.put(\"Available\", true);\n\n VmStatistics vmStatistics = new VmStatistics(\"large\",\n     new ComputerProcessor(8, 16, \"Processor Corp\", 4000000000D, OffsetDateTime.parse(\"2023-01-01\")),\n     new ComputerMemory()\n         .setMemoryInBytes(10000000000L)\n         .setClockSpeedInHertz(4800000000D)\n         .setManufacturer(\"Memory Corp\")\n         .setErrorCorrecting(true),\n     true)\n     .setAdditionalProperties(additionalVmProperties);\n\n ByteArrayOutputStream json = new ByteArrayOutputStream();\n try (JsonWriter jsonWriter = JsonProviders.createWriter(json)) {\n     // JsonWriter automatically flushes on close.\n     vmStatistics.toJson(jsonWriter);\n }\n\n // {\"VMSize\":\"large\",\"Processor\":{\"cores\":8,\"threads\":16,\"manufacturer\":\"Processor Corp\",\n //   \"clockSpeedInHertz\":4000000000.0,\"releaseDate\":\"2023-01-01\"},\"Memory\":{\"memoryInBytes\":10000000000,\n //   \"clockSpeedInHertz\":4800000000.0,\"manufacturer\":\"Memory Corp\",\"errorCorrecting\":true},\n //   \"AcceleratedNetwork\":true,\"CloudProvider\":\"Azure\",\"Available\":true}\n System.out.println(json);\n```\n\n**Sample: Writing to a JSON Writer**\n\n```java\nMap<String, Object> additionalVmProperties = new LinkedHashMap<>();\n additionalVmProperties.put(\"CloudProvider\", \"Azure\");\n additionalVmProperties.put(\"Available\", true);\n\n VmStatistics vmStatistics = new VmStatistics(\"large\",\n     new ComputerProcessor(8, 16, \"Processor Corp\", 4000000000D, OffsetDateTime.parse(\"2023-01-01\")),\n     new ComputerMemory()\n         .setMemoryInBytes(10000000000L)\n         .setClockSpeedInHertz(4800000000D)\n         .setManufacturer(\"Memory Corp\")\n         .setErrorCorrecting(true),\n     true)\n     .setAdditionalProperties(additionalVmProperties);\n\n Writer json = new StringWriter();\n try (JsonWriter jsonWriter = JsonProviders.createWriter(json)) {\n     // JsonWriter automatically flushes on close.\n     vmStatistics.toJson(jsonWriter);\n }\n\n // {\"VMSize\":\"large\",\"Processor\":{\"cores\":8,\"threads\":16,\"manufacturer\":\"Processor Corp\",\n //   \"clockSpeedInHertz\":4000000000.0,\"releaseDate\":\"2023-01-01\"},\"Memory\":{\"memoryInBytes\":10000000000,\n //   \"clockSpeedInHertz\":4800000000.0,\"manufacturer\":\"Memory Corp\",\"errorCorrecting\":true},\n //   \"AcceleratedNetwork\":true,\"CloudProvider\":\"Azure\",\"Available\":true}\n System.out.println(json);\n```\n\n\n[service provider interface]: https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html\n[UnsupportedOperationException]: https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html\n[Closeable]: https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html\n[String]: https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\n[InputStream]: https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html\n[Reader]: https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html\n[OutputStream]: https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html\n[Writer]: https://docs.oracle.com/javase/8/docs/api/java/io/Writer.html"
metadata: {}
package: "com.azure.json"
artifact: com.azure:azure-json:1.1.0
