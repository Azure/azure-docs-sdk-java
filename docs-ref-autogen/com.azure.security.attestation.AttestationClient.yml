### YamlMime:JavaType
uid: "com.azure.security.attestation.AttestationClient"
fullName: "com.azure.security.attestation.AttestationClient"
name: "AttestationClient"
nameWithType: "AttestationClient"
summary: "The AttestationClient implements the functionality required by the \"Attest\" family of APIs.\n\nAn enclave (or Trusted Execution Environment) is a chunk of code that is isolated from the host (think: \"encrypted VM\" or \"encrypted container\"). But there's one key attribute of the enclave: It is encrypted.That means that if data is sent from the enclave, there is no way of knowing that the data came from the enclave.\n\nAnd even worse, there is no way of securely communicating with the enclave (since the enclave is fully isolated from the host, all information passed into the enclave has to go through its host first).\n\nTo solve the communication problem, the Attest API can be used to facilitate what is known as the \"Secure Key Release\" (SKR) protocol.\n\nThere are 4 parties involved in an attestation operation:\n\n *  The host (which hosts the enclave)\n *  The enclave (which is the enclave :) \x1a encrypted, nobody can see what goes on inside it),\n *  The \"verifier\" which verifies the evidence from the enclave (this is the attestation service) and generates a token which can be received by a relying party, and\n *  The \"relying party\" which will interpret the token from the service. For the Secure Key Release Protocol, this is the entity which wishes to communicate with the enclave.\n\nIt's possible that all these parties are on the same computer, it's possible they\x1are on multiple computers.\nIt's possible that the host is also the relying party. It's possible that the relying party is a component like Azure Managed HSM.\n\nThere are three primary pieces of data received by the service for the Attest family of APIs. All of them are arrays of bytes, and all of them originate from code running in the enclave (thus they need to be treated as opaque arrays of bytes by the SDK):\n\n1.  Evidence. For Intel SGX enclaves, this has two forms, either an SGX 'Quote' or an OpenEnclave 'Report'. It is required for attestation operations.\n2.  InitTimeData \x1a This is data which is specified at Initialization Time. It is optional (and not currently supported on all enclave types in Azure)\n3.  RunTimeData \x1a this is data which is specified at the time the quote is generated (at \x1aruntime\x1a). It is optional, but required for the Secure Key Release protocol.\n\nThe Evidence is cryptographically signed by a known authority (for Intel SGX Quotes or OpenEnclave reports, this is a key owned by Intel which represents that the SGX enclave is valid and can be trusted).\nThe core idea for all attestation operations is to take advantage of a region within the Evidence which is controlled by enclave. For SGX Enclaves, this is the 64 bytes of \"user data\" contained within SGX quote.\n\nFor the Secure Key Release protocol, code inside the enclave generates an asymmetric key and serializes the public key into a byte buffer. It then calculates the SHA256 hash of the serialized key and creates a quote containing that SHA256 hash. We now have a cryptographically validated indication that the contents of the byte buffer was known inside the enclave.\n\nThe enclave then hands the byte buffer and the quote to its host. The host sends the quote and byte buffer as the \"RunTime Data\" to the via the <xref uid=\"com.azure.security.attestation.AttestationClient.attestSgxEnclave(com.azure.core.util.BinaryData)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AttestationClient#attestSgxEnclave(BinaryData)\"></xref> or <xref uid=\"com.azure.security.attestation.AttestationClient.attestOpenEnclave*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AttestationClient#attestOpenEnclave\"></xref> API. Assuming the byte buffer and quote are valid, and the quote contains the hash of the byte buffer, the attestation service responds with an <xref uid=\"com.azure.security.attestation.models.AttestationToken\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AttestationToken\"></xref> signed by the attestation service, whose body is an <xref uid=\"com.azure.security.attestation.models.AttestationResult\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AttestationResult\"></xref>.\n\nThe token generated also includes the contents of the InitTimeData and/or RunTimeData if it was provided in the Attest API call.\n\nThe host then sends the token to the relying party. The relying party verifies the token and verifies the claims within the token indicate that the enclave is the correct enclave. It then takes the key from the token and uses it to encrypt the data to be sent to the enclave and sends that back to the host, which passes it into the enclave.\n\nThat completes the secure key release protocol.\n\n\nWhen the Attestation Token is generated by the attestation service, as mentioned, it contains the InitTime and RunTime data.\n\nThere are two possible representations for RunTime Data in the attestation token, depending on the requirements of the relying party:\nThe first is as JSON formatted data. That can be convenient if the relying party expects to receive its public key as a JSON Web Key\nThe second is as a binary blob of data. That is needed if either the data sent by the enclave isn't a JSON object - for instance, if the RunTime data contained an asymmetric key which is formatted as a PEM encoded key, it should be interpreted as a binary blob\n\nIf you ask for the RunTime data to be included in the token as binary, then it will be base64url encoded in the \"x-ms-maa-enclavehelddata\" claim in the output token (the <xref uid=\"com.azure.security.attestation.models.AttestationResult.getEnclaveHeldData()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AttestationResult#getEnclaveHeldData()\"></xref> property).\nIf you ask for the RunTime data to be included in the token as JSON, then it will be included in the \"x-ms-maa-runtimeClaims\" claim in the output token (the <xref uid=\"com.azure.security.attestation.models.AttestationResult.getRuntimeClaims()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AttestationResult#getRuntimeClaims()\"></xref> property).\n\nIn addition to the Attest APIs, the <xref uid=\"com.azure.security.attestation.AttestationClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AttestationClient\"></xref> object also contains helper APIs which can be used to retrieve the OpenId Metadata document and signing keys from the service.\n\nThe OpenId Metadata document contains properties which describe the attestation service.\n\nThe Attestation Signing Keys describe the keys which will be used to sign tokens generated by the attestation service. All tokens emitted by the attestation service will be signed by one of the certificates listed in the attestation signing keys.\n\n**Note:** The <xref uid=\"com.azure.core.http.rest.Response\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Response\"></xref> returned by the `WithResponse` APIs is actually an <xref uid=\"com.azure.security.attestation.models.AttestationToken\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AttestationToken\"></xref> object, which contains a method <xref uid=\"com.azure.security.attestation.models.AttestationToken.serialize()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AttestationToken#serialize()\"></xref> which returns the actual JSON Web Token returned by the attestation service. If a client is going to be transmitting the attestation token from the MAA service to an external relying party, they should send the actual token from the service to the relying party."
inheritances:
- "<xref href=\"java.lang.Object\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
syntax: "public final class AttestationClient"
methods:
- "com.azure.security.attestation.AttestationClient.attestOpenEnclave(com.azure.core.util.BinaryData)"
- "com.azure.security.attestation.AttestationClient.attestOpenEnclave(com.azure.security.attestation.models.AttestationOptions)"
- "com.azure.security.attestation.AttestationClient.attestOpenEnclaveWithResponse(com.azure.security.attestation.models.AttestationOptions,com.azure.core.util.Context)"
- "com.azure.security.attestation.AttestationClient.attestSgxEnclave(com.azure.core.util.BinaryData)"
- "com.azure.security.attestation.AttestationClient.attestSgxEnclave(com.azure.security.attestation.models.AttestationOptions)"
- "com.azure.security.attestation.AttestationClient.attestSgxEnclaveWithResponse(com.azure.security.attestation.models.AttestationOptions,com.azure.core.util.Context)"
- "com.azure.security.attestation.AttestationClient.attestTpm(java.lang.String)"
- "com.azure.security.attestation.AttestationClient.attestTpmWithResponse(java.lang.String,com.azure.core.util.Context)"
- "com.azure.security.attestation.AttestationClient.getOpenIdMetadata()"
- "com.azure.security.attestation.AttestationClient.getOpenIdMetadataWithResponse(com.azure.core.util.Context)"
- "com.azure.security.attestation.AttestationClient.listAttestationSigners()"
- "com.azure.security.attestation.AttestationClient.listAttestationSignersWithResponse(com.azure.core.util.Context)"
type: "class"
metadata: {}
package: "com.azure.security.attestation"
artifact: com.azure:azure-security-attestation:1.0.0
