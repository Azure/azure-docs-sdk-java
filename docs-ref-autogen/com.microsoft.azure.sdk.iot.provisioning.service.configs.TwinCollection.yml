### YamlMime:ManagedReference
items:
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection
  id: TwinCollection
  artifact: com.microsoft.azure.sdk.iot.provisioning:provisioning-service-client:1.7.0
  parent: com.microsoft.azure.sdk.iot.provisioning.service.configs
  children:
  - com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.TwinCollection()
  - com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.TwinCollection(java.util.Map<? extends java.lang.String,java.lang.Object>)
  - com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getTwinMetadata()
  - com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getTwinMetadata(java.lang.String)
  - com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getVersion()
  - com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.put(java.lang.String,java.lang.Object)
  - com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.putAll(java.util.Map<? extends java.lang.String,?>)
  - com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.toJsonElement()
  langs:
  - java
  name: TwinCollection
  nameWithType: TwinCollection
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection
  type: Class
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
  summary: >-
    Representation of a single Twin collection for Provisioning.


    The TwinCollection is an extension of a `HashMap` of `String` and `Object` that contain individual and general versioning mechanism.


    By the Twin definition, the `Object` can contain types of `Boolean`, `Number`, `String`, `Object`, or a sub-TwinCollection, but it cannot be types defined by the user or arrays.


    A TwinCollection can contain up to 5 levels of sub TwinCollections. Once the TwinCollection is a extension of the `HashMap`, both TwinCollection as well as its sub-TwinCollections can be casted to Map of String and Object.


    The collection will be represented in the rest API as a JSON in the body. It can or cannot contain the metadata (identified by the **$** character at the beginning of the key.


    Because of the Twin metadata, the character **$** is not allowed in the entry key.


    For instance, the following JSON is a valid TwinCollection with its metadata.


    ```java

    {
         "Color":"White",
         "MaxSpeed":{
             "Value":500,
             "NewValue":300
         },
         "$metadata":{
             "$lastUpdated":"2017-09-21T02:07:44.238Z",
             "$lastUpdatedVersion":4,
             "Color":{
                 "$lastUpdated":"2017-09-21T02:07:44.238Z",
                 "$lastUpdatedVersion":4,
             },
             "MaxSpeed":{
                 "$lastUpdated":"2017-09-21T02:07:44.238Z",
                 "$lastUpdatedVersion":4,
                 "Value":{
                     "$lastUpdated":"2017-09-21T02:07:44.238Z",
                     "$lastUpdatedVersion":4
                 },
                 "NewValue":{
                     "$lastUpdated":"2017-09-21T02:07:44.238Z",
                     "$lastUpdatedVersion":4
                 }
             }
         },
         "$version":4
     }
    ```


    This class exposes the Twin collection with or without metadata as a Map here user can gat both the value and the metadata. For instance, in the above TwinCollection, <xref uid="com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.get*" data-throw-if-not-resolved="false">#get(Object)</xref> for **Color** will return **White** and the <xref uid="com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getTwinMetadata(java.lang.String)" data-throw-if-not-resolved="false">#getTwinMetadata(String)</xref> for **Color** will return the Object TwinMetadata that contain <xref uid="com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinMetadata.getLastUpdated()" data-throw-if-not-resolved="false">TwinMetadata#getLastUpdated()</xref> that will returns the `Date` **2017-09-21T02:07:44.238Z** and <xref uid="com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinMetadata.getLastUpdatedVersion()" data-throw-if-not-resolved="false">TwinMetadata#getLastUpdatedVersion()</xref> that will returns the `Integer` **4**.


    For the nested TwinCollection, you can do the same, for instance, the following code will return the value and metadata of the **NewValue** nested in **MaxSpeed**:


    ```java

    // Get the value of the MaxSpeed, which is a inner TwinCollection.
          TwinCollection innerMaxSpeed = (TwinCollection) twinCollection.get("MaxSpeed");

          // From the inner TwinCollection, get the value of the NewValue.
          Long maxSpeedNewValue = innerMaxSpeed.get("NewValue");

          // As in the root TwinCollection, the inner TwinCollection contain its own metadata.
          // So, get the metadata information for the inner NewValue.
          TwinMetadata maxSpeedNewValueMetadata = innerMaxSpeed.getTwinMetadata("NewValue");
          Date newValueLastUpdated = maxSpeedNewValueMetadata.getLastUpdated(); //Shall contain `2017-09-21T02:07:44.238Z`
          Integer newValueLastUpdatedVersion = maxSpeedNewValueMetadata.getLastUpdatedVersion(); //Shall contain `4`
    ```
  syntax:
    content: public class TwinCollection extends HashMap<String,Object>
  inheritance:
  - java.lang.Object
  - java.util.AbstractMap
  - java.util.HashMap
  inheritedMembers:
  - java.lang.Object.finalize()
  - java.lang.Object.getClass()
  - java.lang.Object.notify()
  - java.lang.Object.notifyAll()
  - java.lang.Object.wait()
  - java.lang.Object.wait(long)
  - java.lang.Object.wait(long,int)
  - java.util.AbstractMap.equals(java.lang.Object)
  - java.util.AbstractMap.hashCode()
  - java.util.AbstractMap.toString()
  - java.util.HashMap.clear()
  - java.util.HashMap.clone()
  - java.util.HashMap.compute(K,java.util.function.BiFunction<? super K,? super V,? extends V>)
  - java.util.HashMap.computeIfAbsent(K,java.util.function.Function<? super K,? extends V>)
  - java.util.HashMap.computeIfPresent(K,java.util.function.BiFunction<? super K,? super V,? extends V>)
  - java.util.HashMap.containsKey(java.lang.Object)
  - java.util.HashMap.containsValue(java.lang.Object)
  - java.util.HashMap.entrySet()
  - java.util.HashMap.forEach(java.util.function.BiConsumer<? super K,? super V>)
  - java.util.HashMap.get(java.lang.Object)
  - java.util.HashMap.getOrDefault(java.lang.Object,V)
  - java.util.HashMap.isEmpty()
  - java.util.HashMap.keySet()
  - java.util.HashMap.merge(K,V,java.util.function.BiFunction<? super V,? super V,? extends V>)
  - java.util.HashMap.put(K,V)
  - java.util.HashMap.putAll(java.util.Map<? extends K,? extends V>)
  - java.util.HashMap.putIfAbsent(K,V)
  - java.util.HashMap.remove(java.lang.Object)
  - java.util.HashMap.remove(java.lang.Object,java.lang.Object)
  - java.util.HashMap.replace(K,V)
  - java.util.HashMap.replace(K,V,V)
  - java.util.HashMap.replaceAll(java.util.function.BiFunction<? super K,? super V,? extends V>)
  - java.util.HashMap.size()
  - java.util.HashMap.values()
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.TwinCollection()
  id: TwinCollection()
  artifact: com.microsoft.azure.sdk.iot.provisioning:provisioning-service-client:1.7.0
  parent: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection
  langs:
  - java
  name: TwinCollection()
  nameWithType: TwinCollection.TwinCollection()
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.TwinCollection()
  overload: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.TwinCollection*
  type: Constructor
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
  summary: >-
    Constructor


    Creates an empty collection. Fill it with <xref uid="com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.put(java.lang.String,java.lang.Object)" data-throw-if-not-resolved="false">#put(String, Object)</xref> or <xref uid="com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.putAll(java.util.Map&lt;? extends java.lang.String,?&gt;)" data-throw-if-not-resolved="false">#putAll(Map)</xref>.
  syntax:
    content: public TwinCollection()
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.TwinCollection(java.util.Map<? extends java.lang.String,java.lang.Object>)
  id: TwinCollection(java.util.Map<? extends java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure.sdk.iot.provisioning:provisioning-service-client:1.7.0
  parent: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection
  langs:
  - java
  name: TwinCollection(Map<? extends String,Object> map)
  nameWithType: TwinCollection.TwinCollection(Map<? extends String,Object> map)
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.TwinCollection(Map<? extends String,Object> map)
  overload: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.TwinCollection*
  type: Constructor
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
  summary: >-
    Constructor


    Creates a new Twin collection coping the provided Map. Once TwinCollection extends Map, this method can copy another TwinCollection.
  syntax:
    content: public TwinCollection(Map<? extends String,Object> map)
    parameters:
    - id: map
      type: java.util.Map<? extends java.lang.String,java.lang.Object>
      description: the Map of <code>? extends String</code> and <code>Object</code> with the Twin collection
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getTwinMetadata()
  id: getTwinMetadata()
  artifact: com.microsoft.azure.sdk.iot.provisioning:provisioning-service-client:1.7.0
  parent: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection
  langs:
  - java
  name: getTwinMetadata()
  nameWithType: TwinCollection.getTwinMetadata()
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getTwinMetadata()
  overload: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getTwinMetadata*
  type: Method
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
  summary: Getter for the TwinCollection metadata
  syntax:
    content: public TwinMetadata getTwinMetadata()
    return:
      type: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinMetadata
      description: the <xref uid="com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinMetadata" data-throw-if-not-resolved="false">TwinMetadata</xref> of the Whole TwinCollection. It can be <code>null</code>.
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getTwinMetadata(java.lang.String)
  id: getTwinMetadata(java.lang.String)
  artifact: com.microsoft.azure.sdk.iot.provisioning:provisioning-service-client:1.7.0
  parent: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection
  langs:
  - java
  name: getTwinMetadata(String key)
  nameWithType: TwinCollection.getTwinMetadata(String key)
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getTwinMetadata(String key)
  overload: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getTwinMetadata*
  type: Method
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
  summary: Getter for the entry metadata in the TwinCollection.
  syntax:
    content: public TwinMetadata getTwinMetadata(String key)
    parameters:
    - id: key
      type: java.lang.String
      description: the <code>String</code> with the name of the entry to retrieve the metadata.
    return:
      type: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinMetadata
      description: the <xref uid="com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinMetadata" data-throw-if-not-resolved="false">TwinMetadata</xref> ot the specific entry in the TwinCollection. It can be <code>null</code>.
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getVersion()
  id: getVersion()
  artifact: com.microsoft.azure.sdk.iot.provisioning:provisioning-service-client:1.7.0
  parent: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection
  langs:
  - java
  name: getVersion()
  nameWithType: TwinCollection.getVersion()
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getVersion()
  overload: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getVersion*
  type: Method
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
  summary: Getter for the version.
  syntax:
    content: public Integer getVersion()
    return:
      type: java.lang.Integer
      description: The <code>Integer</code> with the version content. It can be <code>null</code>.
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.put(java.lang.String,java.lang.Object)
  id: put(java.lang.String,java.lang.Object)
  artifact: com.microsoft.azure.sdk.iot.provisioning:provisioning-service-client:1.7.0
  parent: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection
  langs:
  - java
  name: put(String key, Object value)
  nameWithType: TwinCollection.put(String key, Object value)
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.put(String key, Object value)
  overload: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.put*
  type: Method
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
  summary: >-
    Add a single new entry in the TwinCollection.


    Override `HashMap.put(String, Object)`.


    This function will add a single pair key value to the TwinCollection. By the Twin definition, the `Object` can contain types of `Boolean`, `Number`, `String`, `Object`, or up to 5 levels of sub-TwinCollection, but it cannot be types defined by the user or arrays.
  syntax:
    content: public Object put(String key, Object value)
    parameters:
    - id: key
      type: java.lang.String
      description: the <code>String</code> that represent the key of the new entry. It cannot be {#code null} or empty.
    - id: value
      type: java.lang.Object
      description: the <code>Object</code> that represents the value of the new entry. It cannot be user defined type or array.
    return:
      type: java.lang.Object
      description: The <code>Object</code> that correspond to the last value of this key. It will be <code>null</code> if there is no previous value.
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.putAll(java.util.Map<? extends java.lang.String,?>)
  id: putAll(java.util.Map<? extends java.lang.String,?>)
  artifact: com.microsoft.azure.sdk.iot.provisioning:provisioning-service-client:1.7.0
  parent: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection
  langs:
  - java
  name: putAll(Map<? extends String,?> map)
  nameWithType: TwinCollection.putAll(Map<? extends String,?> map)
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.putAll(Map<? extends String,?> map)
  overload: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.putAll*
  type: Method
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
  summary: >-
    Add all information in the provided Map to the TwinCollection.


    Override `HashMap.putAll(Map)`.


    This function will add all entries in the Map to the TwinCollection. If the provided key already exists, it will replace the value by the new one. This function will not delete or change the content of the other keys in the Map.


    As defined by the Twin, the value of a entry can be an inner Map. TwinCollection will accept up to 5 levels of inner Maps.
  syntax:
    content: public void putAll(Map<? extends String,?> map)
    parameters:
    - id: map
      type: java.util.Map<? extends java.lang.String,?>
      description: A <code>Map</code> of entries to add to the TwinCollection.
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.toJsonElement()
  id: toJsonElement()
  artifact: com.microsoft.azure.sdk.iot.provisioning:provisioning-service-client:1.7.0
  parent: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection
  langs:
  - java
  name: toJsonElement()
  nameWithType: TwinCollection.toJsonElement()
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.toJsonElement()
  overload: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.toJsonElement*
  type: Method
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
  summary: >-
    Serializer


    Creates a `JsonElement`, which the content represents the information in this class and its subclasses in a JSON format.


    This is useful if the caller will integrate this JSON with JSON from other classes to generate a consolidated JSON.
  syntax:
    content: public JsonElement toJsonElement()
    return:
      type: com.google.gson.JsonElement
      description: The <code>JsonElement</code> with the content of this class.
references:
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.TwinCollection*
  name: TwinCollection
  nameWithType: TwinCollection.TwinCollection
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.TwinCollection
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
- uid: java.util.Map<? extends java.lang.String,java.lang.Object>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: '? extends java.lang.String'
    name: String
    fullName: '? extends java.lang.String'
  - name: ','
    fullName: ','
  - uid: java.lang.Object
    name: Object
    fullName: java.lang.Object
  - name: '>'
    fullName: '>'
- uid: java.util.Map<? extends java.lang.String,?>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: '? extends java.lang.String'
    name: String
    fullName: '? extends java.lang.String'
  - name: ','
    fullName: ','
  - uid: '?'
    name: '?'
    fullName: '?'
  - name: '>'
    fullName: '>'
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.putAll*
  name: putAll
  nameWithType: TwinCollection.putAll
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.putAll
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
- uid: java.lang.String
  spec.java:
  - uid: java.lang.String
    name: String
    fullName: java.lang.String
- uid: java.lang.Object
  spec.java:
  - uid: java.lang.Object
    name: Object
    fullName: java.lang.Object
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.put*
  name: put
  nameWithType: TwinCollection.put
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.put
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
- uid: com.google.gson.JsonElement
  spec.java:
  - uid: com.google.gson.JsonElement
    name: JsonElement
    fullName: com.google.gson.JsonElement
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.toJsonElement*
  name: toJsonElement
  nameWithType: TwinCollection.toJsonElement
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.toJsonElement
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
- uid: java.lang.Integer
  spec.java:
  - uid: java.lang.Integer
    name: Integer
    fullName: java.lang.Integer
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getVersion*
  name: getVersion
  nameWithType: TwinCollection.getVersion
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getVersion
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinMetadata
  name: TwinMetadata
  nameWithType: TwinMetadata
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinMetadata
- uid: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getTwinMetadata*
  name: getTwinMetadata
  nameWithType: TwinCollection.getTwinMetadata
  fullName: com.microsoft.azure.sdk.iot.provisioning.service.configs.TwinCollection.getTwinMetadata
  package: com.microsoft.azure.sdk.iot.provisioning.service.configs
- uid: java.util.HashMap<java.lang.String,java.lang.Object>
  name: HashMap<String,Object>
  nameWithType: HashMap<String,Object>
  fullName: java.util.HashMap<java.lang.String,java.lang.Object>
- uid: java.util.HashMap.get(java.lang.Object)
  name: HashMap.get(Object)
  nameWithType: HashMap.get(Object)
  fullName: java.util.HashMap.get(java.lang.Object)
- uid: java.util.HashMap.remove(java.lang.Object,java.lang.Object)
  name: HashMap.remove(Object,Object)
  nameWithType: HashMap.remove(Object,Object)
  fullName: java.util.HashMap.remove(java.lang.Object,java.lang.Object)
- uid: java.util.HashMap.remove(java.lang.Object)
  name: HashMap.remove(Object)
  nameWithType: HashMap.remove(Object)
  fullName: java.util.HashMap.remove(java.lang.Object)
- uid: java.lang.Object.wait()
  name: Object.wait()
  nameWithType: Object.wait()
  fullName: java.lang.Object.wait()
- uid: java.lang.Object.finalize()
  name: Object.finalize()
  nameWithType: Object.finalize()
  fullName: java.lang.Object.finalize()
- uid: java.util.HashMap.forEach(java.util.function.BiConsumer<? super K,? super V>)
  name: HashMap.forEach(BiConsumer<? super K,? super V>)
  nameWithType: HashMap.forEach(BiConsumer<? super K,? super V>)
  fullName: java.util.HashMap.forEach(java.util.function.BiConsumer<? super K,? super V>)
- uid: java.util.HashMap.putIfAbsent(K,V)
  name: HashMap.putIfAbsent(K,V)
  nameWithType: HashMap.putIfAbsent(K,V)
  fullName: java.util.HashMap.putIfAbsent(K,V)
- uid: java.util.AbstractMap.toString()
  name: AbstractMap.toString()
  nameWithType: AbstractMap.toString()
  fullName: java.util.AbstractMap.toString()
- uid: java.util.HashMap.putAll(java.util.Map<? extends K,? extends V>)
  name: HashMap.putAll(Map<? extends K,? extends V>)
  nameWithType: HashMap.putAll(Map<? extends K,? extends V>)
  fullName: java.util.HashMap.putAll(java.util.Map<? extends K,? extends V>)
- uid: java.util.HashMap.replace(K,V,V)
  name: HashMap.replace(K,V,V)
  nameWithType: HashMap.replace(K,V,V)
  fullName: java.util.HashMap.replace(K,V,V)
- uid: java.util.HashMap.containsValue(java.lang.Object)
  name: HashMap.containsValue(Object)
  nameWithType: HashMap.containsValue(Object)
  fullName: java.util.HashMap.containsValue(java.lang.Object)
- uid: java.util.HashMap.getOrDefault(java.lang.Object,V)
  name: HashMap.getOrDefault(Object,V)
  nameWithType: HashMap.getOrDefault(Object,V)
  fullName: java.util.HashMap.getOrDefault(java.lang.Object,V)
- uid: java.util.HashMap.clear()
  name: HashMap.clear()
  nameWithType: HashMap.clear()
  fullName: java.util.HashMap.clear()
- uid: java.lang.Object.wait(long)
  name: Object.wait(long)
  nameWithType: Object.wait(long)
  fullName: java.lang.Object.wait(long)
- uid: java.lang.Object.getClass()
  name: Object.getClass()
  nameWithType: Object.getClass()
  fullName: java.lang.Object.getClass()
- uid: java.util.HashMap.compute(K,java.util.function.BiFunction<? super K,? super V,? extends V>)
  name: HashMap.compute(K,BiFunction<? super K,? super V,? extends V>)
  nameWithType: HashMap.compute(K,BiFunction<? super K,? super V,? extends V>)
  fullName: java.util.HashMap.compute(K,java.util.function.BiFunction<? super K,? super V,? extends V>)
- uid: java.util.HashMap.size()
  name: HashMap.size()
  nameWithType: HashMap.size()
  fullName: java.util.HashMap.size()
- uid: java.lang.Object.wait(long,int)
  name: Object.wait(long,int)
  nameWithType: Object.wait(long,int)
  fullName: java.lang.Object.wait(long,int)
- uid: java.util.HashMap.put(K,V)
  name: HashMap.put(K,V)
  nameWithType: HashMap.put(K,V)
  fullName: java.util.HashMap.put(K,V)
- uid: java.util.HashMap.replaceAll(java.util.function.BiFunction<? super K,? super V,? extends V>)
  name: HashMap.replaceAll(BiFunction<? super K,? super V,? extends V>)
  nameWithType: HashMap.replaceAll(BiFunction<? super K,? super V,? extends V>)
  fullName: java.util.HashMap.replaceAll(java.util.function.BiFunction<? super K,? super V,? extends V>)
- uid: java.util.HashMap.entrySet()
  name: HashMap.entrySet()
  nameWithType: HashMap.entrySet()
  fullName: java.util.HashMap.entrySet()
- uid: java.util.HashMap.containsKey(java.lang.Object)
  name: HashMap.containsKey(Object)
  nameWithType: HashMap.containsKey(Object)
  fullName: java.util.HashMap.containsKey(java.lang.Object)
- uid: java.lang.Object.notify()
  name: Object.notify()
  nameWithType: Object.notify()
  fullName: java.lang.Object.notify()
- uid: java.util.HashMap.values()
  name: HashMap.values()
  nameWithType: HashMap.values()
  fullName: java.util.HashMap.values()
- uid: java.util.AbstractMap.hashCode()
  name: AbstractMap.hashCode()
  nameWithType: AbstractMap.hashCode()
  fullName: java.util.AbstractMap.hashCode()
- uid: java.lang.Object.notifyAll()
  name: Object.notifyAll()
  nameWithType: Object.notifyAll()
  fullName: java.lang.Object.notifyAll()
- uid: java.util.HashMap.computeIfPresent(K,java.util.function.BiFunction<? super K,? super V,? extends V>)
  name: HashMap.computeIfPresent(K,BiFunction<? super K,? super V,? extends V>)
  nameWithType: HashMap.computeIfPresent(K,BiFunction<? super K,? super V,? extends V>)
  fullName: java.util.HashMap.computeIfPresent(K,java.util.function.BiFunction<? super K,? super V,? extends V>)
- uid: java.util.HashMap.computeIfAbsent(K,java.util.function.Function<? super K,? extends V>)
  name: HashMap.computeIfAbsent(K,Function<? super K,? extends V>)
  nameWithType: HashMap.computeIfAbsent(K,Function<? super K,? extends V>)
  fullName: java.util.HashMap.computeIfAbsent(K,java.util.function.Function<? super K,? extends V>)
- uid: java.util.HashMap.isEmpty()
  name: HashMap.isEmpty()
  nameWithType: HashMap.isEmpty()
  fullName: java.util.HashMap.isEmpty()
- uid: java.util.AbstractMap.equals(java.lang.Object)
  name: AbstractMap.equals(Object)
  nameWithType: AbstractMap.equals(Object)
  fullName: java.util.AbstractMap.equals(java.lang.Object)
- uid: java.util.HashMap.clone()
  name: HashMap.clone()
  nameWithType: HashMap.clone()
  fullName: java.util.HashMap.clone()
- uid: java.util.HashMap.replace(K,V)
  name: HashMap.replace(K,V)
  nameWithType: HashMap.replace(K,V)
  fullName: java.util.HashMap.replace(K,V)
- uid: java.util.HashMap.keySet()
  name: HashMap.keySet()
  nameWithType: HashMap.keySet()
  fullName: java.util.HashMap.keySet()
- uid: java.util.HashMap.merge(K,V,java.util.function.BiFunction<? super V,? super V,? extends V>)
  name: HashMap.merge(K,V,BiFunction<? super V,? super V,? extends V>)
  nameWithType: HashMap.merge(K,V,BiFunction<? super V,? super V,? extends V>)
  fullName: java.util.HashMap.merge(K,V,java.util.function.BiFunction<? super V,? super V,? extends V>)
- uid: '? extends java.lang.String,java.lang.Object'
  name: '? extends String,Object'
  nameWithType: '? extends String,Object'
  fullName: '? extends java.lang.String,java.lang.Object'
- uid: java.util.Map
  name: Map
  nameWithType: Map
  fullName: java.util.Map
- uid: '? extends java.lang.String,?'
  name: '? extends String,?'
  nameWithType: '? extends String,?'
  fullName: '? extends java.lang.String,?'
- uid: java.lang.String,java.lang.Object
  name: String,Object
  nameWithType: String,Object
  fullName: java.lang.String,java.lang.Object
- uid: java.util.HashMap
  name: HashMap
  nameWithType: HashMap
  fullName: java.util.HashMap
- uid: '? super K,? super V>)'
  name: '? super K,? super V>)'
  nameWithType: '? super K,? super V>)'
  fullName: '? super K,? super V>)'
- uid: java.util.HashMap.forEach(java.util.function.BiConsumer
  name: HashMap.forEach(BiConsumer
  nameWithType: HashMap.forEach(BiConsumer
  fullName: java.util.HashMap.forEach(java.util.function.BiConsumer
- uid: java.util.HashMap.putAll(java.util.Map
  name: HashMap.putAll(Map
  nameWithType: HashMap.putAll(Map
  fullName: java.util.HashMap.putAll(java.util.Map
- uid: '? extends K,? extends V>)'
  name: '? extends K,? extends V>)'
  nameWithType: '? extends K,? extends V>)'
  fullName: '? extends K,? extends V>)'
- uid: java.util.HashMap.compute(K,java.util.function.BiFunction
  name: HashMap.compute(K,BiFunction
  nameWithType: HashMap.compute(K,BiFunction
  fullName: java.util.HashMap.compute(K,java.util.function.BiFunction
- uid: '? super K,? super V,? extends V>)'
  name: '? super K,? super V,? extends V>)'
  nameWithType: '? super K,? super V,? extends V>)'
  fullName: '? super K,? super V,? extends V>)'
- uid: java.util.HashMap.replaceAll(java.util.function.BiFunction
  name: HashMap.replaceAll(BiFunction
  nameWithType: HashMap.replaceAll(BiFunction
  fullName: java.util.HashMap.replaceAll(java.util.function.BiFunction
- uid: java.util.HashMap.computeIfPresent(K,java.util.function.BiFunction
  name: HashMap.computeIfPresent(K,BiFunction
  nameWithType: HashMap.computeIfPresent(K,BiFunction
  fullName: java.util.HashMap.computeIfPresent(K,java.util.function.BiFunction
- uid: '? super K,? extends V>)'
  name: '? super K,? extends V>)'
  nameWithType: '? super K,? extends V>)'
  fullName: '? super K,? extends V>)'
- uid: java.util.HashMap.computeIfAbsent(K,java.util.function.Function
  name: HashMap.computeIfAbsent(K,Function
  nameWithType: HashMap.computeIfAbsent(K,Function
  fullName: java.util.HashMap.computeIfAbsent(K,java.util.function.Function
- uid: java.util.HashMap.merge(K,V,java.util.function.BiFunction
  name: HashMap.merge(K,V,BiFunction
  nameWithType: HashMap.merge(K,V,BiFunction
  fullName: java.util.HashMap.merge(K,V,java.util.function.BiFunction
- uid: '? super V,? super V,? extends V>)'
  name: '? super V,? super V,? extends V>)'
  nameWithType: '? super V,? super V,? extends V>)'
  fullName: '? super V,? super V,? extends V>)'
