### YamlMime:ManagedReference
items:
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump
  id: IMessageAndSessionPump
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus
  children:
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.complete(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.complete(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.completeAsync(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.completeAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.lang.String,java.lang.String)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.getPrefetchCount()
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler,com.microsoft.azure.servicebus.MessageHandlerOptions)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler,com.microsoft.azure.servicebus.MessageHandlerOptions,java.util.concurrent.ExecutorService)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler,java.util.concurrent.ExecutorService)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler,com.microsoft.azure.servicebus.SessionHandlerOptions)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler,com.microsoft.azure.servicebus.SessionHandlerOptions,java.util.concurrent.ExecutorService)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler,java.util.concurrent.ExecutorService)
  - com.microsoft.azure.servicebus.IMessageAndSessionPump.setPrefetchCount(int)
  langs:
  - java
  name: IMessageAndSessionPump
  nameWithType: IMessageAndSessionPump
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump
  type: Interface
  package: com.microsoft.azure.servicebus
  summary: Represents the pump which is underneath the clients that handles message processing.
  syntax:
    content: public interface IMessageAndSessionPump
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(java.util.UUID)
  id: abandon(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: abandon(UUID lockToken)
  nameWithType: IMessageAndSessionPump.abandon(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message
  syntax:
    content: public abstract void abandon(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: abandon(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: abandon(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.abandon(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message
  syntax:
    content: public abstract void abandon(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  id: abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: abandon(UUID lockToken, Map<String,Object> propertiesToModify)
  nameWithType: IMessageAndSessionPump.abandon(UUID lockToken, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(UUID lockToken, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message
  syntax:
    content: public abstract void abandon(UUID lockToken, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: abandon(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: abandon(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.abandon(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message
  syntax:
    content: public abstract void abandon(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(java.util.UUID)
  id: abandonAsync(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: abandonAsync(UUID lockToken)
  nameWithType: IMessageAndSessionPump.abandonAsync(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.
  syntax:
    content: public abstract CompletableFuture<Void> abandonAsync(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending abandon.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: abandonAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: abandonAsync(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.abandonAsync(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.
  syntax:
    content: public abstract CompletableFuture<Void> abandonAsync(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending abandon.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  id: abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  nameWithType: IMessageAndSessionPump.abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.
  syntax:
    content: public abstract CompletableFuture<Void> abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending abandon.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: abandonAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.
  syntax:
    content: public abstract CompletableFuture<Void> abandonAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending abandon.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.complete(java.util.UUID)
  id: complete(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: complete(UUID lockToken)
  nameWithType: IMessageAndSessionPump.complete(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.complete(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.complete*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will delete the message from the service.
  syntax:
    content: public abstract void complete(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.complete(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: complete(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: complete(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.complete(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.complete(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.complete*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will delete the message from the service.
  syntax:
    content: public abstract void complete(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.completeAsync(java.util.UUID)
  id: completeAsync(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: completeAsync(UUID lockToken)
  nameWithType: IMessageAndSessionPump.completeAsync(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.completeAsync(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.completeAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will delete the message from the service.
  syntax:
    content: public abstract CompletableFuture<Void> completeAsync(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending complete.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.completeAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: completeAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: completeAsync(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.completeAsync(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.completeAsync(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.completeAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> using its lock token. This will delete the message from the service.
  syntax:
    content: public abstract CompletableFuture<Void> completeAsync(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending complete.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID)
  id: deadLetter(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetter(UUID lockToken)
  nameWithType: IMessageAndSessionPump.deadLetter(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue.
  syntax:
    content: public abstract void deadLetter(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetter(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetter(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.deadLetter(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.lang.String,java.lang.String)
  id: deadLetter(java.util.UUID,java.lang.String,java.lang.String)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  nameWithType: IMessageAndSessionPump.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetter(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  id: deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  nameWithType: IMessageAndSessionPump.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetter(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  id: deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetter(UUID lockToken, Map<String,Object> propertiesToModify)
  nameWithType: IMessageAndSessionPump.deadLetter(UUID lockToken, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(UUID lockToken, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with modified message properties.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetter(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetter(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.deadLetter(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with modified message properties.
  syntax:
    content: public abstract void deadLetter(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID)
  id: deadLetterAsync(java.util.UUID)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetterAsync(UUID lockToken)
  nameWithType: IMessageAndSessionPump.deadLetterAsync(UUID lockToken)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(UUID lockToken)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetterAsync(java.util.UUID,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.deadLetterAsync(UUID lockToken, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(UUID lockToken, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String)
  id: deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  nameWithType: IMessageAndSessionPump.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  id: deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  nameWithType: IMessageAndSessionPump.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetterAsync(java.util.UUID,java.lang.String,java.lang.String,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: deadLetterReason
      type: java.lang.String
      description: The deadletter reason.
    - id: deadLetterErrorDescription
      type: java.lang.String
      description: The deadletter error description.
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  id: deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  nameWithType: IMessageAndSessionPump.deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with modified properties.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  id: deadLetterAsync(java.util.UUID,java.util.Map<java.lang.String,java.lang.Object>,com.microsoft.azure.servicebus.TransactionContext)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageAndSessionPump.deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false">Message</xref> to the deadletter sub-queue with modified properties.
  syntax:
    content: public abstract CompletableFuture<Void> deadLetterAsync(UUID lockToken, Map<String,Object> propertiesToModify, TransactionContext transaction)
    parameters:
    - id: lockToken
      type: java.util.UUID
      description: Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false">Message#getLockToken()</xref>
    - id: propertiesToModify
      type: java.util.Map<java.lang.String,java.lang.Object>
      description: Message properties to modify.
    - id: transaction
      type: com.microsoft.azure.servicebus.TransactionContext
      description: <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false">TransactionContext</xref> which this operation should enlist to.
    return:
      type: java.util.concurrent.CompletableFuture<java.lang.Void>
      description: a CompletableFuture representing the pending deadletter.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.getPrefetchCount()
  id: getPrefetchCount()
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: getPrefetchCount()
  nameWithType: IMessageAndSessionPump.getPrefetchCount()
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.getPrefetchCount()
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.getPrefetchCount*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Get the prefetch value set.
  syntax:
    content: public abstract int getPrefetchCount()
    return:
      type: int
      description: The set prefetch count value.
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler)
  id: registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: registerMessageHandler(IMessageHandler handler)
  nameWithType: IMessageAndSessionPump.registerMessageHandler(IMessageHandler handler)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(IMessageHandler handler)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receive messages continuously from the entity. Registers a message handler and begins a new thread to receive messages. IMessageHandler methods are executed on java.util.concurrent.commonPool()
  syntax:
    content: public abstract void registerMessageHandler(IMessageHandler handler)
    parameters:
    - id: handler
      type: com.microsoft.azure.servicebus.IMessageHandler
      description: The <xref uid="com.microsoft.azure.servicebus.IMessageHandler" data-throw-if-not-resolved="false">IMessageHandler</xref> instance
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler,com.microsoft.azure.servicebus.MessageHandlerOptions)
  id: registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler,com.microsoft.azure.servicebus.MessageHandlerOptions)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: registerMessageHandler(IMessageHandler handler, MessageHandlerOptions handlerOptions)
  nameWithType: IMessageAndSessionPump.registerMessageHandler(IMessageHandler handler, MessageHandlerOptions handlerOptions)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(IMessageHandler handler, MessageHandlerOptions handlerOptions)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receive messages continuously from the entity. Registers a message handler and begins a new thread to receive messages. IMessageHandler methods are executed on java.util.concurrent.commonPool()
  syntax:
    content: public abstract void registerMessageHandler(IMessageHandler handler, MessageHandlerOptions handlerOptions)
    parameters:
    - id: handler
      type: com.microsoft.azure.servicebus.IMessageHandler
      description: The <xref uid="com.microsoft.azure.servicebus.IMessageHandler" data-throw-if-not-resolved="false">IMessageHandler</xref> instance
    - id: handlerOptions
      type: com.microsoft.azure.servicebus.MessageHandlerOptions
      description: <xref uid="com.microsoft.azure.servicebus.MessageHandlerOptions" data-throw-if-not-resolved="false">MessageHandlerOptions</xref>
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler,com.microsoft.azure.servicebus.MessageHandlerOptions,java.util.concurrent.ExecutorService)
  id: registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler,com.microsoft.azure.servicebus.MessageHandlerOptions,java.util.concurrent.ExecutorService)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: registerMessageHandler(IMessageHandler handler, MessageHandlerOptions handlerOptions, ExecutorService executorService)
  nameWithType: IMessageAndSessionPump.registerMessageHandler(IMessageHandler handler, MessageHandlerOptions handlerOptions, ExecutorService executorService)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(IMessageHandler handler, MessageHandlerOptions handlerOptions, ExecutorService executorService)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receive messages continuously from the entity. Registers a message handler and begins a new thread to receive messages. IMessageHandler methods are executed on the passed executor service.
  syntax:
    content: public abstract void registerMessageHandler(IMessageHandler handler, MessageHandlerOptions handlerOptions, ExecutorService executorService)
    parameters:
    - id: handler
      type: com.microsoft.azure.servicebus.IMessageHandler
      description: The <xref uid="com.microsoft.azure.servicebus.IMessageHandler" data-throw-if-not-resolved="false">IMessageHandler</xref> instance
    - id: handlerOptions
      type: com.microsoft.azure.servicebus.MessageHandlerOptions
      description: <xref uid="com.microsoft.azure.servicebus.MessageHandlerOptions" data-throw-if-not-resolved="false">MessageHandlerOptions</xref>
    - id: executorService
      type: java.util.concurrent.ExecutorService
      description: ExecutorService which is used to execute <xref uid="com.microsoft.azure.servicebus.IMessageHandler" data-throw-if-not-resolved="false">IMessageHandler</xref> methods
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler,java.util.concurrent.ExecutorService)
  id: registerMessageHandler(com.microsoft.azure.servicebus.IMessageHandler,java.util.concurrent.ExecutorService)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: registerMessageHandler(IMessageHandler handler, ExecutorService executorService)
  nameWithType: IMessageAndSessionPump.registerMessageHandler(IMessageHandler handler, ExecutorService executorService)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler(IMessageHandler handler, ExecutorService executorService)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receive messages continuously from the entity. Registers a message handler and begins a new thread to receive messages. IMessageHandler methods are executed on the passed executor service.
  syntax:
    content: public abstract void registerMessageHandler(IMessageHandler handler, ExecutorService executorService)
    parameters:
    - id: handler
      type: com.microsoft.azure.servicebus.IMessageHandler
      description: The <xref uid="com.microsoft.azure.servicebus.IMessageHandler" data-throw-if-not-resolved="false">IMessageHandler</xref> instance
    - id: executorService
      type: java.util.concurrent.ExecutorService
      description: ExecutorService which is used to execute <xref uid="com.microsoft.azure.servicebus.IMessageHandler" data-throw-if-not-resolved="false">IMessageHandler</xref> methods.
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler)
  id: registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: registerSessionHandler(ISessionHandler handler)
  nameWithType: IMessageAndSessionPump.registerSessionHandler(ISessionHandler handler)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(ISessionHandler handler)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receive session messages continuously from the queue. Registers a message handler and begins a new thread to receive session-messages. ISessionHandler methods are executed on java.util.concurrent.commonPool()
  syntax:
    content: public abstract void registerSessionHandler(ISessionHandler handler)
    parameters:
    - id: handler
      type: com.microsoft.azure.servicebus.ISessionHandler
      description: The <xref uid="com.microsoft.azure.servicebus.ISessionHandler" data-throw-if-not-resolved="false">ISessionHandler</xref> instance
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler,com.microsoft.azure.servicebus.SessionHandlerOptions)
  id: registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler,com.microsoft.azure.servicebus.SessionHandlerOptions)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: registerSessionHandler(ISessionHandler handler, SessionHandlerOptions handlerOptions)
  nameWithType: IMessageAndSessionPump.registerSessionHandler(ISessionHandler handler, SessionHandlerOptions handlerOptions)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(ISessionHandler handler, SessionHandlerOptions handlerOptions)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receive session messages continuously from the queue. Registers a message handler and begins a new thread to receive session-messages. ISessionHandler methods are executed on java.util.concurrent.commonPool()
  syntax:
    content: public abstract void registerSessionHandler(ISessionHandler handler, SessionHandlerOptions handlerOptions)
    parameters:
    - id: handler
      type: com.microsoft.azure.servicebus.ISessionHandler
      description: The <xref uid="com.microsoft.azure.servicebus.ISessionHandler" data-throw-if-not-resolved="false">ISessionHandler</xref> instance
    - id: handlerOptions
      type: com.microsoft.azure.servicebus.SessionHandlerOptions
      description: <xref uid="com.microsoft.azure.servicebus.SessionHandlerOptions" data-throw-if-not-resolved="false">SessionHandlerOptions</xref>
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler,com.microsoft.azure.servicebus.SessionHandlerOptions,java.util.concurrent.ExecutorService)
  id: registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler,com.microsoft.azure.servicebus.SessionHandlerOptions,java.util.concurrent.ExecutorService)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: registerSessionHandler(ISessionHandler handler, SessionHandlerOptions handlerOptions, ExecutorService executorService)
  nameWithType: IMessageAndSessionPump.registerSessionHandler(ISessionHandler handler, SessionHandlerOptions handlerOptions, ExecutorService executorService)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(ISessionHandler handler, SessionHandlerOptions handlerOptions, ExecutorService executorService)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receive session messages continuously from the queue. Registers a message handler and begins a new thread to receive session-messages. ISessionHandler methods are executed on the passed executor service.
  syntax:
    content: public abstract void registerSessionHandler(ISessionHandler handler, SessionHandlerOptions handlerOptions, ExecutorService executorService)
    parameters:
    - id: handler
      type: com.microsoft.azure.servicebus.ISessionHandler
      description: The <xref uid="com.microsoft.azure.servicebus.ISessionHandler" data-throw-if-not-resolved="false">ISessionHandler</xref> instance
    - id: handlerOptions
      type: com.microsoft.azure.servicebus.SessionHandlerOptions
      description: <xref uid="com.microsoft.azure.servicebus.SessionHandlerOptions" data-throw-if-not-resolved="false">SessionHandlerOptions</xref>
    - id: executorService
      type: java.util.concurrent.ExecutorService
      description: ExecutorService which is used to execute <xref uid="com.microsoft.azure.servicebus.ISessionHandler" data-throw-if-not-resolved="false">ISessionHandler</xref> methods
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler,java.util.concurrent.ExecutorService)
  id: registerSessionHandler(com.microsoft.azure.servicebus.ISessionHandler,java.util.concurrent.ExecutorService)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: registerSessionHandler(ISessionHandler handler, ExecutorService executorService)
  nameWithType: IMessageAndSessionPump.registerSessionHandler(ISessionHandler handler, ExecutorService executorService)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler(ISessionHandler handler, ExecutorService executorService)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: Receive session messages continuously from the queue. Registers a message handler and begins a new thread to receive session-messages. ISessionHandler methods are executed on the passed executor service.
  syntax:
    content: public abstract void registerSessionHandler(ISessionHandler handler, ExecutorService executorService)
    parameters:
    - id: handler
      type: com.microsoft.azure.servicebus.ISessionHandler
      description: The <xref uid="com.microsoft.azure.servicebus.ISessionHandler" data-throw-if-not-resolved="false">ISessionHandler</xref> instance
    - id: executorService
      type: java.util.concurrent.ExecutorService
      description: ExecutorService which is used to execute <xref uid="com.microsoft.azure.servicebus.ISessionHandler" data-throw-if-not-resolved="false">ISessionHandler</xref> methods
  exceptions:
  - type: java.lang.InterruptedException
    description: if the current thread was interrupted while waiting
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if the current thread was interrupted while waiting
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.setPrefetchCount(int)
  id: setPrefetchCount(int)
  artifact: com.microsoft.azure:azure-servicebus:3.4.0
  parent: com.microsoft.azure.servicebus.IMessageAndSessionPump
  langs:
  - java
  name: setPrefetchCount(int prefetchCount)
  nameWithType: IMessageAndSessionPump.setPrefetchCount(int prefetchCount)
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.setPrefetchCount(int prefetchCount)
  overload: com.microsoft.azure.servicebus.IMessageAndSessionPump.setPrefetchCount*
  type: Method
  package: com.microsoft.azure.servicebus
  summary: >-
    Set the prefetch count of the receiver. Prefetch speeds up the message flow by aiming to have a message readily available for local retrieval when and before the application asks for one using Receive. Setting a non-zero value prefetches PrefetchCount number of messages. Setting the value to zero turns prefetch off. For RECEIVEANDDELETE mode, the default value is 0. For PEEKLOCK mode, the default value is 100.


    The value cannot be set until the receiver is created.
  syntax:
    content: public abstract void setPrefetchCount(int prefetchCount)
    parameters:
    - id: prefetchCount
      type: int
      description: The desired prefetch count.
  exceptions:
  - type: com.microsoft.azure.servicebus.primitives.ServiceBusException
    description: if sets the value failed
references:
- uid: java.lang.InterruptedException
  spec.java:
  - uid: java.lang.InterruptedException
    name: InterruptedException
    fullName: java.lang.InterruptedException
- uid: com.microsoft.azure.servicebus.primitives.ServiceBusException
  name: ServiceBusException
  nameWithType: ServiceBusException
  fullName: com.microsoft.azure.servicebus.primitives.ServiceBusException
- uid: com.microsoft.azure.servicebus.IMessageHandler
  name: IMessageHandler
  nameWithType: IMessageHandler
  fullName: com.microsoft.azure.servicebus.IMessageHandler
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler*
  name: registerMessageHandler
  nameWithType: IMessageAndSessionPump.registerMessageHandler
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerMessageHandler
  package: com.microsoft.azure.servicebus
- uid: java.util.concurrent.ExecutorService
  spec.java:
  - uid: java.util.concurrent.ExecutorService
    name: ExecutorService
    fullName: java.util.concurrent.ExecutorService
- uid: com.microsoft.azure.servicebus.MessageHandlerOptions
  name: MessageHandlerOptions
  nameWithType: MessageHandlerOptions
  fullName: com.microsoft.azure.servicebus.MessageHandlerOptions
- uid: com.microsoft.azure.servicebus.ISessionHandler
  name: ISessionHandler
  nameWithType: ISessionHandler
  fullName: com.microsoft.azure.servicebus.ISessionHandler
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler*
  name: registerSessionHandler
  nameWithType: IMessageAndSessionPump.registerSessionHandler
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.registerSessionHandler
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.SessionHandlerOptions
  name: SessionHandlerOptions
  nameWithType: SessionHandlerOptions
  fullName: com.microsoft.azure.servicebus.SessionHandlerOptions
- uid: java.util.UUID
  spec.java:
  - uid: java.util.UUID
    name: UUID
    fullName: java.util.UUID
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon*
  name: abandon
  nameWithType: IMessageAndSessionPump.abandon
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandon
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.TransactionContext
  name: TransactionContext
  nameWithType: TransactionContext
  fullName: com.microsoft.azure.servicebus.TransactionContext
- uid: java.util.Map<java.lang.String,java.lang.Object>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: java.lang.String
    name: String
    fullName: java.lang.String
  - name: ','
    fullName: ','
  - uid: java.lang.Object
    name: Object
    fullName: java.lang.Object
  - name: '>'
    fullName: '>'
- uid: java.util.concurrent.CompletableFuture<java.lang.Void>
  spec.java:
  - uid: java.util.concurrent.CompletableFuture
    name: CompletableFuture
    fullName: java.util.concurrent.CompletableFuture
  - name: <
    fullName: <
  - uid: java.lang.Void
    name: Void
    fullName: java.lang.Void
  - name: '>'
    fullName: '>'
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync*
  name: abandonAsync
  nameWithType: IMessageAndSessionPump.abandonAsync
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.abandonAsync
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.complete*
  name: complete
  nameWithType: IMessageAndSessionPump.complete
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.complete
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.completeAsync*
  name: completeAsync
  nameWithType: IMessageAndSessionPump.completeAsync
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.completeAsync
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter*
  name: deadLetter
  nameWithType: IMessageAndSessionPump.deadLetter
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetter
  package: com.microsoft.azure.servicebus
- uid: java.lang.String
  spec.java:
  - uid: java.lang.String
    name: String
    fullName: java.lang.String
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync*
  name: deadLetterAsync
  nameWithType: IMessageAndSessionPump.deadLetterAsync
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.deadLetterAsync
  package: com.microsoft.azure.servicebus
- uid: int
  spec.java:
  - uid: int
    name: int
    fullName: int
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.getPrefetchCount*
  name: getPrefetchCount
  nameWithType: IMessageAndSessionPump.getPrefetchCount
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.getPrefetchCount
  package: com.microsoft.azure.servicebus
- uid: com.microsoft.azure.servicebus.IMessageAndSessionPump.setPrefetchCount*
  name: setPrefetchCount
  nameWithType: IMessageAndSessionPump.setPrefetchCount
  fullName: com.microsoft.azure.servicebus.IMessageAndSessionPump.setPrefetchCount
  package: com.microsoft.azure.servicebus
- uid: java.lang.String,java.lang.Object
  name: String,Object
  nameWithType: String,Object
  fullName: java.lang.String,java.lang.Object
- uid: java.util.Map
  name: Map
  nameWithType: Map
  fullName: java.util.Map
- uid: java.lang.Void
  name: Void
  nameWithType: Void
  fullName: java.lang.Void
- uid: java.util.concurrent.CompletableFuture
  name: CompletableFuture
  nameWithType: CompletableFuture
  fullName: java.util.concurrent.CompletableFuture
