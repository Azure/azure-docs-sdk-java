### YamlMime:JavaType
uid: "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool"
fullName: "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool"
name: "RntbdClientChannelPool"
nameWithType: "RntbdClientChannelPool"
summary: "A <xref uid=\"io.netty.channel.pool.ChannelPool\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ChannelPool\"></xref> implementation that enforces a maximum number of concurrent direct TCP Cosmos connections. RntbdClientChannelPool: Actors - acquire (RntbdServiceEndpoint): acquire a channel to use - release (RntbdServiceEndpoint): channel usage is complete and returning it back to pool - Channel.closeChannel() Future: Event handling notifying the channel termination to refresh bookkeeping - acquisitionTimeoutTimer: channel acquisition time-out handler - monitoring (through RntbdServiceEndpoint): get monitoring metrics Behaviors/Expectations: - Bounds: - max requests in-flight per channelPool: MAX\\_CHANNELS\\_PER\\_ENDPOINT \\* MAX\\_REQUESTS\\_ENDPOINT (NOT A GUARANTEE) - AvailableChannels.size() + AcquiredChannels.size() + (connections in connecting state, i.e., connecting.get()) <= MAX\\_CHANNELS\\_PER\\_ENDPOINT - PendingAcquisition queue default-size: Max(10\\_000, MAX\\_CHANNELS\\_PER\\_ENDPOINT \\* MAX\\_REQUESTS\\_ENDPOINT) - ChannelPool executor included event-loop task: MAX\\_CHANNELS\\_PER\\_ENDPOINT \\* MAX\\_REQUESTS\\_ENDPOINT + newInFlightAcquisitions (not yet in pendingAcquisitionQueue) - newInFlightAcquisitions: is expected to very very short. Hard-bound to ADMINSSON\\_CONTROL (upstream in RntbdServiceEndpoint) - NewChannel vs ReUseChannel: - NewChannels are serially created (reasonable current state, possible future change, upstream please DON'T TAKE any dependency) - Will re-use an existing channel when possible (with MAX\\_REQUESTS\\_ENDPOINT attempt not GUARANTEED) - Channel usage fairness: fairness is attempted but not guaranteed - When loadFactor is > 90%, fairness is attempted by selecting Channel with less concurrency - Otherwise no guarantees on fairness per channel with-in bounds of MAX\\_REQUESTS\\_ENDPOINT. I.e. some channel might have high request concurrency compared to others - Channel serving guarantees: - Ordered delivery is not guaranteed (by-design) - Fairness is attempted but not a guarantee - \\[UNRELATED TO CHANNEL-POOL\\] \\[CURRENT DESIGN\\]: RntbdServiceEndpoint.write releases Channel before its usage -> acquisition order and channel user order might differ. - AcquisitionTimeout: if not can't be served in an expected time, fails gracefully - Metrics: are approximations and might be in-consistent(by-design) as well - EventLoop - ChannelPool executor might be shared across ChannelPools or Channel Design Notes: - channelPool.eventLoop\\{@Link executor\\}: (executes on a single & same thread, serially) - Each channelPool gets an EventLoop (selection is round-robin) - Schedule only when it can be served immediately - Updates and reads that depend on \"strong consistency\" - like whether to create a new connection or not. - Updates to below data structures should be done only when inside eventLoop - \\{@Link acquiredChannels\\} - \\{@Link availableChannels\\} - AcquisitionTimeout handling: - A global single threaded scheduler - \\[\\*\\*\\*\\] Each channel independently schedules acquisitionTimeout handlers - touches \\{@Link pendingAcquisitions\\} might result in impacting the fairness - RntbdServiceEndpoint.write: - Promise might AcquisitionTimeout - RntbdServiceEndpoint.writeWhenConnected - releaseToPool immediately -> unblocks next acquisition if-any - \\*\\*Uses Channel even after release\\*\\*, in channelEventLoop \\[Not a functional issue but to be noted\\] - Possible that acquisition order might differ the ChannelWrite order - MAX\\_REQUESTS\\_ENDPOINT: Truth managed by RntbdRequestManager in Channel.Pipeline - RequestManager only known when the Channel process them. - In-flight scheduled ones are unknown -> its a SOFT BOUND"
inheritances:
- "<xref href=\"java.lang.Object\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
syntax: "public final class RntbdClientChannelPool implements ChannelPool"
methods:
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.acquire()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.acquire(com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdChannelAcquisitionTimeline)"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.acquire(io.netty.util.concurrent.Promise<io.netty.channel.Channel>)"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.attemptingToConnectMetrics()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.channels(boolean)"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.channelsAcquiredMetrics()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.channelsAvailableMetrics()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.close()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.executorTaskQueueMetrics()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.isClosed()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.maxChannels()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.maxRequestsPerChannel()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.release(io.netty.channel.Channel)"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.release(io.netty.channel.Channel,io.netty.util.concurrent.Promise<java.lang.Void>)"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.remoteAddress()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.requestQueueLength()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.toString()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.usedDirectMemory()"
- "com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdClientChannelPool.usedHeapMemory()"
type: "class"
implements:
- "<xref href=\"io.netty.channel.pool.ChannelPool?alt=io.netty.channel.pool.ChannelPool&text=ChannelPool\" data-throw-if-not-resolved=\"False\" />"
metadata: {}
package: "com.azure.cosmos.implementation.directconnectivity.rntbd"
artifact: com.azure:azure-cosmos:4.25.0
