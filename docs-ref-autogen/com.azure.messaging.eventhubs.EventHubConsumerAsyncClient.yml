### YamlMime:JavaType
uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient"
fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient"
name: "EventHubConsumerAsyncClient"
nameWithType: "EventHubConsumerAsyncClient"
summary: "An **asynchronous** consumer responsible for reading <xref uid=\"com.azure.messaging.eventhubs.EventData\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventData\"></xref> from either a specific Event Hub partition or all partitions in the context of a specific consumer group."
inheritances:
- "<xref href=\"java.lang.Object?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
inheritedClassMethods:
- classRef: "java.lang.<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html\">Object</a>"
  methodsRef:
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--\">clone</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-\">equals</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize--\">finalize</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--\">getClass</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--\">hashCode</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify--\">notify</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll--\">notifyAll</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--\">toString</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--\">wait</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait-long-\">wait</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait-long-int-\">wait</a>"
syntax: "public class **EventHubConsumerAsyncClient**</br> implements <a href=\"https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html\">Closeable</a>"
methods:
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.close()"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.close()"
  name: "close()"
  nameWithType: "EventHubConsumerAsyncClient.close()"
  summary: "Disposes of the consumer by closing the underlying connection to the service."
  syntax: "public void close()"
  desc: "Disposes of the consumer by closing the underlying connection to the service."
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getConsumerGroup()"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getConsumerGroup()"
  name: "getConsumerGroup()"
  nameWithType: "EventHubConsumerAsyncClient.getConsumerGroup()"
  summary: "Gets the consumer group this consumer is reading events as a part of."
  syntax: "public String getConsumerGroup()"
  desc: "Gets the consumer group this consumer is reading events as a part of."
  returns:
    description: "The consumer group this consumer is reading events as a part of."
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getEventHubName()"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getEventHubName()"
  name: "getEventHubName()"
  nameWithType: "EventHubConsumerAsyncClient.getEventHubName()"
  summary: "Gets the Event Hub name this client interacts with."
  syntax: "public String getEventHubName()"
  desc: "Gets the Event Hub name this client interacts with."
  returns:
    description: "The Event Hub name this client interacts with."
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getEventHubProperties()"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getEventHubProperties()"
  name: "getEventHubProperties()"
  nameWithType: "EventHubConsumerAsyncClient.getEventHubProperties()"
  summary: "Retrieves information about an Event Hub, including the number of partitions present and their identifiers."
  syntax: "public Mono<EventHubProperties> getEventHubProperties()"
  desc: "Retrieves information about an Event Hub, including the number of partitions present and their identifiers."
  returns:
    description: "The set of information for the Event Hub that this client is associated with."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.messaging.eventhubs.EventHubProperties?alt=com.azure.messaging.eventhubs.EventHubProperties&text=EventHubProperties\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getFullyQualifiedNamespace()"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getFullyQualifiedNamespace()"
  name: "getFullyQualifiedNamespace()"
  nameWithType: "EventHubConsumerAsyncClient.getFullyQualifiedNamespace()"
  summary: "Gets the fully qualified Event Hubs namespace that the connection is associated with."
  syntax: "public String getFullyQualifiedNamespace()"
  desc: "Gets the fully qualified Event Hubs namespace that the connection is associated with. This is likely similar to `{yournamespace}.servicebus.windows.net`."
  returns:
    description: "The fully qualified Event Hubs namespace that the connection is associated with"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getIdentifier()"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getIdentifier()"
  name: "getIdentifier()"
  nameWithType: "EventHubConsumerAsyncClient.getIdentifier()"
  summary: "Gets the client identifier."
  syntax: "public String getIdentifier()"
  desc: "Gets the client identifier."
  returns:
    description: "The unique identifier string for current client."
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getPartitionIds()"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getPartitionIds()"
  name: "getPartitionIds()"
  nameWithType: "EventHubConsumerAsyncClient.getPartitionIds()"
  summary: "Retrieves the identifiers for the partitions of an Event Hub."
  syntax: "public Flux<String> getPartitionIds()"
  desc: "Retrieves the identifiers for the partitions of an Event Hub."
  returns:
    description: "A Flux of identifiers for the partitions of an Event Hub."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\">Flux</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>&gt;"
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getPartitionProperties(java.lang.String)"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.getPartitionProperties(String partitionId)"
  name: "getPartitionProperties(String partitionId)"
  nameWithType: "EventHubConsumerAsyncClient.getPartitionProperties(String partitionId)"
  summary: "Retrieves information about a specific partition for an Event Hub, including elements that describe the available events in the partition event stream."
  parameters:
  - description: "The unique identifier of a partition associated with the Event Hub."
    name: "partitionId"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  syntax: "public Mono<PartitionProperties> getPartitionProperties(String partitionId)"
  desc: "Retrieves information about a specific partition for an Event Hub, including elements that describe the available events in the partition event stream."
  returns:
    description: "The set of information for the requested partition under the Event Hub this client is associated with."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.messaging.eventhubs.PartitionProperties?alt=com.azure.messaging.eventhubs.PartitionProperties&text=PartitionProperties\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receive()"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receive()"
  name: "receive()"
  nameWithType: "EventHubConsumerAsyncClient.receive()"
  summary: "Consumes events from all partitions starting from the beginning of each partition."
  syntax: "public Flux<PartitionEvent> receive()"
  desc: "Consumes events from all partitions starting from the beginning of each partition.\n\nThis method is **not** recommended for production use; the <xref uid=\"com.azure.messaging.eventhubs.EventProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventProcessorClient\"></xref> should be used for reading events from all partitions in a production scenario, as it offers a much more robust experience with higher throughput. It is important to note that this method does not guarantee fairness amongst the partitions. Depending on service communication, there may be a clustering of events per partition and/or there may be a noticeable bias for a given partition or subset of partitions."
  returns:
    description: "A stream of events for every partition in the Event Hub starting from the beginning of each partition."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\">Flux</a>&lt;<xref href=\"com.azure.messaging.eventhubs.models.PartitionEvent?alt=com.azure.messaging.eventhubs.models.PartitionEvent&text=PartitionEvent\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receive(boolean)"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receive(boolean startReadingAtEarliestEvent)"
  name: "receive(boolean startReadingAtEarliestEvent)"
  nameWithType: "EventHubConsumerAsyncClient.receive(boolean startReadingAtEarliestEvent)"
  summary: "Consumes events from all partitions."
  parameters:
  - description: "<code>true</code> to begin reading at the first events available in each\n     partition; otherwise, reading will begin at the end of each partition seeing only new events as they are\n     published."
    name: "startReadingAtEarliestEvent"
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Flux<PartitionEvent> receive(boolean startReadingAtEarliestEvent)"
  desc: "Consumes events from all partitions.\n\nThis method is **not** recommended for production use; the <xref uid=\"com.azure.messaging.eventhubs.EventProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventProcessorClient\"></xref> should be used for reading events from all partitions in a production scenario, as it offers a much more robust experience with higher throughput. It is important to note that this method does not guarantee fairness amongst the partitions. Depending on service communication, there may be a clustering of events per partition and/or there may be a noticeable bias for a given partition or subset of partitions."
  returns:
    description: "A stream of events for every partition in the Event Hub."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\">Flux</a>&lt;<xref href=\"com.azure.messaging.eventhubs.models.PartitionEvent?alt=com.azure.messaging.eventhubs.models.PartitionEvent&text=PartitionEvent\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receive(boolean,com.azure.messaging.eventhubs.models.ReceiveOptions)"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receive(boolean startReadingAtEarliestEvent, ReceiveOptions receiveOptions)"
  name: "receive(boolean startReadingAtEarliestEvent, ReceiveOptions receiveOptions)"
  nameWithType: "EventHubConsumerAsyncClient.receive(boolean startReadingAtEarliestEvent, ReceiveOptions receiveOptions)"
  summary: "Consumes events from all partitions configured with a set of `receiveOptions`."
  parameters:
  - description: "<code>true</code> to begin reading at the first events available in each\n     partition; otherwise, reading will begin at the end of each partition seeing only new events as they are\n     published."
    name: "startReadingAtEarliestEvent"
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
  - description: "Options when receiving events from each Event Hub partition."
    name: "receiveOptions"
    type: "<xref href=\"com.azure.messaging.eventhubs.models.ReceiveOptions?alt=com.azure.messaging.eventhubs.models.ReceiveOptions&text=ReceiveOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Flux<PartitionEvent> receive(boolean startReadingAtEarliestEvent, ReceiveOptions receiveOptions)"
  desc: "Consumes events from all partitions configured with a set of `receiveOptions`.\n\nThis method is **not** recommended for production use; the <xref uid=\"com.azure.messaging.eventhubs.EventProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventProcessorClient\"></xref> should be used for reading events from all partitions in a production scenario, as it offers a much more robust experience with higher throughput. It is important to note that this method does not guarantee fairness amongst the partitions. Depending on service communication, there may be a clustering of events per partition and/or there may be a noticeable bias for a given partition or subset of partitions.\n\n *  If receive is invoked where <xref uid=\"com.azure.messaging.eventhubs.models.ReceiveOptions.getOwnerLevel()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ReceiveOptions#getOwnerLevel()\"></xref> has a value, then Event Hubs service will guarantee only one active consumer exists per partitionId and consumer group combination. This receive operation is sometimes referred to as an \"Epoch Consumer\".\n *  Multiple consumers per partitionId and consumer group combination can be created by not setting <xref uid=\"com.azure.messaging.eventhubs.models.ReceiveOptions.getOwnerLevel()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ReceiveOptions#getOwnerLevel()\"></xref> when invoking receive operations. This non-exclusive consumer is sometimes referred to as a \"Non-Epoch Consumer.\""
  returns:
    description: "A stream of events for every partition in the Event Hub."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\">Flux</a>&lt;<xref href=\"com.azure.messaging.eventhubs.models.PartitionEvent?alt=com.azure.messaging.eventhubs.models.PartitionEvent&text=PartitionEvent\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receiveFromPartition(java.lang.String,com.azure.messaging.eventhubs.models.EventPosition)"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receiveFromPartition(String partitionId, EventPosition startingPosition)"
  name: "receiveFromPartition(String partitionId, EventPosition startingPosition)"
  nameWithType: "EventHubConsumerAsyncClient.receiveFromPartition(String partitionId, EventPosition startingPosition)"
  summary: "Consumes events from a single partition starting at `startingPosition`."
  parameters:
  - description: "Identifier of the partition to read events from."
    name: "partitionId"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "Position within the Event Hub partition to begin consuming events."
    name: "startingPosition"
    type: "<xref href=\"com.azure.messaging.eventhubs.models.EventPosition?alt=com.azure.messaging.eventhubs.models.EventPosition&text=EventPosition\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Flux<PartitionEvent> receiveFromPartition(String partitionId, EventPosition startingPosition)"
  desc: "Consumes events from a single partition starting at `startingPosition`."
  returns:
    description: "A stream of events for this partition starting from <code>startingPosition</code>."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\">Flux</a>&lt;<xref href=\"com.azure.messaging.eventhubs.models.PartitionEvent?alt=com.azure.messaging.eventhubs.models.PartitionEvent&text=PartitionEvent\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receiveFromPartition(java.lang.String,com.azure.messaging.eventhubs.models.EventPosition,com.azure.messaging.eventhubs.models.ReceiveOptions)"
  fullName: "com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receiveFromPartition(String partitionId, EventPosition startingPosition, ReceiveOptions receiveOptions)"
  name: "receiveFromPartition(String partitionId, EventPosition startingPosition, ReceiveOptions receiveOptions)"
  nameWithType: "EventHubConsumerAsyncClient.receiveFromPartition(String partitionId, EventPosition startingPosition, ReceiveOptions receiveOptions)"
  summary: "Consumes events from a single partition starting at `startingPosition` with a set of <xref uid=\"com.azure.messaging.eventhubs.models.ReceiveOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"receive options\"></xref>."
  parameters:
  - description: "Identifier of the partition to read events from."
    name: "partitionId"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "Position within the Event Hub partition to begin consuming events."
    name: "startingPosition"
    type: "<xref href=\"com.azure.messaging.eventhubs.models.EventPosition?alt=com.azure.messaging.eventhubs.models.EventPosition&text=EventPosition\" data-throw-if-not-resolved=\"False\" />"
  - description: "Options when receiving events from the partition."
    name: "receiveOptions"
    type: "<xref href=\"com.azure.messaging.eventhubs.models.ReceiveOptions?alt=com.azure.messaging.eventhubs.models.ReceiveOptions&text=ReceiveOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Flux<PartitionEvent> receiveFromPartition(String partitionId, EventPosition startingPosition, ReceiveOptions receiveOptions)"
  desc: "Consumes events from a single partition starting at `startingPosition` with a set of <xref uid=\"com.azure.messaging.eventhubs.models.ReceiveOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"receive options\"></xref>.\n\n *  If receive is invoked where <xref uid=\"com.azure.messaging.eventhubs.models.ReceiveOptions.getOwnerLevel()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ReceiveOptions#getOwnerLevel()\"></xref> has a value, then Event Hubs service will guarantee only one active consumer exists per partitionId and consumer group combination. This receive operation is sometimes referred to as an \"Epoch Consumer\".\n *  Multiple consumers per partitionId and consumer group combination can be created by not setting <xref uid=\"com.azure.messaging.eventhubs.models.ReceiveOptions.getOwnerLevel()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ReceiveOptions#getOwnerLevel()\"></xref> when invoking receive operations. This non-exclusive consumer is sometimes referred to as a \"Non-Epoch Consumer.\""
  returns:
    description: "A stream of events for this partition. If a stream for the events was opened before, the same position\n     within that partition is returned. Otherwise, events are read starting from <code>startingPosition</code>."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\">Flux</a>&lt;<xref href=\"com.azure.messaging.eventhubs.models.PartitionEvent?alt=com.azure.messaging.eventhubs.models.PartitionEvent&text=PartitionEvent\" data-throw-if-not-resolved=\"False\" />&gt;"
type: "class"
desc: "An **asynchronous** consumer responsible for reading <xref uid=\"com.azure.messaging.eventhubs.EventData\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventData\"></xref> from either a specific Event Hub partition or all partitions in the context of a specific consumer group.\n\nThe examples shown in this document use a credential object named DefaultAzureCredential for authentication, which is appropriate for most scenarios, including local development and production environments. Additionally, we recommend using [managed identity][] for authentication in production environments. You can find more information on different ways of authenticating and their corresponding credential types in the [Azure Identity documentation\"][Azure Identity documentation].\n\n**Sample: Creating an <xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventHubConsumerAsyncClient\"></xref>**\n\nThe following code sample demonstrates the creation of the asynchronous client <xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventHubConsumerAsyncClient\"></xref>. The `fullyQualifiedNamespace` is the Event Hubs Namespace's host name. It is listed under the \"Essentials\" panel after navigating to the Event Hubs Namespace via Azure Portal. The `consumerGroup` is found by navigating to the Event Hub instance, and selecting \"Consumer groups\" under the \"Entities\" panel. The <xref uid=\"com.azure.messaging.eventhubs.EventHubClientBuilder.consumerGroup(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventHubClientBuilder#consumerGroup(String)\"></xref> is required for creating consumer clients. The credential used is `DefaultAzureCredential` because it combines commonly used credentials in deployment and development and chooses the credential to used based on its running environment.\n\n```java\nTokenCredential credential = new DefaultAzureCredentialBuilder().build();\n\n // \"<<fully-qualified-namespace>>\" will look similar to \"{your-namespace}.servicebus.windows.net\"\n // \"<<event-hub-name>>\" will be the name of the Event Hub instance you created inside the Event Hubs namespace.\n EventHubProducerAsyncClient producer = new EventHubClientBuilder()\n     .credential(\"<<fully-qualified-namespace>>\", \"<<event-hub-name>>\",\n         credential)\n     .buildAsyncProducerClient();\n```\n\n**Sample: Consuming events a single partition from Event Hub**\n\nThe code sample below demonstrates receiving events from partition \"0\" of an Event Hub starting from <xref uid=\"com.azure.messaging.eventhubs.models.EventPosition.latest()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventPosition#latest()\"></xref>. <xref uid=\"com.azure.messaging.eventhubs.models.EventPosition.latest()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventPosition#latest()\"></xref> points to the end of the partition stream. The consumer receives events enqueued *after* it started subscribing for events.\n\n<xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receiveFromPartition(java.lang.String,com.azure.messaging.eventhubs.models.EventPosition)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#receiveFromPartition(String, EventPosition)\"></xref> is a non-blocking call. After setting up the operation, its async representation is returned. The `Flux` must be subscribed to, like the sample below, to start receiving events.\n\n```java\nEventHubConsumerAsyncClient consumer = new EventHubClientBuilder()\n     .credential(\"<<fully-qualified-namespace>>\", \"<<event-hub-name>>\",\n         new DefaultAzureCredentialBuilder().build())\n     .consumerGroup(EventHubClientBuilder.DEFAULT_CONSUMER_GROUP_NAME)\n     .buildAsyncConsumerClient();\n\n // Obtain partitionId from EventHubConsumerAsyncClient.getPartitionIds()\n String partitionId = \"0\";\n EventPosition startingPosition = EventPosition.latest();\n\n // Keep a reference to `subscription`. When the program is finished receiving events, call\n // subscription.dispose(). This will stop fetching events from the Event Hub.\n //\n // NOTE: This is a non-blocking call and will move to the next line of code after setting up the async\n // operation.  If the program ends after this, or the class is immediately disposed, no events will be\n // received.\n Disposable subscription = consumer.receiveFromPartition(partitionId, startingPosition)\n     .subscribe(partitionEvent -> {\n         PartitionContext partitionContext = partitionEvent.getPartitionContext();\n         EventData event = partitionEvent.getData();\n\n         System.out.printf(\"Received event from partition '%s'%n\", partitionContext.getPartitionId());\n         System.out.printf(\"Contents of event as string: '%s'%n\", event.getBodyAsString());\n     }, error -> {\n         // This is a terminal signal.  No more events will be received from the same Flux object.\n         System.err.print(\"An error occurred:\" + error);\n     }, () -> {\n         // This is a terminal signal.  No more events will be received from the same Flux object.\n         System.out.print(\"Stream has ended.\");\n     });\n```\n\n**Sample: Including latest partition information in received events**\n\n<xref uid=\"com.azure.messaging.eventhubs.EventData\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventData\"></xref> can be decorated with the latest partition information and sent to consumers. Enable this by setting <xref uid=\"com.azure.messaging.eventhubs.models.ReceiveOptions.setTrackLastEnqueuedEventProperties(boolean)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ReceiveOptions#setTrackLastEnqueuedEventProperties(boolean)\"></xref> to `true`. As events come in, explore the <xref uid=\"com.azure.messaging.eventhubs.models.PartitionEvent\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PartitionEvent\"></xref> object. This is useful in scenarios where customers want to constant up-to-date information about their Event Hub. This does take a performance hit as the extra partition information must be sent over the wire with every event.\n\n<xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receiveFromPartition(java.lang.String,com.azure.messaging.eventhubs.models.EventPosition,com.azure.messaging.eventhubs.models.ReceiveOptions)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#receiveFromPartition(String, EventPosition, ReceiveOptions)\"></xref> is a non-blocking call. After setting up the operation, its async representation is returned. The `Flux` must be subscribed to, like sample below, to start receiving events.\n\n```java\n// Set `setTrackLastEnqueuedEventProperties` to true to get the last enqueued information from the partition for\n // each event that is received.\n ReceiveOptions receiveOptions = new ReceiveOptions()\n     .setTrackLastEnqueuedEventProperties(true);\n EventPosition startingPosition = EventPosition.earliest();\n\n // Receives events from partition \"0\" starting at the beginning of the stream.\n // Keep a reference to `subscription`. When the program is finished receiving events, call\n // subscription.dispose(). This will stop fetching events from the Event Hub.\n Disposable subscription = consumer.receiveFromPartition(\"0\", startingPosition, receiveOptions)\n     .subscribe(partitionEvent -> {\n         LastEnqueuedEventProperties properties = partitionEvent.getLastEnqueuedEventProperties();\n         System.out.printf(\"Information received at %s. Last enqueued sequence number: %s%n\",\n             properties.getRetrievalTime(),\n             properties.getSequenceNumber());\n     });\n```\n\n**Sample: Rate limiting consumption of events from Event Hub**\n\nFor event consumers that need to limit the number of events they receive at a given time, they can use <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BaseSubscriber#request(long)\"></xref>. Using a custom subscriber allows developers more granular control over the rate at which they receive events.\n\n<xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receiveFromPartition(java.lang.String,com.azure.messaging.eventhubs.models.EventPosition)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#receiveFromPartition(String, EventPosition)\"></xref> is a non-blocking call. After setting up the operation, its async representation is returned. The `Flux` must be subscribed to, like the sample below, to start receiving events.\n\n```java\nconsumer.receiveFromPartition(partitionId, EventPosition.latest()).subscribe(new BaseSubscriber<PartitionEvent>() {\n     private static final int NUMBER_OF_EVENTS = 5;\n     private final AtomicInteger currentNumberOfEvents = new AtomicInteger();\n\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n         // Tell the Publisher we only want 5 events at a time.\n         request(NUMBER_OF_EVENTS);\n     }\n\n     @Override\n     protected void hookOnNext(PartitionEvent value) {\n         // Process the EventData\n\n         // If the number of events we have currently received is a multiple of 5, that means we have reached the\n         // last event the Publisher will provide to us. Invoking request(long) here, tells the Publisher that\n         // the subscriber is ready to get more events from upstream.\n         if (currentNumberOfEvents.incrementAndGet() % 5 == 0) {\n             request(NUMBER_OF_EVENTS);\n         }\n     }\n });\n```\n\n**Sample: Receiving from all partitions**\n\nThe code sample below demonstrates receiving events from all partitions of an Event Hub starting the beginning of each partition's stream. This is valuable for demo purposes but *is not* intended for production scenarios. For production scenarios, consider using <xref uid=\"com.azure.messaging.eventhubs.EventProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"EventProcessorClient\"></xref>.\n\n<xref uid=\"com.azure.messaging.eventhubs.EventHubConsumerAsyncClient.receive(boolean)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#receive(boolean)\"></xref> is a non-blocking call. After setting up the operation, its async representation is returned. The `Flux` must be subscribed to, like the sample below, to start receiving events.\n\n```java\n// Keep a reference to `subscription`. When the program is finished receiving events, call\n // subscription.dispose(). This will stop fetching events from the Event Hub.\n Disposable subscription = consumer.receive(true)\n     .subscribe(partitionEvent -> {\n         PartitionContext context = partitionEvent.getPartitionContext();\n         EventData event = partitionEvent.getData();\n\n         System.out.printf(\"Event %s is from partition %s%n.\", event.getSequenceNumber(),\n             context.getPartitionId());\n     }, error -> {\n         // This is a terminal signal.  No more events will be received from the same Flux object.\n         System.err.print(\"An error occurred:\" + error);\n     }, () -> {\n         // This is a terminal signal.  No more events will be received from the same Flux object.\n         System.out.print(\"Stream has ended.\");\n     });\n```\n\n\n[managed identity]: https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/\n[Azure Identity documentation]: https://learn.microsoft.com/java/api/overview/azure/identity-readme"
implements:
- "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html\">Closeable</a>"
metadata: {}
package: "com.azure.messaging.eventhubs"
artifact: com.azure:azure-messaging-eventhubs:5.20.3
