### YamlMime:JavaType
uid: "com.azure.storage.file.datalake.models.PathAccessControlEntry"
fullName: "com.azure.storage.file.datalake.models.PathAccessControlEntry"
name: "PathAccessControlEntry"
nameWithType: "PathAccessControlEntry"
summary: "POSIX access control rights on files and directories.\n\nThe value is a comma-separated list of access control entries, each access control entry (ACE) consists of four elements in the format \"\\[scope:\\]\\[type\\]:\\[id\\]:\\[permissions\\]\":\n\n *  Scope\n *  Type\n *  User or Group Identifier (AAD ObjectId)\n *  Permissions\n\nThe scope must be \"default\" to indicate the ACE belongs to the default Access Control List (ACL) for a directory; otherwise scope is implicit and the ACE belongs to the access ACL.\n\nThere are four ACE types:\n\n *  \"user\": grants rights to the owner or a named user\n *  \"group\" grants rights to the owning group or a named group\n *  \"mask\" restricts rights granted to named users and the members of groups\n *  \"other\" grants rights to all users not found in any of the other entries\n\nThe user or group identifier is omitted for entries of type \"mask\" and \"other\". The user or group identifier is also omitted for the owner and owning group.\n\nThe permission field is a 3-character sequence where the first character is 'r' to grant read access, the second character is 'w' to grant write access, and the third character is 'x' to grant execute permission. If access is not granted, the '-' character is used to denote that the permission is denied.\n\nFor example, the following ACL grants read, write, and execute rights to the file owner and john.doe@contoso, the read right to the owning group, and nothing to everyone else: \"user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask::rwx\"."
inheritances:
- "<xref href=\"java.lang.Object\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
syntax: "public class PathAccessControlEntry"
constructors:
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.PathAccessControlEntry()"
methods:
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.equals(java.lang.Object)"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.getAccessControlType()"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.getEntityId()"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.getPermissions()"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.hashCode()"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.isInDefaultScope()"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.parse(java.lang.String)"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.parseList(java.lang.String)"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.serializeList(java.util.List<com.azure.storage.file.datalake.models.PathAccessControlEntry>)"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.setAccessControlType(com.azure.storage.file.datalake.models.AccessControlType)"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.setDefaultScope(boolean)"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.setEntityId(java.lang.String)"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.setPermissions(com.azure.storage.file.datalake.models.RolePermissions)"
- "com.azure.storage.file.datalake.models.PathAccessControlEntry.toString()"
type: "class"
metadata: {}
package: "com.azure.storage.file.datalake.models"
artifact: com.azure:azure-storage-file-datalake:12.2.0
