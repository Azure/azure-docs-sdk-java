### YamlMime:JavaPackage
uid: "com.azure.messaging.servicebus"
fullName: "com.azure.messaging.servicebus"
name: "com.azure.messaging.servicebus"
summary: "<p>The Azure Service Bus client library allows Java developers to interact with Azure Service Bus entities by\n publishing to and/or subscribing from queues and topics/subscriptions."
classes:
- "com.azure.messaging.servicebus.ServiceBusClientBuilder"
- "com.azure.messaging.servicebus.ServiceBusClientBuilder.ServiceBusProcessorClientBuilder"
- "com.azure.messaging.servicebus.ServiceBusClientBuilder.ServiceBusReceiverClientBuilder"
- "com.azure.messaging.servicebus.ServiceBusClientBuilder.ServiceBusRuleManagerBuilder"
- "com.azure.messaging.servicebus.ServiceBusClientBuilder.ServiceBusSenderClientBuilder"
- "com.azure.messaging.servicebus.ServiceBusClientBuilder.ServiceBusSessionProcessorClientBuilder"
- "com.azure.messaging.servicebus.ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder"
- "com.azure.messaging.servicebus.ServiceBusConnectionStringProperties"
- "com.azure.messaging.servicebus.ServiceBusErrorContext"
- "com.azure.messaging.servicebus.ServiceBusErrorSource"
- "com.azure.messaging.servicebus.ServiceBusException"
- "com.azure.messaging.servicebus.ServiceBusFailureReason"
- "com.azure.messaging.servicebus.ServiceBusMessage"
- "com.azure.messaging.servicebus.ServiceBusMessageBatch"
- "com.azure.messaging.servicebus.ServiceBusProcessorClient"
- "com.azure.messaging.servicebus.ServiceBusReceivedMessage"
- "com.azure.messaging.servicebus.ServiceBusReceivedMessageContext"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
- "com.azure.messaging.servicebus.ServiceBusReceiverClient"
- "com.azure.messaging.servicebus.ServiceBusRuleManagerAsyncClient"
- "com.azure.messaging.servicebus.ServiceBusRuleManagerClient"
- "com.azure.messaging.servicebus.ServiceBusSenderAsyncClient"
- "com.azure.messaging.servicebus.ServiceBusSenderClient"
- "com.azure.messaging.servicebus.ServiceBusSessionReceiverAsyncClient"
- "com.azure.messaging.servicebus.ServiceBusSessionReceiverClient"
- "com.azure.messaging.servicebus.ServiceBusTransactionContext"
enums:
- "com.azure.messaging.servicebus.ServiceBusServiceVersion"
desc: "<p>The Azure Service Bus client library allows Java developers to interact with Azure Service Bus entities by\n publishing to and/or subscribing from queues and topics/subscriptions.\n <a href=\"https://docs.microsoft.com/azure/service-bus-messaging\">Microsoft Azure Service Bus</a> is a fully\n managed enterprise integration message broker. Service Bus can decouple applications and services. Service Bus\n offers a reliable and secure platform for asynchronous transfer of data and state. Data is transferred between\n different applications and services using messages.</p>\n\n <h2>Key Concepts</h2>\n\n <ul>\n     <li><strong>\n     <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview#queues\">Queue</a>\n     :</strong>  Allows for the sending and receiving of messages, ordered first-in-first-out(FIFO).  It is often\n     used for point to point communication.</li>\n\n     <li><strong>\n     <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview#topics\">Topic</a>\n     :</strong>  Allows for sending messages to multiple receivers, simultaneously.  This is suited for publisher and\n     subscriber scenarios.</li>\n\n     <li><strong>\n     <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/service-bus-queues-topics-subscriptions#topics-and-subscriptions\">\n     Subscription</a>:</strong>  Receives messages from a topic.  Each subscription is independent and receives a\n     copy of every message sent to the topic.  Each subscription has a filter.  Filters, also known as rules, are\n     applied to each message to determine whether they will be published to the subscription.</li>\n </ul>\n\n <h2>Getting Started</h2>\n\n <p>Service clients are the point of interaction for developers to use Azure Event Hubs.\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusSenderClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusSenderClient\"></xref> and\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusSenderAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusSenderAsyncClient\"></xref> are the sync and async\n clients for publishing messages to a Service Bus queue or topic.  Similarly,\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusReceiverClient\"></xref> and\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\"></xref> are the sync and async clients for consuming\n messages from a Service Bus queue or topic.  In production scenarios, we recommend customers leverage\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusProcessorClient\"></xref> for consuming messages because recovers from\n transient failures.</p>\n\n <p>The examples shown in this document use a credential object named DefaultAzureCredential for authentication,\n which is appropriate for most scenarios, including local development and production environments. Additionally, we\n recommend using\n <a href=\"https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/\">managed identity</a>\n for authentication in production environments. You can find more information on different ways of authenticating and\n their corresponding credential types in the\n <a href=\"https://learn.microsoft.com/java/api/overview/azure/identity-readme\">Azure Identity documentation</a>.\n </p>\n\n <h3>Publishing Service Bus messages</h3>\n\n <p>This library provides two sender clients to publish messages to Azure Service Bus.  The async client,\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusSenderAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusSenderAsyncClient\"></xref> and its sync version,\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusSenderClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusSenderClient\"></xref>.  The samples below demonstrate basic scenarios,\n additional snippets can be found in the class documentation for\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusClientBuilder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusClientBuilder\"></xref> and any of the clients.</p>\n\n <p><strong>Sample: Construct a synchronous sender and send messages</strong></p>\n\n <p>The following code sample demonstrates the creation and use of the synchronous client\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusSenderClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusSenderClient\"></xref> to send messages to a queue.  When performance is\n important, consider using <xref uid=\"com.azure.messaging.servicebus.ServiceBusMessageBatch\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusMessageBatch\"></xref> to publish multiple messages\n at once.</p>\n\n <!-- src_embed com.azure.messaging.servicebus.servicebussenderclient.createMessageBatch -->\n <pre>\n TokenCredential credential = new DefaultAzureCredentialBuilder&#40;&#41;.build&#40;&#41;;\n\n &#47;&#47; 'fullyQualifiedNamespace' will look similar to &quot;&#123;your-namespace&#125;.servicebus.windows.net&quot;\n ServiceBusSenderClient sender = new ServiceBusClientBuilder&#40;&#41;\n     .credential&#40;fullyQualifiedNamespace, credential&#41;\n     .sender&#40;&#41;\n     .queueName&#40;queueName&#41;\n     .buildClient&#40;&#41;;\n\n List&lt;ServiceBusMessage&gt; messages = Arrays.asList&#40;\n     new ServiceBusMessage&#40;&quot;test-1&quot;&#41;,\n     new ServiceBusMessage&#40;&quot;test-2&quot;&#41;&#41;;\n\n &#47;&#47; Creating a batch without options set.\n ServiceBusMessageBatch batch = sender.createMessageBatch&#40;&#41;;\n for &#40;ServiceBusMessage message : messages&#41; &#123;\n     if &#40;batch.tryAddMessage&#40;message&#41;&#41; &#123;\n         continue;\n     &#125;\n\n     &#47;&#47; The batch is full. Send the current batch and create a new one.\n     sender.sendMessages&#40;batch&#41;;\n\n     batch = sender.createMessageBatch&#40;&#41;;\n\n     &#47;&#47; Add the message we couldn't before.\n     if &#40;!batch.tryAddMessage&#40;message&#41;&#41; &#123;\n         throw new IllegalArgumentException&#40;&quot;Message is too large for an empty batch.&quot;&#41;;\n     &#125;\n &#125;\n\n &#47;&#47; Send the final batch if there are any messages in it.\n if &#40;batch.getCount&#40;&#41; &gt; 0&#41; &#123;\n     sender.sendMessages&#40;batch&#41;;\n &#125;\n\n &#47;&#47; Continue using the sender and finally, dispose of the sender.\n &#47;&#47; Clients should be long-lived objects as they require resources\n &#47;&#47; and time to establish a connection to the service.\n sender.close&#40;&#41;;\n </pre>\n <!-- end com.azure.messaging.servicebus.servicebussenderclient.createMessageBatch -->\n\n <h3>Receiving Service Bus messages</h3>\n\n <p>This library provides several clients to receive messages from Azure Service Bus.  The async client,\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\"></xref> and its sync version,\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusReceiverClient\"></xref>.  For session-enabled entities, there is\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusSessionReceiverAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusSessionReceiverAsyncClient\"></xref> and\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusSessionReceiverClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusSessionReceiverClient\"></xref>.  In production scenarios,\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusProcessorClient\"></xref> is recommended because it recovers from transient\n errors such as temporary network failures.</p>\n\n <p>The samples below demonstrate basic scenarios, additional snippets can be found in the class documentation.</p>\n\n <p><strong>Sample: Create a ServiceBusProcessorClient and receive messages</strong></p>\n\n <p>The following code sample demonstrates the creation and use of the synchronous client\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusProcessorClient\"></xref> to receive messages from a Service Bus queue.\n By default, messages are received using <xref uid=\"com.azure.messaging.servicebus.models.ServiceBusReceiveMode#PEEK_LOCK\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.models.ServiceBusReceiveMode#PEEK_LOCK\"></xref>\n and customers must settle their messages using one of the settlement methods on the receiver client.\n \"<a href=\"https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\">\n     \"Settling receive operations</a>\" provides additional information about message settlement.\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusProcessorClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusProcessorClient\"></xref> continues fetching messages from the queue until\n the processor is stopped.  If it encounters a transient error, it will try to recover, then continue processing\n messages.</p>\n\n <!-- src_embed com.azure.messaging.servicebus.servicebusprocessorclient#receive-mode-peek-lock-instantiation -->\n <pre>\n &#47;&#47; Function that gets called whenever a message is received.\n Consumer&lt;ServiceBusReceivedMessageContext&gt; processMessage = context -&gt; &#123;\n     final ServiceBusReceivedMessage message = context.getMessage&#40;&#41;;\n     &#47;&#47; Randomly complete or abandon each message. Ideally, in real-world scenarios, if the business logic\n     &#47;&#47; handling message reaches desired state such that it doesn't require Service Bus to redeliver\n     &#47;&#47; the same message, then context.complete&#40;&#41; should be called otherwise context.abandon&#40;&#41;.\n     final boolean success = Math.random&#40;&#41; &lt; 0.5;\n     if &#40;success&#41; &#123;\n         try &#123;\n             context.complete&#40;&#41;;\n         &#125; catch &#40;RuntimeException error&#41; &#123;\n             System.out.printf&#40;&quot;Completion of the message %s failed.%n Error: %s%n&quot;,\n                 message.getMessageId&#40;&#41;, error&#41;;\n         &#125;\n     &#125; else &#123;\n         try &#123;\n             context.abandon&#40;&#41;;\n         &#125; catch &#40;RuntimeException error&#41; &#123;\n             System.out.printf&#40;&quot;Abandoning of the message %s failed.%nError: %s%n&quot;,\n                 message.getMessageId&#40;&#41;, error&#41;;\n         &#125;\n     &#125;\n &#125;;\n\n &#47;&#47; Sample code that gets called if there's an error\n Consumer&lt;ServiceBusErrorContext&gt; processError = errorContext -&gt; &#123;\n     if &#40;errorContext.getException&#40;&#41; instanceof ServiceBusException&#41; &#123;\n         ServiceBusException exception = &#40;ServiceBusException&#41; errorContext.getException&#40;&#41;;\n\n         System.out.printf&#40;&quot;Error source: %s, reason %s%n&quot;, errorContext.getErrorSource&#40;&#41;,\n             exception.getReason&#40;&#41;&#41;;\n     &#125; else &#123;\n         System.out.printf&#40;&quot;Error occurred: %s%n&quot;, errorContext.getException&#40;&#41;&#41;;\n     &#125;\n &#125;;\n\n TokenCredential tokenCredential = new DefaultAzureCredentialBuilder&#40;&#41;.build&#40;&#41;;\n\n &#47;&#47; Create the processor client via the builder and its sub-builder\n &#47;&#47; 'fullyQualifiedNamespace' will look similar to &quot;&#123;your-namespace&#125;.servicebus.windows.net&quot;\n ServiceBusProcessorClient processorClient = new ServiceBusClientBuilder&#40;&#41;\n     .credential&#40;fullyQualifiedNamespace, tokenCredential&#41;\n     .processor&#40;&#41;\n     .queueName&#40;queueName&#41;\n     .receiveMode&#40;ServiceBusReceiveMode.PEEK_LOCK&#41;\n     .disableAutoComplete&#40;&#41;  &#47;&#47; Make sure to explicitly opt in to manual settlement &#40;e.g. complete, abandon&#41;.\n     .processMessage&#40;processMessage&#41;\n     .processError&#40;processError&#41;\n     .disableAutoComplete&#40;&#41;\n     .buildProcessorClient&#40;&#41;;\n\n &#47;&#47; Starts the processor in the background. Control returns immediately.\n processorClient.start&#40;&#41;;\n\n &#47;&#47; Stop processor and dispose when done processing messages.\n processorClient.stop&#40;&#41;;\n processorClient.close&#40;&#41;;\n </pre>\n <!-- end com.azure.messaging.servicebus.servicebusprocessorclient#receive-mode-peek-lock-instantiation -->\n\n <p><strong>Sample: Create a receiver and receive messages</strong></p>\n\n <p>The following code sample demonstrates the creation and use of the synchronous client\n <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.ServiceBusReceiverClient\"></xref> to receive messages from a Service Bus subscription.\n The receive operation returns when either 10 messages are received or 30 seconds has elapsed.  By default, messages\n are received using <xref uid=\"com.azure.messaging.servicebus.models.ServiceBusReceiveMode#PEEK_LOCK\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.messaging.servicebus.models.ServiceBusReceiveMode#PEEK_LOCK\"></xref> and customers must\n settle their messages using one of the settlement methods on the receiver client.\n \"<a href=\"https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\">\n     \"Settling receive operations</a>\" provides additional information about message settlement.</p>\n\n <!-- src_embed com.azure.messaging.servicebus.servicebusreceiverclient.receiveMessages-int-duration -->\n <pre>\n TokenCredential tokenCredential = new DefaultAzureCredentialBuilder&#40;&#41;.build&#40;&#41;;\n\n &#47;&#47; 'fullyQualifiedNamespace' will look similar to &quot;&#123;your-namespace&#125;.servicebus.windows.net&quot;\n ServiceBusReceiverClient receiver = new ServiceBusClientBuilder&#40;&#41;\n     .credential&#40;fullyQualifiedNamespace, tokenCredential&#41;\n     .receiver&#40;&#41;\n     .topicName&#40;topicName&#41;\n     .subscriptionName&#40;subscriptionName&#41;\n     .buildClient&#40;&#41;;\n\n &#47;&#47; Receives a batch of messages when 10 messages are received or until 30 seconds have elapsed, whichever\n &#47;&#47; happens first.\n IterableStream&lt;ServiceBusReceivedMessage&gt; messages = receiver.receiveMessages&#40;10, Duration.ofSeconds&#40;30&#41;&#41;;\n messages.forEach&#40;message -&gt; &#123;\n     System.out.printf&#40;&quot;Id: %s. Contents: %s%n&quot;, message.getMessageId&#40;&#41;, message.getBody&#40;&#41;&#41;;\n\n     &#47;&#47; If able to process message, complete it. Otherwise, abandon it and allow it to be\n     &#47;&#47; redelivered.\n     if &#40;isMessageProcessed&#41; &#123;\n         receiver.complete&#40;message&#41;;\n     &#125; else &#123;\n         receiver.abandon&#40;message&#41;;\n     &#125;\n &#125;&#41;;\n\n &#47;&#47; When program ends, or you're done receiving all messages, dispose of the receiver.\n &#47;&#47; Clients should be long-lived objects as they\n &#47;&#47; require resources and time to establish a connection to the service.\n receiver.close&#40;&#41;;\n </pre>\n <!-- end com.azure.messaging.servicebus.servicebusreceiverclient.receiveMessages-int-duration -->"
metadata: {}
package: "com.azure.messaging.servicebus"
artifact: com.azure:azure-messaging-servicebus:7.15.0
