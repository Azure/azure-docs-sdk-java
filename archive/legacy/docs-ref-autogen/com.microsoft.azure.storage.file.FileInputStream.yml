### YamlMime:JavaType
constructors:
- fullName: com.microsoft.azure.storage.file.FileInputStream.FileInputStream(final CloudFile parentFile, final AccessCondition accessCondition, final FileRequestOptions options, final OperationContext opContext)
  name: FileInputStream(final CloudFile parentFile, final AccessCondition accessCondition, final FileRequestOptions options, final OperationContext opContext)
  nameWithType: FileInputStream.FileInputStream(final CloudFile parentFile, final AccessCondition accessCondition, final FileRequestOptions options, final OperationContext opContext)
  parameters:
  - description: <p>A <xref uid="com.microsoft.azure.storage.file.CloudFile" data-throw-if-not-resolved="false" data-raw-source="CloudFile"></xref> object which represents the file that this stream is associated with. </p>
    name: parentFile
    type: final <xref href="com.microsoft.azure.storage.file.CloudFile?alt=com.microsoft.azure.storage.file.CloudFile&text=CloudFile" data-throw-if-not-resolved="False"/>
  - description: <p>An <xref uid="com.microsoft.azure.storage.AccessCondition" data-throw-if-not-resolved="false" data-raw-source="AccessCondition"></xref> object which represents the access conditions for the file. </p>
    name: accessCondition
    type: final <xref href="com.microsoft.azure.storage.AccessCondition?alt=com.microsoft.azure.storage.AccessCondition&text=AccessCondition" data-throw-if-not-resolved="False"/>
  - description: <p>A <xref uid="com.microsoft.azure.storage.file.FileRequestOptions" data-throw-if-not-resolved="false" data-raw-source="FileRequestOptions"></xref> object which represents that specifies any additional options for the request. </p>
    name: options
    type: final <xref href="com.microsoft.azure.storage.file.FileRequestOptions?alt=com.microsoft.azure.storage.file.FileRequestOptions&text=FileRequestOptions" data-throw-if-not-resolved="False"/>
  - description: <p>An <xref uid="com.microsoft.azure.storage.OperationContext" data-throw-if-not-resolved="false" data-raw-source="OperationContext"></xref> object which is used to track the execution of the operation.</p>
    name: opContext
    type: final <xref href="com.microsoft.azure.storage.OperationContext?alt=com.microsoft.azure.storage.OperationContext&text=OperationContext" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="StorageException?alt=StorageException&text=StorageException" data-throw-if-not-resolved="False"/>
    description: <p>An exception representing any error which occurred during the operation. </p>
  summary: >-
    <p>Initializes a new instance of the FileInputStream class.</p>

    <p></p>
  syntax: protected FileInputStream(final CloudFile parentFile, final AccessCondition accessCondition, final FileRequestOptions options, final OperationContext opContext)
  uid: com.microsoft.azure.storage.file.FileInputStream.FileInputStream(final CloudFile,final AccessCondition,final FileRequestOptions,final OperationContext)
inheritances:
- <xref href="java.lang.Object" data-throw-if-not-resolved="False"/>
- <xref href="InputStream" data-throw-if-not-resolved="False"/>
methods:
- fullName: com.microsoft.azure.storage.file.FileInputStream.available()
  name: available()
  nameWithType: FileInputStream.available()
  exceptions:
  - type: <xref href="IOException?alt=IOException&text=IOException" data-throw-if-not-resolved="False"/>
    description: <p>If an I/O error occurs. </p>
  returns:
    description: <p>An <code>int</code> which represents an estimate of the number of bytes that can be read (or skipped over) from this input stream without blocking, or 0 when it reaches the end of the input stream.</p>
    type: <xref href="synchronized+int?alt=synchronized+int&text=synchronized+int" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Returns an estimate of the number of bytes that can be read (or skipped over) from this input stream without blocking by the next invocation of a method for this input stream. The next invocation might be the same thread or another thread. A single read or skip of this many bytes will not block, but may read or skip fewer bytes.</p>

    <p></p>
  syntax: public synchronized int available()
  uid: com.microsoft.azure.storage.file.FileInputStream.available()
- fullName: com.microsoft.azure.storage.file.FileInputStream.close()
  name: close()
  nameWithType: FileInputStream.close()
  exceptions:
  - type: <xref href="IOException?alt=IOException&text=IOException" data-throw-if-not-resolved="False"/>
    description: <p>If an I/O error occurs. </p>
  returns:
    type: <xref href="synchronized+void?alt=synchronized+void&text=synchronized+void" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Closes this input stream and releases any system resources associated with the stream.</p>

    <p></p>
  syntax: public synchronized void close()
  uid: com.microsoft.azure.storage.file.FileInputStream.close()
- fullName: com.microsoft.azure.storage.file.FileInputStream.mark(final int readlimit)
  name: mark(final int readlimit)
  nameWithType: FileInputStream.mark(final int readlimit)
  parameters:
  - description: <p>An <code>int</code> which represents the maximum limit of bytes that can be read before the mark position becomes invalid. </p>
    name: readlimit
    type: <xref href="final+int?alt=final+int&text=final+int" data-throw-if-not-resolved="False"/>
  returns:
    type: <xref href="synchronized+void?alt=synchronized+void&text=synchronized+void" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Marks the current position in this input stream. A subsequent call to the reset method repositions this stream at the last marked position so that subsequent reads re-read the same bytes.</p>

    <p></p>
  syntax: public synchronized void mark(final int readlimit)
  uid: com.microsoft.azure.storage.file.FileInputStream.mark(final int)
- fullName: com.microsoft.azure.storage.file.FileInputStream.markSupported()
  name: markSupported()
  nameWithType: FileInputStream.markSupported()
  returns:
    description: >-
      <p>

        <code>True</code> if this stream instance supports the mark and reset methods; <code>False</code> otherwise. </p>
    type: <xref href="boolean?alt=boolean&text=boolean" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Tests if this input stream supports the mark and reset methods. Whether or not mark and reset are supported is an invariant property of a particular input stream instance. The markSupported method of <xref uid="" data-throw-if-not-resolved="false" data-raw-source="InputStream"></xref> returns false.</p>

    <p></p>
  syntax: public boolean markSupported()
  uid: com.microsoft.azure.storage.file.FileInputStream.markSupported()
- fullName: com.microsoft.azure.storage.file.FileInputStream.read()
  name: read()
  nameWithType: FileInputStream.read()
  exceptions:
  - type: <xref href="IOException?alt=IOException&text=IOException" data-throw-if-not-resolved="False"/>
    description: <p>If an I/O error occurs. </p>
  returns:
    description: <p>An <code>int</code> which represents the total number of bytes read into the buffer, or -1 if there is no more data because the end of the stream has been reached.</p>
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Reads the next byte of data from the input stream. The value byte is returned as an int in the range 0 to 255. If no byte is available because the end of the stream has been reached, the value -1 is returned. This method blocks until input data is available, the end of the stream is detected, or an exception is thrown.</p>

    <p></p>
  syntax: public int read()
  uid: com.microsoft.azure.storage.file.FileInputStream.read()
- fullName: com.microsoft.azure.storage.file.FileInputStream.read(final byte[] b)
  name: read(final byte[] b)
  nameWithType: FileInputStream.read(final byte[] b)
  parameters:
  - description: <p>A <code>byte</code> array which represents the buffer into which the data is read.</p>
    name: b
    type: <xref href="final+byte+%5B%5D?alt=final+byte+%5B%5D&text=final+byte+%5B%5D" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IOException?alt=IOException&text=IOException" data-throw-if-not-resolved="False"/>
    description: <p>If the first byte cannot be read for any reason other than the end of the file, if the input stream has been closed, or if some other I/O error occurs. </p>
  - type: <xref href="NullPointerException?alt=NullPointerException&text=NullPointerException" data-throw-if-not-resolved="False"/>
    description: <p>If the <code>byte</code> array <code>b</code> is null. </p>
  returns:
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Reads some number of bytes from the input stream and stores them into the buffer array . The number of bytes actually read is returned as an integer. This method blocks until input data is available, end of file is detected, or an exception is thrown. If the length of  is zero, then no bytes are read and 0 is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at the end of the file, the value -1 is returned; otherwise, at least one byte is read and stored into .</p>

    <p>The first byte read is stored into element , the next one into , and so on. The number of bytes read is, at most, equal to the length of . Let  be the number of bytes actually read; these bytes will be stored in elements  through , leaving elements  through  unaffected.</p>

    <p>The  method for class <xref uid="" data-throw-if-not-resolved="false" data-raw-source="InputStream"></xref> has the same effect as:</p>

    <p></p>

    <p></p>
  syntax: public int read(final byte[] b)
  uid: com.microsoft.azure.storage.file.FileInputStream.read(final byte [])
- fullName: com.microsoft.azure.storage.file.FileInputStream.read(final byte[] b, final int off, final int len)
  name: read(final byte[] b, final int off, final int len)
  nameWithType: FileInputStream.read(final byte[] b, final int off, final int len)
  parameters:
  - description: <p>A <code>byte</code> array which represents the buffer into which the data is read. </p>
    name: b
    type: <xref href="final+byte+%5B%5D?alt=final+byte+%5B%5D&text=final+byte+%5B%5D" data-throw-if-not-resolved="False"/>
  - description: <p>An <code>int</code> which represents the start offset in the <code>byte</code> array at which the data is written. </p>
    name: off
    type: <xref href="final+int?alt=final+int&text=final+int" data-throw-if-not-resolved="False"/>
  - description: <p>An <code>int</code> which represents the maximum number of bytes to read.</p>
    name: len
    type: <xref href="final+int?alt=final+int&text=final+int" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IOException?alt=IOException&text=IOException" data-throw-if-not-resolved="False"/>
    description: <p>If the first byte cannot be read for any reason other than end of file, or if the input stream has been closed, or if some other I/O error occurs. </p>
  - type: <xref href="NullPointerException?alt=NullPointerException&text=NullPointerException" data-throw-if-not-resolved="False"/>
    description: <p>If the <code>byte</code> array <code>b</code> is null. </p>
  - type: <xref href="IndexOutOfBoundsException?alt=IndexOutOfBoundsException&text=IndexOutOfBoundsException" data-throw-if-not-resolved="False"/>
    description: <p>If <code>off</code> is negative, <code>len</code> is negative, or <code>len</code> is greater than <code>b.length - off</code>. </p>
  returns:
    description: <p>An <code>int</code> which represents the total number of bytes read into the buffer, or -1 if there is no more data because the end of the stream has been reached.</p>
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Reads up to  bytes of data from the input stream into an array of bytes. An attempt is made to read as many as  bytes, but a smaller number may be read. The number of bytes actually read is returned as an integer. This method blocks until input data is available, end of file is detected, or an exception is thrown.</p>

    <p>If  is zero, then no bytes are read and 0 is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at end of file, the value -1 is returned; otherwise, at least one byte is read and stored into .</p>

    <p>The first byte read is stored into element , the next one into , and so on. The number of bytes read is, at most, equal to . Let  be the number of bytes actually read; these bytes will be stored in elements  through , leaving elements  through  unaffected.</p>

    <p>In every case, elements  through  and elements  through  are unaffected.</p>

    <p>The  method for class <xref uid="" data-throw-if-not-resolved="false" data-raw-source="InputStream"></xref> simply calls the method  repeatedly. If the first such call results in an , that exception is returned from the call to the  method. If any subsequent call to  results in a , the exception is caught and treated as if it were end of file; the bytes read up to that point are stored into  and the number of bytes read before the exception occurred is returned. The default implementation of this method blocks until the requested amount of input data  has been read, end of file is detected, or an exception is thrown. Subclasses are encouraged to provide a more efficient implementation of this method.</p>

    <p></p>
  syntax: public int read(final byte[] b, final int off, final int len)
  uid: com.microsoft.azure.storage.file.FileInputStream.read(final byte [],final int,final int)
- fullName: com.microsoft.azure.storage.file.FileInputStream.reset()
  name: reset()
  nameWithType: FileInputStream.reset()
  exceptions:
  - type: <xref href="IOException?alt=IOException&text=IOException" data-throw-if-not-resolved="False"/>
    description: <p>If this stream has not been marked or if the mark has been invalidated. </p>
  returns:
    type: <xref href="synchronized+void?alt=synchronized+void&text=synchronized+void" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Repositions this stream to the position at the time the mark method was last called on this input stream. Note repositioning the file read stream will disable file MD5 checking.</p>

    <p></p>
  syntax: public synchronized void reset()
  uid: com.microsoft.azure.storage.file.FileInputStream.reset()
- fullName: com.microsoft.azure.storage.file.FileInputStream.skip(final long n)
  name: skip(final long n)
  nameWithType: FileInputStream.skip(final long n)
  parameters:
  - description: <p>A <code>long</code> which represents the number of bytes to skip. </p>
    name: n
    type: <xref href="final+long?alt=final+long&text=final+long" data-throw-if-not-resolved="False"/>
  returns:
    type: <xref href="synchronized+long?alt=synchronized+long&text=synchronized+long" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Skips over and discards n bytes of data from this input stream. The skip method may, for a variety of reasons, end up skipping over some smaller number of bytes, possibly 0. This may result from any of a number of conditions; reaching end of file before n bytes have been skipped is only one possibility. The actual number of bytes skipped is returned. If n is negative, no bytes are skipped.</p>

    <p>Note repositioning the file read stream will disable file MD5 checking.</p>

    <p></p>
  syntax: public synchronized long skip(final long n)
  uid: com.microsoft.azure.storage.file.FileInputStream.skip(final long)
nameWithType: FileInputStream
syntax: public class FileInputStream
type: class
uid: com.microsoft.azure.storage.file.FileInputStream
fullName: com.microsoft.azure.storage.file.FileInputStream
name: FileInputStream
package: com.microsoft.azure.storage.file
summary: <p>Provides an input stream to read a given file resource. </p>
metadata: {}
