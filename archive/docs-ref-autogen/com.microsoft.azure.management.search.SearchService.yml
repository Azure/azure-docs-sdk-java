### YamlMime:JavaType
inheritedMembers:
- com.microsoft.azure.management.resources.fluentcore.arm.models.HasId.id()
- com.microsoft.azure.management.resources.fluentcore.model.HasInner.inner()
- com.microsoft.azure.management.resources.fluentcore.model.Indexable.key()
- com.microsoft.azure.management.resources.fluentcore.arm.models.HasManager.manager()
- com.microsoft.azure.management.resources.fluentcore.arm.models.HasName.name()
- com.microsoft.azure.management.resources.fluentcore.model.Refreshable.refresh()
- com.microsoft.azure.management.resources.fluentcore.model.Refreshable.refreshAsync()
- com.microsoft.azure.management.resources.fluentcore.arm.models.Resource.region()
- com.microsoft.azure.management.resources.fluentcore.arm.models.Resource.regionName()
- com.microsoft.azure.management.resources.fluentcore.arm.models.HasResourceGroup.resourceGroupName()
- com.microsoft.azure.management.resources.fluentcore.arm.models.Resource.tags()
- com.microsoft.azure.management.resources.fluentcore.arm.models.Resource.type()
- com.microsoft.azure.management.resources.fluentcore.model.Updatable.update()
methods:
- fullName: com.microsoft.azure.management.search.SearchService.createQueryKey(String name)
  name: createQueryKey(String name)
  nameWithType: SearchService.createQueryKey(String name)
  parameters:
  - description: <p>The name of the new query API key. </p>
    name: name
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IllegalArgumentException?alt=IllegalArgumentException&text=IllegalArgumentException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if parameters fail the validation </p>
  - type: <xref href="CloudException?alt=CloudException&text=CloudException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if the request is rejected by server </p>
  - type: <xref href="RuntimeException?alt=RuntimeException&text=RuntimeException" data-throw-if-not-resolved="False"/>
    description: <p>all other wrapped checked exceptions if the request fails to be sent </p>
  returns:
    description: <p>the &lt;QueryKey&gt; object if successful </p>
    type: <xref href="com.microsoft.azure.management.search.QueryKey?alt=com.microsoft.azure.management.search.QueryKey&text=QueryKey" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Regenerates either the primary or secondary admin API key. </p>

    <p>You can only regenerate one key at a time.</p>

    <p></p>
  syntax: public QueryKey createQueryKey(String name)
  uid: com.microsoft.azure.management.search.SearchService.createQueryKey(String)
- fullName: com.microsoft.azure.management.search.SearchService.createQueryKeyAsync(String name)
  name: createQueryKeyAsync(String name)
  nameWithType: SearchService.createQueryKeyAsync(String name)
  parameters:
  - description: <p>The name of the new query API key. </p>
    name: name
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IllegalArgumentException?alt=IllegalArgumentException&text=IllegalArgumentException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if parameters fail the validation </p>
  returns:
    description: <p>a representation of the future computation of this call </p>
    type: Observable&lt;<xref href="com.microsoft.azure.management.search.QueryKey?alt=com.microsoft.azure.management.search.QueryKey&text=QueryKey" data-throw-if-not-resolved="False"/>&gt;
  summary: >-
    <p>Regenerates either the primary or secondary admin API key. </p>

    <p>You can only regenerate one key at a time.</p>

    <p></p>
  syntax: public Observable<QueryKey> createQueryKeyAsync(String name)
  uid: com.microsoft.azure.management.search.SearchService.createQueryKeyAsync(String)
- fullName: com.microsoft.azure.management.search.SearchService.deleteQueryKey(String key)
  name: deleteQueryKey(String key)
  nameWithType: SearchService.deleteQueryKey(String key)
  parameters:
  - description: <p>The query key to be deleted. Query keys are identified by value, not by name. </p>
    name: key
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IllegalArgumentException?alt=IllegalArgumentException&text=IllegalArgumentException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if parameters fail the validation </p>
  - type: <xref href="CloudException?alt=CloudException&text=CloudException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if the request is rejected by server </p>
  - type: <xref href="RuntimeException?alt=RuntimeException&text=RuntimeException" data-throw-if-not-resolved="False"/>
    description: <p>all other wrapped checked exceptions if the request fails to be sent </p>
  summary: >-
    <p>Deletes the specified query key. </p>

    <p>Unlike admin keys, query keys are not regenerated. The process for regenerating a query key is to delete and then recreate it.</p>

    <p></p>
  syntax: public void deleteQueryKey(String key)
  uid: com.microsoft.azure.management.search.SearchService.deleteQueryKey(String)
- fullName: com.microsoft.azure.management.search.SearchService.deleteQueryKeyAsync(String key)
  name: deleteQueryKeyAsync(String key)
  nameWithType: SearchService.deleteQueryKeyAsync(String key)
  parameters:
  - description: <p>The query key to be deleted. Query keys are identified by value, not by name. </p>
    name: key
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IllegalArgumentException?alt=IllegalArgumentException&text=IllegalArgumentException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if parameters fail the validation </p>
  returns:
    description: <p>a representation of the future computation of this call </p>
    type: <xref href="Completable?alt=Completable&text=Completable" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Deletes the specified query key. </p>

    <p>Unlike admin keys, query keys are not regenerated. The process for regenerating a query key is to delete and then recreate it.</p>

    <p></p>
  syntax: public Completable deleteQueryKeyAsync(String key)
  uid: com.microsoft.azure.management.search.SearchService.deleteQueryKeyAsync(String)
- fullName: com.microsoft.azure.management.search.SearchService.getAdminKeys()
  name: getAdminKeys()
  nameWithType: SearchService.getAdminKeys()
  exceptions:
  - type: <xref href="IllegalArgumentException?alt=IllegalArgumentException&text=IllegalArgumentException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if parameters fail the validation </p>
  - type: <xref href="CloudException?alt=CloudException&text=CloudException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if the request is rejected by server </p>
  - type: <xref href="RuntimeException?alt=RuntimeException&text=RuntimeException" data-throw-if-not-resolved="False"/>
    description: <p>all other wrapped checked exceptions if the request fails to be sent </p>
  returns:
    description: <p>the AdminKeys object if successful </p>
    type: <xref href="com.microsoft.azure.management.search.AdminKeys?alt=com.microsoft.azure.management.search.AdminKeys&text=AdminKeys" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>The primary and secondary admin API keys for the specified Azure Search service.</p>

    <p></p>
  syntax: public AdminKeys getAdminKeys()
  uid: com.microsoft.azure.management.search.SearchService.getAdminKeys()
- fullName: com.microsoft.azure.management.search.SearchService.getAdminKeysAsync()
  name: getAdminKeysAsync()
  nameWithType: SearchService.getAdminKeysAsync()
  exceptions:
  - type: <xref href="IllegalArgumentException?alt=IllegalArgumentException&text=IllegalArgumentException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if parameters fail the validation </p>
  returns:
    description: <p>a representation of the future computation of this call </p>
    type: Observable&lt;<xref href="com.microsoft.azure.management.search.AdminKeys?alt=com.microsoft.azure.management.search.AdminKeys&text=AdminKeys" data-throw-if-not-resolved="False"/>&gt;
  summary: >-
    <p>The primary and secondary admin API keys for the specified Azure Search service.</p>

    <p></p>
  syntax: public Observable<AdminKeys> getAdminKeysAsync()
  uid: com.microsoft.azure.management.search.SearchService.getAdminKeysAsync()
- fullName: com.microsoft.azure.management.search.SearchService.hostingMode()
  name: hostingMode()
  nameWithType: SearchService.hostingMode()
  returns:
    description: <p>the hosting mode value. </p>
    type: <xref href="com.microsoft.azure.management.search.HostingMode?alt=com.microsoft.azure.management.search.HostingMode&text=HostingMode" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>The hosting mode value. </p>

    <p>Applicable only for the standard3 SKU. You can set this property to enable up to 3 high density partitions that allow up to 1000 indexes, which is much higher than the maximum indexes allowed for any other SKU. For the standard3 SKU, the value is either 'default' or 'highDensity'. For all other SKUs, this value must be 'default'.</p>

    <p></p>
  syntax: public HostingMode hostingMode()
  uid: com.microsoft.azure.management.search.SearchService.hostingMode()
- fullName: com.microsoft.azure.management.search.SearchService.listQueryKeys()
  name: listQueryKeys()
  nameWithType: SearchService.listQueryKeys()
  exceptions:
  - type: <xref href="IllegalArgumentException?alt=IllegalArgumentException&text=IllegalArgumentException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if parameters fail the validation </p>
  - type: <xref href="CloudException?alt=CloudException&text=CloudException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if the request is rejected by server </p>
  - type: <xref href="RuntimeException?alt=RuntimeException&text=RuntimeException" data-throw-if-not-resolved="False"/>
    description: <p>all other wrapped checked exceptions if the request fails to be sent </p>
  returns:
    description: <p>the List&lt;QueryKey&gt; object if successful </p>
    type: List&lt;<xref href="com.microsoft.azure.management.search.QueryKey?alt=com.microsoft.azure.management.search.QueryKey&text=QueryKey" data-throw-if-not-resolved="False"/>&gt;
  summary: >-
    <p>Returns the list of query API keys for the given Azure Search service.</p>

    <p></p>
  syntax: public List<QueryKey> listQueryKeys()
  uid: com.microsoft.azure.management.search.SearchService.listQueryKeys()
- fullName: com.microsoft.azure.management.search.SearchService.listQueryKeysAsync()
  name: listQueryKeysAsync()
  nameWithType: SearchService.listQueryKeysAsync()
  exceptions:
  - type: <xref href="IllegalArgumentException?alt=IllegalArgumentException&text=IllegalArgumentException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if parameters fail the validation </p>
  returns:
    description: <p>the observable to the List&lt;QueryKey&gt; object </p>
    type: Observable&lt;<xref href="com.microsoft.azure.management.search.QueryKey?alt=com.microsoft.azure.management.search.QueryKey&text=QueryKey" data-throw-if-not-resolved="False"/>&gt;
  summary: >-
    <p>Returns the list of query API keys for the given Azure Search service.</p>

    <p></p>
  syntax: public Observable<QueryKey> listQueryKeysAsync()
  uid: com.microsoft.azure.management.search.SearchService.listQueryKeysAsync()
- fullName: com.microsoft.azure.management.search.SearchService.partitionCount()
  name: partitionCount()
  nameWithType: SearchService.partitionCount()
  returns:
    description: <p>the number of partitions used by the service </p>
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  syntax: public int partitionCount()
  uid: com.microsoft.azure.management.search.SearchService.partitionCount()
- fullName: com.microsoft.azure.management.search.SearchService.provisioningState()
  name: provisioningState()
  nameWithType: SearchService.provisioningState()
  returns:
    description: <p>the provisioning state of the resource </p>
    type: <xref href="com.microsoft.azure.management.search.ProvisioningState?alt=com.microsoft.azure.management.search.ProvisioningState&text=ProvisioningState" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>The state of the last provisioning operation performed on the Search service. </p>

    <p>Provisioning is an intermediate state that occurs while service capacity is being established. After capacity is set up, provisioningState changes to either 'succeeded' or 'failed'. Client applications can poll provisioning status (the recommended polling interval is from 30 seconds to one minute) by using the Get Search Service operation to see when an operation is completed. If you are using the free service, this value tends to come back as 'succeeded' directly in the call to Create Search service. This is because the free service uses capacity that is already set up.</p>

    <p></p>
  syntax: public ProvisioningState provisioningState()
  uid: com.microsoft.azure.management.search.SearchService.provisioningState()
- fullName: com.microsoft.azure.management.search.SearchService.regenerateAdminKeys(AdminKeyKind keyKind)
  name: regenerateAdminKeys(AdminKeyKind keyKind)
  nameWithType: SearchService.regenerateAdminKeys(AdminKeyKind keyKind)
  parameters:
  - description: <p>specifies which key to regenerate </p>
    name: keyKind
    type: <xref href="com.microsoft.azure.management.search.AdminKeyKind?alt=com.microsoft.azure.management.search.AdminKeyKind&text=AdminKeyKind" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IllegalArgumentException?alt=IllegalArgumentException&text=IllegalArgumentException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if parameters fail the validation </p>
  - type: <xref href="CloudException?alt=CloudException&text=CloudException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if the request is rejected by server </p>
  - type: <xref href="RuntimeException?alt=RuntimeException&text=RuntimeException" data-throw-if-not-resolved="False"/>
    description: <p>all other wrapped checked exceptions if the request fails to be sent </p>
  returns:
    description: <p>the AdminKeys object if successful </p>
    type: <xref href="com.microsoft.azure.management.search.AdminKeys?alt=com.microsoft.azure.management.search.AdminKeys&text=AdminKeys" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Regenerates either the primary or secondary admin API key. </p>

    <p>You can only regenerate one key at a time.</p>

    <p></p>
  syntax: public AdminKeys regenerateAdminKeys(AdminKeyKind keyKind)
  uid: com.microsoft.azure.management.search.SearchService.regenerateAdminKeys(AdminKeyKind)
- fullName: com.microsoft.azure.management.search.SearchService.regenerateAdminKeysAsync(AdminKeyKind keyKind)
  name: regenerateAdminKeysAsync(AdminKeyKind keyKind)
  nameWithType: SearchService.regenerateAdminKeysAsync(AdminKeyKind keyKind)
  parameters:
  - description: <p>Specifies which key to regenerate </p>
    name: keyKind
    type: <xref href="com.microsoft.azure.management.search.AdminKeyKind?alt=com.microsoft.azure.management.search.AdminKeyKind&text=AdminKeyKind" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IllegalArgumentException?alt=IllegalArgumentException&text=IllegalArgumentException" data-throw-if-not-resolved="False"/>
    description: <p>thrown if parameters fail the validation </p>
  returns:
    description: <p>a representation of the future computation of this call </p>
    type: Observable&lt;<xref href="com.microsoft.azure.management.search.AdminKeys?alt=com.microsoft.azure.management.search.AdminKeys&text=AdminKeys" data-throw-if-not-resolved="False"/>&gt;
  summary: >-
    <p>Regenerates either the primary or secondary admin API key. You can only regenerate one key at a time.</p>

    <p></p>
  syntax: public Observable<AdminKeys> regenerateAdminKeysAsync(AdminKeyKind keyKind)
  uid: com.microsoft.azure.management.search.SearchService.regenerateAdminKeysAsync(AdminKeyKind)
- fullName: com.microsoft.azure.management.search.SearchService.replicaCount()
  name: replicaCount()
  nameWithType: SearchService.replicaCount()
  returns:
    description: <p>the number of replicas used by the service </p>
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  syntax: public int replicaCount()
  uid: com.microsoft.azure.management.search.SearchService.replicaCount()
- fullName: com.microsoft.azure.management.search.SearchService.sku()
  name: sku()
  nameWithType: SearchService.sku()
  returns:
    description: <p>the SKU type of the service </p>
    type: <xref href="com.microsoft.azure.management.search.Sku?alt=com.microsoft.azure.management.search.Sku&text=Sku" data-throw-if-not-resolved="False"/>
  syntax: public Sku sku()
  uid: com.microsoft.azure.management.search.SearchService.sku()
- fullName: com.microsoft.azure.management.search.SearchService.status()
  name: status()
  nameWithType: SearchService.status()
  returns:
    description: <p>the status of the service </p>
    type: <xref href="com.microsoft.azure.management.search.SearchServiceStatus?alt=com.microsoft.azure.management.search.SearchServiceStatus&text=SearchServiceStatus" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>The status of the Search service. </p>

    <p>Possible values include: 'running': the Search service is running and no provisioning operations are underway. 'provisioning': the Search service is being provisioned or scaled up or down. 'deleting': the Search service is being deleted. 'degraded': the Search service is degraded. This can occur when the underlying search units are not healthy. The Search service is most likely operational, but performance might be slow and some requests might be dropped. 'disabled': the Search service is disabled. In this state, the service will reject all API requests. 'error': the Search service is in an error state. If your service is in the degraded, disabled, or error states, it means the Azure Search team is actively investigating the underlying issue. Dedicated services in these states are still chargeable based on the number of search units provisioned.</p>

    <p></p>
  syntax: public SearchServiceStatus status()
  uid: com.microsoft.azure.management.search.SearchService.status()
- fullName: com.microsoft.azure.management.search.SearchService.statusDetails()
  name: statusDetails()
  nameWithType: SearchService.statusDetails()
  returns:
    description: <p>the details of the status. </p>
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  syntax: public String statusDetails()
  uid: com.microsoft.azure.management.search.SearchService.statusDetails()
nameWithType: SearchService
syntax: public interface SearchService extends GroupableResource<SearchServiceManager, SearchServiceInner>,Refreshable<SearchService>,Updatable<SearchService.Update>
type: interface
uid: com.microsoft.azure.management.search.SearchService
fullName: com.microsoft.azure.management.search.SearchService
name: SearchService
package: com.microsoft.azure.management.search
summary: <p>An immutable client-side representation of an Azure registry. </p>
metadata: {}
