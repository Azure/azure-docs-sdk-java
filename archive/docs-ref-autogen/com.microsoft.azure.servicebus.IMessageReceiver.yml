### YamlMime:JavaType
inheritedMembers:
- com.microsoft.azure.servicebus.ICloseable.close()
- com.microsoft.azure.servicebus.ICloseable.closeAsync()
- com.microsoft.azure.servicebus.IMessageEntityClient.getEntityPath()
- com.microsoft.azure.servicebus.IMessageBrowser.peek()
- com.microsoft.azure.servicebus.IMessageBrowser.peek(long)
- com.microsoft.azure.servicebus.IMessageBrowser.peekAsync()
- com.microsoft.azure.servicebus.IMessageBrowser.peekAsync(long)
- com.microsoft.azure.servicebus.IMessageBrowser.peekBatch(int)
- com.microsoft.azure.servicebus.IMessageBrowser.peekBatch(long,int)
- com.microsoft.azure.servicebus.IMessageBrowser.peekBatchAsync(int)
- com.microsoft.azure.servicebus.IMessageBrowser.peekBatchAsync(long,int)
methods:
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID lockToken)
  name: abandon(UUID lockToken)
  nameWithType: IMessageReceiver.abandon(UUID lockToken)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if abandon failed </p>
  summary: >-
    <p>Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message</p>

    <p></p>
  syntax: public void abandon(UUID lockToken)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID lockToken, Map<String, Object> propertiesToModify)
  name: abandon(UUID lockToken, Map<String, Object> propertiesToModify)
  nameWithType: IMessageReceiver.abandon(UUID lockToken, Map<String, Object> propertiesToModify)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if abandon failed </p>
  summary: >-
    <p>Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message</p>

    <p></p>
  syntax: public void abandon(UUID lockToken, Map<String, Object> propertiesToModify)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID,Map<String, Object>)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  name: abandon(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.abandon(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if abandon failed </p>
  summary: >-
    <p>Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message</p>

    <p></p>
  syntax: public void abandon(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID,Map<String, Object>,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID lockToken, TransactionContext transaction)
  name: abandon(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.abandon(UUID lockToken, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if abandon failed </p>
  summary: >-
    <p>Abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message</p>

    <p></p>
  syntax: public void abandon(UUID lockToken, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.abandon(UUID,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID lockToken)
  name: abandonAsync(UUID lockToken)
  nameWithType: IMessageReceiver.abandonAsync(UUID lockToken)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending abandon. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.</p>

    <p></p>
  syntax: public CompletableFuture<Void> abandonAsync(UUID lockToken)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  name: abandonAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  nameWithType: IMessageReceiver.abandonAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending abandon. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.</p>

    <p></p>
  syntax: public CompletableFuture<Void> abandonAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID,Map<String, Object>)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  name: abandonAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.abandonAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending abandon. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> with lock token and updated message property. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.</p>

    <p></p>
  syntax: public CompletableFuture<Void> abandonAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID,Map<String, Object>,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID lockToken, TransactionContext transaction)
  name: abandonAsync(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.abandonAsync(UUID lockToken, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending abandon. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously abandon <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> with lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message.</p>

    <p></p>
  syntax: public CompletableFuture<Void> abandonAsync(UUID lockToken, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.abandonAsync(UUID,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.complete(UUID lockToken)
  name: complete(UUID lockToken)
  nameWithType: IMessageReceiver.complete(UUID lockToken)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if abandon failed </p>
  summary: >-
    <p>Completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token. This will delete the message from the service.</p>

    <p></p>
  syntax: public void complete(UUID lockToken)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.complete(UUID)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.complete(UUID lockToken, TransactionContext transaction)
  name: complete(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.complete(UUID lockToken, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if abandon failed </p>
  summary: >-
    <p>Completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token. This will delete the message from the service.</p>

    <p></p>
  syntax: public void complete(UUID lockToken, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.complete(UUID,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync(UUID lockToken)
  name: completeAsync(UUID lockToken)
  nameWithType: IMessageReceiver.completeAsync(UUID lockToken)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending complete. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token. This will delete the message from the service.</p>

    <p></p>
  syntax: public CompletableFuture<Void> completeAsync(UUID lockToken)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync(UUID)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync(UUID lockToken, TransactionContext transaction)
  name: completeAsync(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.completeAsync(UUID lockToken, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending complete. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously completes a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token. This will delete the message from the service.</p>

    <p></p>
  syntax: public CompletableFuture<Void> completeAsync(UUID lockToken, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.completeAsync(UUID,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken)
  name: deadLetter(UUID lockToken)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if deadletter failed </p>
  summary: >-
    <p>Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue.</p>

    <p></p>
  syntax: public void deadLetter(UUID lockToken)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, Map<String, Object> propertiesToModify)
  name: deadLetter(UUID lockToken, Map<String, Object> propertiesToModify)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, Map<String, Object> propertiesToModify)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if deadletter failed </p>
  summary: >-
    <p>Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with modified message properties.</p>

    <p></p>
  syntax: public void deadLetter(UUID lockToken, Map<String, Object> propertiesToModify)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID,Map<String, Object>)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  name: deadLetter(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if deadletter failed </p>
  summary: >-
    <p>Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with modified message properties.</p>

    <p></p>
  syntax: public void deadLetter(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID,Map<String, Object>,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter reason. </p>
    name: deadLetterReason
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter error description. </p>
    name: deadLetterErrorDescription
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if deadletter failed </p>
  summary: >-
    <p>Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with deadletter reason and error description.</p>

    <p></p>
  syntax: public void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID,String,String)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify)
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter reason. </p>
    name: deadLetterReason
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter error description. </p>
    name: deadLetterErrorDescription
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if deadletter failed </p>
  summary: >-
    <p>Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.</p>

    <p></p>
  syntax: public void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID,String,String,Map<String, Object>)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify, TransactionContext transaction)
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter reason. </p>
    name: deadLetterReason
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter error description. </p>
    name: deadLetterErrorDescription
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if deadletter failed </p>
  summary: >-
    <p>Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.</p>

    <p></p>
  syntax: public void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID,String,String,Map<String, Object>,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  name: deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter reason. </p>
    name: deadLetterReason
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter error description. </p>
    name: deadLetterErrorDescription
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if deadletter failed </p>
  summary: >-
    <p>Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with deadletter reason and error description.</p>

    <p></p>
  syntax: public void deadLetter(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID,String,String,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID lockToken, TransactionContext transaction)
  name: deadLetter(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetter(UUID lockToken, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if deadletter failed </p>
  summary: >-
    <p>Moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue.</p>

    <p></p>
  syntax: public void deadLetter(UUID lockToken, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetter(UUID,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken)
  name: deadLetterAsync(UUID lockToken)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending deadletter. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with deadletter.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deadLetterAsync(UUID lockToken)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  name: deadLetterAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending deadletter. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with modified properties.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deadLetterAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID,Map<String, Object>)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  name: deadLetterAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending deadletter. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with modified properties.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deadLetterAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID,Map<String, Object>,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter reason. </p>
    name: deadLetterReason
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter error description. </p>
    name: deadLetterErrorDescription
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending deadletter. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with deadletter reason and error description.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID,String,String)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify)
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter reason. </p>
    name: deadLetterReason
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter error description. </p>
    name: deadLetterErrorDescription
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending deadletter. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID,String,String,Map<String, Object>)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify, TransactionContext transaction)
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter reason. </p>
    name: deadLetterReason
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter error description. </p>
    name: deadLetterErrorDescription
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending deadletter. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with deadletter reason and error description and modified properties.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID,String,String,Map<String, Object>,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  name: deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter reason. </p>
    name: deadLetterReason
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The deadletter error description. </p>
    name: deadLetterErrorDescription
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending deadletter. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with deadletter reason and error description.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deadLetterAsync(UUID lockToken, String deadLetterReason, String deadLetterErrorDescription, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID,String,String,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID lockToken, TransactionContext transaction)
  name: deadLetterAsync(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.deadLetterAsync(UUID lockToken, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending deadletter. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously moves a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to the deadletter sub-queue with deadletter.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deadLetterAsync(UUID lockToken, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deadLetterAsync(UUID,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID lockToken)
  name: defer(UUID lockToken)
  nameWithType: IMessageReceiver.defer(UUID lockToken)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if defer failed </p>
  summary: >-
    <p>Defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token. This will move message into deferred subqueue.</p>

    <p></p>
  syntax: public void defer(UUID lockToken)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID lockToken, Map<String, Object> propertiesToModify)
  name: defer(UUID lockToken, Map<String, Object> propertiesToModify)
  nameWithType: IMessageReceiver.defer(UUID lockToken, Map<String, Object> propertiesToModify)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if defer failed </p>
  summary: >-
    <p>Defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token with modified message property. This will move message into deferred subqueue.</p>

    <p></p>
  syntax: public void defer(UUID lockToken, Map<String, Object> propertiesToModify)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID,Map<String, Object>)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  name: defer(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.defer(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if defer failed </p>
  summary: >-
    <p>Defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token with modified message property. This will move message into deferred subqueue.</p>

    <p></p>
  syntax: public void defer(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID,Map<String, Object>,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID lockToken, TransactionContext transaction)
  name: defer(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.defer(UUID lockToken, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if defer failed </p>
  summary: >-
    <p>Defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token. This will move message into deferred subqueue.</p>

    <p></p>
  syntax: public void defer(UUID lockToken, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.defer(UUID,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID lockToken)
  name: deferAsync(UUID lockToken)
  nameWithType: IMessageReceiver.deferAsync(UUID lockToken)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending defer. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token. This will move message into deferred subqueue.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deferAsync(UUID lockToken)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  name: deferAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  nameWithType: IMessageReceiver.deferAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending defer. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token with modified message propert. This will move message into deferred subqueue.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deferAsync(UUID lockToken, Map<String, Object> propertiesToModify)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID,Map<String, Object>)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  name: deferAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  nameWithType: IMessageReceiver.deferAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: <p>Message properties to modify. </p>
    name: propertiesToModify
    type: <xref href="Map%3CString%2C+Object%3E?alt=Map%3CString%2C+Object%3E&text=Map%3CString%2C+Object%3E" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending defer. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token with modified message propert. This will move message into deferred subqueue.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deferAsync(UUID lockToken, Map<String, Object> propertiesToModify, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID,Map<String, Object>,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID lockToken, TransactionContext transaction)
  name: deferAsync(UUID lockToken, TransactionContext transaction)
  nameWithType: IMessageReceiver.deferAsync(UUID lockToken, TransactionContext transaction)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  - description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.TransactionContext" data-throw-if-not-resolved="false" data-raw-source="TransactionContext"></xref> which this operation should enlist to. </p>
    name: transaction
    type: <xref href="com.microsoft.azure.servicebus.TransactionContext?alt=com.microsoft.azure.servicebus.TransactionContext&text=TransactionContext" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending defer. </p>
    type: <xref href="CompletableFuture%3CVoid%3E?alt=CompletableFuture%3CVoid%3E&text=CompletableFuture%3CVoid%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously defers a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> using its lock token. This will move message into deferred subqueue.</p>

    <p></p>
  syntax: public CompletableFuture<Void> deferAsync(UUID lockToken, TransactionContext transaction)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.deferAsync(UUID,TransactionContext)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.getPrefetchCount()
  name: getPrefetchCount()
  nameWithType: IMessageReceiver.getPrefetchCount()
  returns:
    description: <p>The set prefetch count value. </p>
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Get the prefetch value set.</p>

    <p></p>
  syntax: public int getPrefetchCount()
  uid: com.microsoft.azure.servicebus.IMessageReceiver.getPrefetchCount()
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.getReceiveMode()
  name: getReceiveMode()
  nameWithType: IMessageReceiver.getReceiveMode()
  returns:
    description: >-
      <p>

        <xref uid="com.microsoft.azure.servicebus.ReceiveMode" data-throw-if-not-resolved="false" data-raw-source="ReceiveMode"></xref>

      </p>
    type: <xref href="com.microsoft.azure.servicebus.ReceiveMode?alt=com.microsoft.azure.servicebus.ReceiveMode&text=ReceiveMode" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Get current receiver's <xref uid="com.microsoft.azure.servicebus.ReceiveMode" data-throw-if-not-resolved="false" data-raw-source="ReceiveMode"></xref>.</p>

    <p></p>
  syntax: public ReceiveMode getReceiveMode()
  uid: com.microsoft.azure.servicebus.IMessageReceiver.getReceiveMode()
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receive()
  name: receive()
  nameWithType: IMessageReceiver.receive()
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if receive failed </p>
  returns:
    description: <p>The received <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> or null if there is no message. </p>
    type: <xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Receives a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> with default server wait time.</p>

    <p></p>
  syntax: public IMessage receive()
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receive()
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receive(Duration serverWaitTime)
  name: receive(Duration serverWaitTime)
  nameWithType: IMessageReceiver.receive(Duration serverWaitTime)
  parameters:
  - description: <p>The server wait time </p>
    name: serverWaitTime
    type: <xref href="Duration?alt=Duration&text=Duration" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if receive failed </p>
  returns:
    description: <p>The received <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> or null if there is no message. </p>
    type: <xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Receives a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> with specified server wait time.</p>

    <p></p>
  syntax: public IMessage receive(Duration serverWaitTime)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receive(Duration)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync()
  name: receiveAsync()
  nameWithType: IMessageReceiver.receiveAsync()
  returns:
    description: <p>The message received. Returns null if no message is found </p>
    type: CompletableFuture&lt;<xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>&gt;
  summary: >-
    <p>Receives a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> from Azure Service Bus.</p>

    <p></p>
  syntax: public CompletableFuture<IMessage> receiveAsync()
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync()
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync(Duration serverWaitTime)
  name: receiveAsync(Duration serverWaitTime)
  nameWithType: IMessageReceiver.receiveAsync(Duration serverWaitTime)
  parameters:
  - description: <p>The time the client waits for receiving a message before it times out. </p>
    name: serverWaitTime
    type: <xref href="Duration?alt=Duration&text=Duration" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>The message received. Returns null if no message is found </p>
    type: CompletableFuture&lt;<xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>&gt;
  summary: >-
    <p>Receives a <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> from Azure Service Bus with server wait time.</p>

    <p></p>
  syntax: public CompletableFuture<IMessage> receiveAsync(Duration serverWaitTime)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveAsync(Duration)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch(int maxMessageCount)
  name: receiveBatch(int maxMessageCount)
  nameWithType: IMessageReceiver.receiveBatch(int maxMessageCount)
  parameters:
  - description: <p>The maximum number of messages that will be received. </p>
    name: maxMessageCount
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if receive failed </p>
  returns:
    description: <p>List of messages received. Returns null if no message is found. </p>
    type: Collection&lt;<xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>&gt;
  summary: >-
    <p>Receives a maximum of maxMessageCount <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> from Azure Service Bus.</p>

    <p></p>
  syntax: public Collection<IMessage> receiveBatch(int maxMessageCount)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch(int)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch(int maxMessageCount, Duration serverWaitTime)
  name: receiveBatch(int maxMessageCount, Duration serverWaitTime)
  nameWithType: IMessageReceiver.receiveBatch(int maxMessageCount, Duration serverWaitTime)
  parameters:
  - description: <p>The maximum number of messages that will be received. </p>
    name: maxMessageCount
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  - description: <p>The time the client waits for receiving a message before it times out. </p>
    name: serverWaitTime
    type: <xref href="Duration?alt=Duration&text=Duration" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if receive failed </p>
  returns:
    description: <p>List of messages received. Returns null if no message is found. </p>
    type: Collection&lt;<xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>&gt;
  summary: >-
    <p>Receives a maximum of maxMessageCount <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> from Azure Service Bus with server wait time.</p>

    <p></p>
  syntax: public Collection<IMessage> receiveBatch(int maxMessageCount, Duration serverWaitTime)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatch(int,Duration)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync(int maxMessageCount)
  name: receiveBatchAsync(int maxMessageCount)
  nameWithType: IMessageReceiver.receiveBatchAsync(int maxMessageCount)
  parameters:
  - description: <p>The maximum number of messages that will be received. </p>
    name: maxMessageCount
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending receive. </p>
    type: CompletableFuture&lt;Collection&lt;<xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>&gt;&gt;
  summary: >-
    <p>Asynchronously receives a maximum of maxMessageCount <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> from the entity.</p>

    <p></p>
  syntax: public CompletableFuture<Collection<IMessage>> receiveBatchAsync(int maxMessageCount)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync(int)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync(int maxMessageCount, Duration serverWaitTime)
  name: receiveBatchAsync(int maxMessageCount, Duration serverWaitTime)
  nameWithType: IMessageReceiver.receiveBatchAsync(int maxMessageCount, Duration serverWaitTime)
  parameters:
  - description: <p>The maximum number of messages that will be received. </p>
    name: maxMessageCount
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  - description: <p>The time the client waits for receiving a message before it times out. </p>
    name: serverWaitTime
    type: <xref href="Duration?alt=Duration&text=Duration" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending receive. </p>
    type: CompletableFuture&lt;Collection&lt;<xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>&gt;&gt;
  summary: >-
    <p>Asynchronously receives a maximum of maxMessageCount <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> from Azure Service Bus with server wait time.</p>

    <p></p>
  syntax: public CompletableFuture<Collection<IMessage>> receiveBatchAsync(int maxMessageCount, Duration serverWaitTime)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveBatchAsync(int,Duration)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessage(long sequenceNumber)
  name: receiveDeferredMessage(long sequenceNumber)
  nameWithType: IMessageReceiver.receiveDeferredMessage(long sequenceNumber)
  parameters:
  - description: <p>The <xref uid="com.microsoft.azure.servicebus.Message.getSequenceNumber()" data-throw-if-not-resolved="false" data-raw-source="Message#getSequenceNumber()"></xref>. </p>
    name: sequenceNumber
    type: <xref href="long?alt=long&text=long" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if receive failed </p>
  returns:
    description: <p>The received <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> or null if there is no message for given sequence number. </p>
    type: <xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Receives a deferred <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref>. Deferred messages can only be received by using sequence number.</p>

    <p></p>
  syntax: public IMessage receiveDeferredMessage(long sequenceNumber)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessage(long)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageAsync(long sequenceNumber)
  name: receiveDeferredMessageAsync(long sequenceNumber)
  nameWithType: IMessageReceiver.receiveDeferredMessageAsync(long sequenceNumber)
  parameters:
  - description: <p>The sequence number of the message that will be received. </p>
    name: sequenceNumber
    type: <xref href="long?alt=long&text=long" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending receive. </p>
    type: CompletableFuture&lt;<xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>&gt;
  summary: >-
    <p>Asynchronously receives a specific deferred <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> identified by sequence number.</p>

    <p></p>
  syntax: public CompletableFuture<IMessage> receiveDeferredMessageAsync(long sequenceNumber)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageAsync(long)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatch(Collection<Long> sequenceNumbers)
  name: receiveDeferredMessageBatch(Collection<Long> sequenceNumbers)
  nameWithType: IMessageReceiver.receiveDeferredMessageBatch(Collection<Long> sequenceNumbers)
  parameters:
  - description: <p>The sequence numbers of desired deferred messages. </p>
    name: sequenceNumbers
    type: <xref href="Collection%3CLong%3E?alt=Collection%3CLong%3E&text=Collection%3CLong%3E" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if receive failed </p>
  returns:
    description: <p>List of messages received. Returns null if no message is found. </p>
    type: Collection&lt;<xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>&gt;
  summary: >-
    <p>Receives a batch of deferred <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref>.</p>

    <p></p>
  syntax: public Collection<IMessage> receiveDeferredMessageBatch(Collection<Long> sequenceNumbers)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatch(Collection<Long>)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatchAsync(Collection<Long> sequenceNumbers)
  name: receiveDeferredMessageBatchAsync(Collection<Long> sequenceNumbers)
  nameWithType: IMessageReceiver.receiveDeferredMessageBatchAsync(Collection<Long> sequenceNumbers)
  parameters:
  - description: <p>The sequence numbers of the message that will be received. </p>
    name: sequenceNumbers
    type: <xref href="Collection%3CLong%3E?alt=Collection%3CLong%3E&text=Collection%3CLong%3E" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending receive. </p>
    type: CompletableFuture&lt;Collection&lt;<xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>&gt;&gt;
  summary: >-
    <p>Asynchronously receives a set of deferred <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> from the entity.</p>

    <p></p>
  syntax: public CompletableFuture<Collection<IMessage>> receiveDeferredMessageBatchAsync(Collection<Long> sequenceNumbers)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.receiveDeferredMessageBatchAsync(Collection<Long>)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock(IMessage message)
  name: renewMessageLock(IMessage message)
  nameWithType: IMessageReceiver.renewMessageLock(IMessage message)
  parameters:
  - description: <p>The <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to be renewed </p>
    name: message
    type: <xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if renew failed </p>
  returns:
    description: <p>The new locked until UTC time. </p>
    type: <xref href="Instant?alt=Instant&text=Instant" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Renews the lock on the message specified by the lock token. The lock will be renewed based on the setting specified on the entity. When a message is received in <xref uid="com.microsoft.azure.servicebus.ReceiveMode.PEEKLOCK" data-throw-if-not-resolved="false" data-raw-source="ReceiveMode#PEEKLOCK"></xref> mode, the message is locked on the server for this receiver instance for a duration as specified during the Queue/Subscription creation (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to the entity's LockDuration value.</p>

    <p></p>
  syntax: public Instant renewMessageLock(IMessage message)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock(IMessage)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock(UUID lockToken)
  name: renewMessageLock(UUID lockToken)
  nameWithType: IMessageReceiver.renewMessageLock(UUID lockToken)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if the current thread was interrupted while waiting </p>
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if renew failed </p>
  returns:
    description: <p>The new locked until UTC time. </p>
    type: <xref href="Instant?alt=Instant&text=Instant" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Renews the lock on the message specified by the lock token. The lock will be renewed based on the setting specified on the entity. When a message is received in <xref uid="com.microsoft.azure.servicebus.ReceiveMode.PEEKLOCK" data-throw-if-not-resolved="false" data-raw-source="ReceiveMode#PEEKLOCK"></xref> mode, the message is locked on the server for this receiver instance for a duration as specified during the Queue/Subscription creation (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to the entity's LockDuration value.</p>

    <p>Note - calling this will not update <xref uid="com.microsoft.azure.servicebus.Message.getLockedUntilUtc()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockedUntilUtc()"></xref> and updated lockedUntilUtc must be tracked by the application. </p>
  syntax: public Instant renewMessageLock(UUID lockToken)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLock(UUID)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync(IMessage message)
  name: renewMessageLockAsync(IMessage message)
  nameWithType: IMessageReceiver.renewMessageLockAsync(IMessage message)
  parameters:
  - description: <p>The <xref uid="com.microsoft.azure.servicebus.Message" data-throw-if-not-resolved="false" data-raw-source="Message"></xref> to be renewed </p>
    name: message
    type: <xref href="com.microsoft.azure.servicebus.IMessage?alt=com.microsoft.azure.servicebus.IMessage&text=IMessage" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending renew. </p>
    type: <xref href="CompletableFuture%3CInstant%3E?alt=CompletableFuture%3CInstant%3E&text=CompletableFuture%3CInstant%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Asynchronously renews the lock on the message specified by the lock token. The lock will be renewed based on the setting specified on the entity. When a message is received in <xref uid="com.microsoft.azure.servicebus.ReceiveMode.PEEKLOCK" data-throw-if-not-resolved="false" data-raw-source="ReceiveMode#PEEKLOCK"></xref> mode, the message is locked on the server for this receiver instance for a duration as specified during the Queue/Subscription creation (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to the entity's LockDuration value.</p>

    <p></p>
  syntax: public CompletableFuture<Instant> renewMessageLockAsync(IMessage message)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync(IMessage)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync(UUID lockToken)
  name: renewMessageLockAsync(UUID lockToken)
  nameWithType: IMessageReceiver.renewMessageLockAsync(UUID lockToken)
  parameters:
  - description: <p>Message lock token <xref uid="com.microsoft.azure.servicebus.Message.getLockToken()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockToken()"></xref></p>
    name: lockToken
    type: <xref href="UUID?alt=UUID&text=UUID" data-throw-if-not-resolved="False"/>
  returns:
    description: <p>a CompletableFuture representing the pending renew. </p>
    type: <xref href="CompletableFuture%3CInstant%3E?alt=CompletableFuture%3CInstant%3E&text=CompletableFuture%3CInstant%3E" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Renews the lock on the message specified by the lock token. The lock will be renewed based on the setting specified on the entity. When a message is received in <xref uid="com.microsoft.azure.servicebus.ReceiveMode.PEEKLOCK" data-throw-if-not-resolved="false" data-raw-source="ReceiveMode#PEEKLOCK"></xref> mode, the message is locked on the server for this receiver instance for a duration as specified during the Queue/Subscription creation (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to the entity's LockDuration value.</p>

    <p>Note - calling this will not update <xref uid="com.microsoft.azure.servicebus.Message.getLockedUntilUtc()" data-throw-if-not-resolved="false" data-raw-source="Message#getLockedUntilUtc()"></xref> and updated lockedUntilUtc must be tracked by the application. </p>
  syntax: public CompletableFuture<Instant> renewMessageLockAsync(UUID lockToken)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.renewMessageLockAsync(UUID)
- fullName: com.microsoft.azure.servicebus.IMessageReceiver.setPrefetchCount(int prefetchCount)
  name: setPrefetchCount(int prefetchCount)
  nameWithType: IMessageReceiver.setPrefetchCount(int prefetchCount)
  parameters:
  - description: <p>The desired prefetch count. </p>
    name: prefetchCount
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="ServiceBusException?alt=ServiceBusException&text=ServiceBusException" data-throw-if-not-resolved="False"/>
    description: <p>if sets the value failed </p>
  summary: >-
    <p>Set the prefetch count of the receiver. Prefetch speeds up the message flow by aiming to have a message readily available for local retrieval when and before the application asks for one using Receive. Setting a non-zero value prefetches PrefetchCount number of messages. Setting the value to zero turns prefetch off. For both PEEKLOCK mode and RECEIVEANDDELETE mode, the default value is 0. </p>

    <p>The value cannot be set until the receiver is created.</p>

    <p></p>
  syntax: public void setPrefetchCount(int prefetchCount)
  uid: com.microsoft.azure.servicebus.IMessageReceiver.setPrefetchCount(int)
nameWithType: IMessageReceiver
syntax: public interface IMessageReceiver extends IMessageEntityClient,IMessageBrowser
type: interface
uid: com.microsoft.azure.servicebus.IMessageReceiver
fullName: com.microsoft.azure.servicebus.IMessageReceiver
name: IMessageReceiver
package: com.microsoft.azure.servicebus
summary: <p>Defines message receiver interface. The MessageReceiver can be used to receive messages from Queues and Subscriptions and acknowledge them. </p>
metadata: {}
