### YamlMime:JavaType
uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient"
fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient"
name: "BlockBlobAsyncClient"
nameWithType: "BlockBlobAsyncClient"
summary: "Client to a block blob."
inheritances:
- "<xref href=\"java.lang.Object?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"com.azure.storage.blob.specialized.BlobAsyncClientBase?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.abortCopyFromUrl(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.abortCopyFromUrlWithResponse(java.lang.String,java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.beginCopy(com.azure.storage.blob.options.BlobBeginCopyOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.beginCopy(java.lang.String,java.time.Duration)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.beginCopy(java.lang.String,java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.AccessTier,com.azure.storage.blob.models.RehydratePriority,com.azure.core.http.RequestConditions,com.azure.storage.blob.models.BlobRequestConditions,java.time.Duration)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.copyFromUrl(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.copyFromUrlWithResponse(com.azure.storage.blob.options.BlobCopyFromUrlOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.copyFromUrlWithResponse(java.lang.String,java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.AccessTier,com.azure.core.http.RequestConditions,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.createSnapshot()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.createSnapshotWithResponse(java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.delete()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteIfExists()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteIfExistsWithResponse(com.azure.storage.blob.models.DeleteSnapshotsOptionType,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteImmutabilityPolicy()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteImmutabilityPolicyWithResponse()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteWithResponse(com.azure.storage.blob.models.DeleteSnapshotsOptionType,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.download()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadContent()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadContentWithResponse(com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadStream()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadStreamWithResponse(com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFile(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFile(java.lang.String,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFileWithResponse(com.azure.storage.blob.options.BlobDownloadToFileOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFileWithResponse(java.lang.String,com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.ParallelTransferOptions,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFileWithResponse(java.lang.String,com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.ParallelTransferOptions,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean,java.util.Set<java.nio.file.OpenOption>)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadWithResponse(com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.exists()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.existsWithResponse()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues,com.azure.core.util.Context)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateUserDelegationSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues,com.azure.storage.blob.models.UserDelegationKey)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateUserDelegationSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues,com.azure.storage.blob.models.UserDelegationKey,java.lang.String,com.azure.core.util.Context)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountInfo()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountInfoWithResponse()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountName()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountUrl()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getBlobName()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getBlobUrl()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getContainerAsyncClient()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getContainerName()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getCustomerProvidedKey()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getCustomerProvidedKeyAsyncClient(com.azure.storage.blob.models.CustomerProvidedKey)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getEncryptionScope()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getEncryptionScopeAsyncClient(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getHttpPipeline()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getProperties()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getPropertiesWithResponse(com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getServiceVersion()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getSnapshotClient(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getSnapshotId()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getTags()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getTagsWithResponse(com.azure.storage.blob.options.BlobGetTagsOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getVersionClient(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getVersionId()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.isSnapshot()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.query(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.queryWithResponse(com.azure.storage.blob.options.BlobQueryOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setAccessTier(com.azure.storage.blob.models.AccessTier)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setAccessTierWithResponse(com.azure.storage.blob.models.AccessTier,com.azure.storage.blob.models.RehydratePriority,java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setAccessTierWithResponse(com.azure.storage.blob.options.BlobSetAccessTierOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setHttpHeaders(com.azure.storage.blob.models.BlobHttpHeaders)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setHttpHeadersWithResponse(com.azure.storage.blob.models.BlobHttpHeaders,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setImmutabilityPolicy(com.azure.storage.blob.models.BlobImmutabilityPolicy)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setImmutabilityPolicyWithResponse(com.azure.storage.blob.models.BlobImmutabilityPolicy,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setLegalHold(boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setLegalHoldWithResponse(boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setMetadata(java.util.Map<java.lang.String,java.lang.String>)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setMetadataWithResponse(java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setTags(java.util.Map<java.lang.String,java.lang.String>)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setTagsWithResponse(com.azure.storage.blob.options.BlobSetTagsOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.undelete()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.undeleteWithResponse()"
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
syntax: "public final class BlockBlobAsyncClient extends BlobAsyncClientBase"
fields:
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_BLOCKS"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_BLOCKS"
  name: "MAX_BLOCKS"
  nameWithType: "BlockBlobAsyncClient.MAX_BLOCKS"
  summary: "Indicates the maximum number of blocks allowed in a block blob."
  modifiers:
  - "static"
  - "final"
  field:
    value: "50000"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final int MAX_BLOCKS"
  desc: "Indicates the maximum number of blocks allowed in a block blob."
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_STAGE_BLOCK_BYTES"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_STAGE_BLOCK_BYTES"
  name: "MAX_STAGE_BLOCK_BYTES"
  nameWithType: "BlockBlobAsyncClient.MAX_STAGE_BLOCK_BYTES"
  summary: "Indicates the maximum number of bytes that can be sent in a call to stage<wbr>Block."
  deprecatedTag: "Use <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_STAGE_BLOCK_BYTES_LONG\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#MAX_STAGE_BLOCK_BYTES_LONG\"></xref>"
  modifiers:
  - "static"
  - "final"
  field:
    value: "104857600"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "@Deprecated\npublic static final int MAX_STAGE_BLOCK_BYTES"
  desc: "Indicates the maximum number of bytes that can be sent in a call to stageBlock."
  hasDeprecatedTag: true
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_STAGE_BLOCK_BYTES_LONG"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_STAGE_BLOCK_BYTES_LONG"
  name: "MAX_STAGE_BLOCK_BYTES_LONG"
  nameWithType: "BlockBlobAsyncClient.MAX_STAGE_BLOCK_BYTES_LONG"
  summary: "Indicates the maximum number of bytes that can be sent in a call to stage<wbr>Block."
  modifiers:
  - "static"
  - "final"
  field:
    value: "4194304000"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final long MAX_STAGE_BLOCK_BYTES_LONG"
  desc: "Indicates the maximum number of bytes that can be sent in a call to stageBlock."
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_UPLOAD_BLOB_BYTES"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_UPLOAD_BLOB_BYTES"
  name: "MAX_UPLOAD_BLOB_BYTES"
  nameWithType: "BlockBlobAsyncClient.MAX_UPLOAD_BLOB_BYTES"
  summary: "Indicates the maximum number of bytes that can be sent in a call to upload."
  deprecatedTag: "Use <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_STAGE_BLOCK_BYTES_LONG\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#MAX_STAGE_BLOCK_BYTES_LONG\"></xref>"
  modifiers:
  - "static"
  - "final"
  field:
    value: "268435456"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "@Deprecated\npublic static final int MAX_UPLOAD_BLOB_BYTES"
  desc: "Indicates the maximum number of bytes that can be sent in a call to upload."
  hasDeprecatedTag: true
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_UPLOAD_BLOB_BYTES_LONG"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.MAX_UPLOAD_BLOB_BYTES_LONG"
  name: "MAX_UPLOAD_BLOB_BYTES_LONG"
  nameWithType: "BlockBlobAsyncClient.MAX_UPLOAD_BLOB_BYTES_LONG"
  summary: "Indicates the maximum number of bytes that can be sent in a call to upload."
  modifiers:
  - "static"
  - "final"
  field:
    value: "5242880000"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final long MAX_UPLOAD_BLOB_BYTES_LONG"
  desc: "Indicates the maximum number of bytes that can be sent in a call to upload."
methods:
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockList(java.util.List<java.lang.String>)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockList(List<String> base64BlockIds)"
  name: "commitBlockList(List<String> base64BlockIds)"
  nameWithType: "BlockBlobAsyncClient.commitBlockList(List<String> base64BlockIds)"
  summary: "Writes a blob by specifying the list of block IDs that are to make up the blob."
  parameters:
  - description: "A list of base64 encode <code>String</code>s that specifies the block IDs to be committed."
    name: "base64BlockIds"
    type: "<xref href=\"java.util.List?alt=java.util.List&text=List\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public Mono<BlockBlobItem> commitBlockList(List<String> base64BlockIds)"
  desc: "Writes a blob by specifying the list of block IDs that are to make up the blob. In order to be written as part of a blob, a block must have been successfully written to the server in a prior stageBlock operation. You can call commitBlockList to update a blob by uploading only those blocks that have changed, then committing the new and existing blocks together. Any blocks not specified in the block list and permanently deleted. For more information, see the [Azure Docs][].\n\n**Code Samples**\n\n```java\nclient.commitBlockList(Collections.singletonList(base64BlockID)).subscribe(response ->\n     System.out.printf(\"Committing block list completed. Last modified: %s%n\", response.getLastModified()));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-block-list"
  returns:
    description: "A reactive response containing the information of the block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockList(java.util.List<java.lang.String>,boolean)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockList(List<String> base64BlockIds, boolean overwrite)"
  name: "commitBlockList(List<String> base64BlockIds, boolean overwrite)"
  nameWithType: "BlockBlobAsyncClient.commitBlockList(List<String> base64BlockIds, boolean overwrite)"
  summary: "Writes a blob by specifying the list of block IDs that are to make up the blob."
  parameters:
  - description: "A list of base64 encode <code>String</code>s that specifies the block IDs to be committed."
    name: "base64BlockIds"
    type: "<xref href=\"java.util.List?alt=java.util.List&text=List\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "Whether to overwrite, should data exist on the blob."
    name: "overwrite"
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<BlockBlobItem> commitBlockList(List<String> base64BlockIds, boolean overwrite)"
  desc: "Writes a blob by specifying the list of block IDs that are to make up the blob. In order to be written as part of a blob, a block must have been successfully written to the server in a prior stageBlock operation. You can call commitBlockList to update a blob by uploading only those blocks that have changed, then committing the new and existing blocks together. Any blocks not specified in the block list and permanently deleted. For more information, see the [Azure Docs][].\n\n**Code Samples**\n\n```java\nboolean overwrite = false; // Default behavior\n client.commitBlockList(Collections.singletonList(base64BlockID), overwrite).subscribe(response ->\n     System.out.printf(\"Committing block list completed. Last modified: %s%n\", response.getLastModified()));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-block-list"
  returns:
    description: "A reactive response containing the information of the block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockListWithResponse(com.azure.storage.blob.options.BlockBlobCommitBlockListOptions)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockListWithResponse(BlockBlobCommitBlockListOptions options)"
  name: "commitBlockListWithResponse(BlockBlobCommitBlockListOptions options)"
  nameWithType: "BlockBlobAsyncClient.commitBlockListWithResponse(BlockBlobCommitBlockListOptions options)"
  summary: "Writes a blob by specifying the list of block IDs that are to make up the blob."
  parameters:
  - description: "<xref uid=\"com.azure.storage.blob.options.BlockBlobCommitBlockListOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobCommitBlockListOptions\"></xref>"
    name: "options"
    type: "<xref href=\"com.azure.storage.blob.options.BlockBlobCommitBlockListOptions?alt=com.azure.storage.blob.options.BlockBlobCommitBlockListOptions&text=BlockBlobCommitBlockListOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<BlockBlobItem>> commitBlockListWithResponse(BlockBlobCommitBlockListOptions options)"
  desc: "Writes a blob by specifying the list of block IDs that are to make up the blob. In order to be written as part of a blob, a block must have been successfully written to the server in a prior stageBlock operation. You can call commitBlockList to update a blob by uploading only those blocks that have changed, then committing the new and existing blocks together. Any blocks not specified in the block list and permanently deleted. For more information, see the [Azure Docs][].\n\nTo avoid overwriting, pass \"\\*\" to <xref uid=\"com.azure.storage.blob.models.BlobRequestConditions.setIfNoneMatch(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions#setIfNoneMatch(String)\"></xref>.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n     .setContentLanguage(\"en-US\")\n     .setContentType(\"binary\");\n\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n Map<String, String> tags = Collections.singletonMap(\"tag\", \"value\");\n BlobRequestConditions requestConditions = new BlobRequestConditions()\n     .setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n client.commitBlockListWithResponse(new BlockBlobCommitBlockListOptions(Collections.singletonList(base64BlockID))\n     .setHeaders(headers).setMetadata(metadata).setTags(tags).setTier(AccessTier.HOT)\n     .setRequestConditions(requestConditions))\n     .subscribe(response ->\n     System.out.printf(\"Committing block list completed with status %d%n\", response.getStatusCode()));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-block-list"
  returns:
    description: "A reactive response containing the information of the block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockListWithResponse(java.util.List<java.lang.String>,com.azure.storage.blob.models.BlobHttpHeaders,java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.AccessTier,com.azure.storage.blob.models.BlobRequestConditions)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockListWithResponse(List<String> base64BlockIds, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  name: "commitBlockListWithResponse(List<String> base64BlockIds, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  nameWithType: "BlockBlobAsyncClient.commitBlockListWithResponse(List<String> base64BlockIds, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  summary: "Writes a blob by specifying the list of block IDs that are to make up the blob."
  parameters:
  - description: "A list of base64 encode <code>String</code>s that specifies the block IDs to be committed."
    name: "base64BlockIds"
    type: "<xref href=\"java.util.List?alt=java.util.List&text=List\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobHttpHeaders\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobHttpHeaders\"></xref>"
    name: "headers"
    type: "<xref href=\"com.azure.storage.blob.models.BlobHttpHeaders?alt=com.azure.storage.blob.models.BlobHttpHeaders&text=BlobHttpHeaders\" data-throw-if-not-resolved=\"False\" />"
  - description: "Metadata to associate with the blob. If there is leading or trailing whitespace in any\n metadata key or value, it must be removed or encoded."
    name: "metadata"
    type: "<xref href=\"java.util.Map?alt=java.util.Map&text=Map\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />,<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "<xref uid=\"com.azure.storage.blob.models.AccessTier\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AccessTier\"></xref> for the destination blob."
    name: "tier"
    type: "<xref href=\"com.azure.storage.blob.models.AccessTier?alt=com.azure.storage.blob.models.AccessTier&text=AccessTier\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobRequestConditions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions\"></xref>"
    name: "requestConditions"
    type: "<xref href=\"com.azure.storage.blob.models.BlobRequestConditions?alt=com.azure.storage.blob.models.BlobRequestConditions&text=BlobRequestConditions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<BlockBlobItem>> commitBlockListWithResponse(List<String> base64BlockIds, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  desc: "Writes a blob by specifying the list of block IDs that are to make up the blob. In order to be written as part of a blob, a block must have been successfully written to the server in a prior stageBlock operation. You can call commitBlockList to update a blob by uploading only those blocks that have changed, then committing the new and existing blocks together. Any blocks not specified in the block list and permanently deleted. For more information, see the [Azure Docs][].\n\nTo avoid overwriting, pass \"\\*\" to <xref uid=\"com.azure.storage.blob.models.BlobRequestConditions.setIfNoneMatch(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions#setIfNoneMatch(String)\"></xref>.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n     .setContentLanguage(\"en-US\")\n     .setContentType(\"binary\");\n\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n BlobRequestConditions requestConditions = new BlobRequestConditions()\n     .setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n client.commitBlockListWithResponse(Collections.singletonList(base64BlockID), headers, metadata,\n     AccessTier.HOT, requestConditions).subscribe(response ->\n         System.out.printf(\"Committing block list completed with status %d%n\", response.getStatusCode()));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-block-list"
  returns:
    description: "A reactive response containing the information of the block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.getCustomerProvidedKeyAsyncClient(com.azure.storage.blob.models.CustomerProvidedKey)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  name: "getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  nameWithType: "BlockBlobAsyncClient.getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  summary: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobAsyncClient\"></xref> with the specified `customerProvidedKey`."
  overridden: "com.azure.storage.blob.specialized.BlobAsyncClientBase.getCustomerProvidedKeyAsyncClient(com.azure.storage.blob.models.CustomerProvidedKey)"
  parameters:
  - description: "the <xref uid=\"com.azure.storage.blob.models.CustomerProvidedKey\" data-throw-if-not-resolved=\"false\" data-raw-source=\"CustomerProvidedKey\"></xref> for the blob,\n pass <code>null</code> to use no customer provided key."
    name: "customerProvidedKey"
    type: "<xref href=\"com.azure.storage.blob.models.CustomerProvidedKey?alt=com.azure.storage.blob.models.CustomerProvidedKey&text=CustomerProvidedKey\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public BlockBlobAsyncClient getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  desc: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobAsyncClient\"></xref> with the specified `customerProvidedKey`."
  returns:
    description: "a <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobAsyncClient\"></xref> with the specified <code>customerProvidedKey</code>."
    type: "<xref href=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient?alt=com.azure.storage.blob.specialized.BlockBlobAsyncClient&text=BlockBlobAsyncClient\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.getEncryptionScopeAsyncClient(java.lang.String)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.getEncryptionScopeAsyncClient(String encryptionScope)"
  name: "getEncryptionScopeAsyncClient(String encryptionScope)"
  nameWithType: "BlockBlobAsyncClient.getEncryptionScopeAsyncClient(String encryptionScope)"
  summary: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobAsyncClient\"></xref> with the specified `encryptionScope`."
  overridden: "com.azure.storage.blob.specialized.BlobAsyncClientBase.getEncryptionScopeAsyncClient(java.lang.String)"
  parameters:
  - description: "the encryption scope for the blob, pass <code>null</code> to use no encryption scope."
    name: "encryptionScope"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public BlockBlobAsyncClient getEncryptionScopeAsyncClient(String encryptionScope)"
  desc: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobAsyncClient\"></xref> with the specified `encryptionScope`."
  returns:
    description: "a <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobAsyncClient\"></xref> with the specified <code>encryptionScope</code>."
    type: "<xref href=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient?alt=com.azure.storage.blob.specialized.BlockBlobAsyncClient&text=BlockBlobAsyncClient\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.listBlocks(com.azure.storage.blob.models.BlockListType)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.listBlocks(BlockListType listType)"
  name: "listBlocks(BlockListType listType)"
  nameWithType: "BlockBlobAsyncClient.listBlocks(BlockListType listType)"
  summary: "Returns the list of blocks that have been uploaded as part of a block blob using the specified block list filter."
  parameters:
  - description: "Specifies which type of blocks to return."
    name: "listType"
    type: "<xref href=\"com.azure.storage.blob.models.BlockListType?alt=com.azure.storage.blob.models.BlockListType&text=BlockListType\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<BlockList> listBlocks(BlockListType listType)"
  desc: "Returns the list of blocks that have been uploaded as part of a block blob using the specified block list filter. For more information, see the [Azure Docs][].\n\n**Code Samples**\n\n```java\nclient.listBlocks(BlockListType.ALL).subscribe(block -> {\n     System.out.println(\"Committed Blocks:\");\n     block.getCommittedBlocks().forEach(b -> System.out.printf(\"Name: %s, Size: %d\", b.getName(), b.getSizeLong()));\n\n     System.out.println(\"Uncommitted Blocks:\");\n     block.getUncommittedBlocks().forEach(b -> System.out.printf(\"Name: %s, Size: %d\", b.getName(), b.getSizeLong()));\n });\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/get-block-list"
  returns:
    description: "A reactive response containing the list of blocks."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockList?alt=com.azure.storage.blob.models.BlockList&text=BlockList\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.listBlocksWithResponse(com.azure.storage.blob.models.BlockListType,java.lang.String)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.listBlocksWithResponse(BlockListType listType, String leaseId)"
  name: "listBlocksWithResponse(BlockListType listType, String leaseId)"
  nameWithType: "BlockBlobAsyncClient.listBlocksWithResponse(BlockListType listType, String leaseId)"
  summary: "Returns the list of blocks that have been uploaded as part of a block blob using the specified block list filter."
  parameters:
  - description: "Specifies which type of blocks to return."
    name: "listType"
    type: "<xref href=\"com.azure.storage.blob.models.BlockListType?alt=com.azure.storage.blob.models.BlockListType&text=BlockListType\" data-throw-if-not-resolved=\"False\" />"
  - description: "The lease ID the active lease on the blob must match."
    name: "leaseId"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<BlockList>> listBlocksWithResponse(BlockListType listType, String leaseId)"
  desc: "Returns the list of blocks that have been uploaded as part of a block blob using the specified block list filter. For more information, see the [Azure Docs][].\n\n**Code Samples**\n\n```java\nclient.listBlocksWithResponse(BlockListType.ALL, leaseId).subscribe(response -> {\n     BlockList block = response.getValue();\n     System.out.println(\"Committed Blocks:\");\n     block.getCommittedBlocks().forEach(b -> System.out.printf(\"Name: %s, Size: %d\", b.getName(), b.getSizeLong()));\n\n     System.out.println(\"Uncommitted Blocks:\");\n     block.getUncommittedBlocks().forEach(b -> System.out.printf(\"Name: %s, Size: %d\", b.getName(), b.getSizeLong()));\n });\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/get-block-list"
  returns:
    description: "A reactive response containing the list of blocks."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockList?alt=com.azure.storage.blob.models.BlockList&text=BlockList\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.listBlocksWithResponse(com.azure.storage.blob.options.BlockBlobListBlocksOptions)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.listBlocksWithResponse(BlockBlobListBlocksOptions options)"
  name: "listBlocksWithResponse(BlockBlobListBlocksOptions options)"
  nameWithType: "BlockBlobAsyncClient.listBlocksWithResponse(BlockBlobListBlocksOptions options)"
  summary: "Returns the list of blocks that have been uploaded as part of a block blob using the specified block list filter."
  parameters:
  - description: "<xref uid=\"com.azure.storage.blob.options.BlockBlobListBlocksOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobListBlocksOptions\"></xref>"
    name: "options"
    type: "<xref href=\"com.azure.storage.blob.options.BlockBlobListBlocksOptions?alt=com.azure.storage.blob.options.BlockBlobListBlocksOptions&text=BlockBlobListBlocksOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<BlockList>> listBlocksWithResponse(BlockBlobListBlocksOptions options)"
  desc: "Returns the list of blocks that have been uploaded as part of a block blob using the specified block list filter. For more information, see the [Azure Docs][].\n\n**Code Samples**\n\n```java\nclient.listBlocksWithResponse(new BlockBlobListBlocksOptions(BlockListType.ALL)\n     .setLeaseId(leaseId)\n     .setIfTagsMatch(tags)).subscribe(response -> {\n         BlockList block = response.getValue();\n         System.out.println(\"Committed Blocks:\");\n         block.getCommittedBlocks().forEach(b -> System.out.printf(\"Name: %s, Size: %d\", b.getName(),\n             b.getSizeLong()));\n\n         System.out.println(\"Uncommitted Blocks:\");\n         block.getUncommittedBlocks().forEach(b -> System.out.printf(\"Name: %s, Size: %d\", b.getName(),\n             b.getSizeLong()));\n     });\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/get-block-list"
  returns:
    description: "A reactive response containing the list of blocks."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockList?alt=com.azure.storage.blob.models.BlockList&text=BlockList\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlock(java.lang.String,reactor.core.publisher.Flux<java.nio.ByteBuffer>,long)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlock(String base64BlockId, Flux<ByteBuffer> data, long length)"
  name: "stageBlock(String base64BlockId, Flux<ByteBuffer> data, long length)"
  nameWithType: "BlockBlobAsyncClient.stageBlock(String base64BlockId, Flux<ByteBuffer> data, long length)"
  summary: "Uploads the specified block to the block blob's \"staging area\" to be later committed by a call to commit<wbr>Block<wbr>List."
  parameters:
  - description: "A Base64 encoded <code>String</code> that specifies the ID for this block. Note that all block\n ids for a given blob must be the same length."
    name: "base64BlockId"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The data to write to the block. Note that this <code>Flux</code> must be replayable if retries are enabled\n (the default). In other words, the <code>Flux</code> must produce the same data each time it is subscribed to."
    name: "data"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "The exact length of the data. It is important that this value match precisely the length of the\n data emitted by the <code>Flux</code>."
    name: "length"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> stageBlock(String base64BlockId, Flux<ByteBuffer> data, long length)"
  desc: "Uploads the specified block to the block blob's \"staging area\" to be later committed by a call to commitBlockList. For more information, see the [Azure Docs][].\n\nNote that the data passed must be replayable if retries are enabled (the default). In other words, the\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-block"
  returns:
    description: "A reactive response signalling completion.\n\n <p><strong>Code Samples</strong></p>\n\n <!-- src_embed com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlock#String-Flux-long -->\n <pre>\n client.stageBlock&#40;base64BlockID, data, length&#41;\n     .subscribe&#40;\n         response -&gt; System.out.println&#40;&quot;Staging block completed&quot;&#41;,\n         error -&gt; System.out.printf&#40;&quot;Error when calling stage Block: %s&quot;, error&#41;&#41;;\n </pre>\n <!-- end com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlock#String-Flux-long -->"
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlockFromUrl(java.lang.String,java.lang.String,com.azure.storage.blob.models.BlobRange)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlockFromUrl(String base64BlockId, String sourceUrl, BlobRange sourceRange)"
  name: "stageBlockFromUrl(String base64BlockId, String sourceUrl, BlobRange sourceRange)"
  nameWithType: "BlockBlobAsyncClient.stageBlockFromUrl(String base64BlockId, String sourceUrl, BlobRange sourceRange)"
  summary: "Creates a new block to be committed as part of a blob where the contents are read from a URL."
  parameters:
  - description: "A Base64 encoded <code>String</code> that specifies the ID for this block. Note that all block\n ids for a given blob must be the same length."
    name: "base64BlockId"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The url to the blob that will be the source of the copy.  A source blob in the same storage\n account can be authenticated via Shared Key. However, if the source is a blob in another account, the source blob\n must either be public or must be authenticated via a shared access signature. If the source blob is public, no\n authentication is required to perform the operation."
    name: "sourceUrl"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobRange\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRange\"></xref>"
    name: "sourceRange"
    type: "<xref href=\"com.azure.storage.blob.models.BlobRange?alt=com.azure.storage.blob.models.BlobRange&text=BlobRange\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> stageBlockFromUrl(String base64BlockId, String sourceUrl, BlobRange sourceRange)"
  desc: "Creates a new block to be committed as part of a blob where the contents are read from a URL. For more information, see the [Azure Docs][].\n\n**Code Samples**\n\n```java\nclient.stageBlockFromUrl(base64BlockID, sourceUrl, new BlobRange(offset, count))\n     .subscribe(\n         response -> System.out.println(\"Staging block completed\"),\n         error -> System.out.printf(\"Error when calling stage Block: %s\", error));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-block-from-url"
  returns:
    description: "A reactive response signalling completion."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlockFromUrlWithResponse(com.azure.storage.blob.options.BlockBlobStageBlockFromUrlOptions)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlockFromUrlWithResponse(BlockBlobStageBlockFromUrlOptions options)"
  name: "stageBlockFromUrlWithResponse(BlockBlobStageBlockFromUrlOptions options)"
  nameWithType: "BlockBlobAsyncClient.stageBlockFromUrlWithResponse(BlockBlobStageBlockFromUrlOptions options)"
  summary: "Creates a new block to be committed as part of a blob where the contents are read from a URL."
  parameters:
  - description: "parameters for the operation."
    name: "options"
    type: "<xref href=\"com.azure.storage.blob.options.BlockBlobStageBlockFromUrlOptions?alt=com.azure.storage.blob.options.BlockBlobStageBlockFromUrlOptions&text=BlockBlobStageBlockFromUrlOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<Void>> stageBlockFromUrlWithResponse(BlockBlobStageBlockFromUrlOptions options)"
  desc: "Creates a new block to be committed as part of a blob where the contents are read from a URL. For more information, see the [Azure Docs][].\n\n**Code Samples**\n\n```java\nBlobRequestConditions sourceRequestConditions = new BlobRequestConditions()\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.stageBlockFromUrlWithResponse(new BlockBlobStageBlockFromUrlOptions(base64BlockID, sourceUrl)\n     .setSourceRange(new BlobRange(offset, count)).setLeaseId(leaseId)\n     .setSourceRequestConditions(sourceRequestConditions)).subscribe(response ->\n     System.out.printf(\"Staging block from URL completed with status %d%n\", response.getStatusCode()));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-block-from-url"
  returns:
    description: "A reactive response signalling completion."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlockFromUrlWithResponse(java.lang.String,java.lang.String,com.azure.storage.blob.models.BlobRange,byte[],java.lang.String,com.azure.storage.blob.models.BlobRequestConditions)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlockFromUrlWithResponse(String base64BlockId, String sourceUrl, BlobRange sourceRange, byte[] sourceContentMd5, String leaseId, BlobRequestConditions sourceRequestConditions)"
  name: "stageBlockFromUrlWithResponse(String base64BlockId, String sourceUrl, BlobRange sourceRange, byte[] sourceContentMd5, String leaseId, BlobRequestConditions sourceRequestConditions)"
  nameWithType: "BlockBlobAsyncClient.stageBlockFromUrlWithResponse(String base64BlockId, String sourceUrl, BlobRange sourceRange, byte[] sourceContentMd5, String leaseId, BlobRequestConditions sourceRequestConditions)"
  summary: "Creates a new block to be committed as part of a blob where the contents are read from a URL."
  parameters:
  - description: "A Base64 encoded <code>String</code> that specifies the ID for this block. Note that all block\n ids for a given blob must be the same length."
    name: "base64BlockId"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The url to the blob that will be the source of the copy.  A source blob in the same storage\n account can be authenticated via Shared Key. However, if the source is a blob in another account, the source blob\n must either be public or must be authenticated via a shared access signature. If the source blob is public, no\n authentication is required to perform the operation."
    name: "sourceUrl"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobRange\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRange\"></xref>"
    name: "sourceRange"
    type: "<xref href=\"com.azure.storage.blob.models.BlobRange?alt=com.azure.storage.blob.models.BlobRange&text=BlobRange\" data-throw-if-not-resolved=\"False\" />"
  - description: "An MD5 hash of the block content. This hash is used to verify the integrity of the block\n during transport. When this header is specified, the storage service compares the hash of the content that has\n arrived with this header value. Note that this MD5 hash is not stored with the blob. If the two hashes do not\n match, the operation will fail."
    name: "sourceContentMd5"
    type: "<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]"
  - description: "The lease ID that the active lease on the blob must match."
    name: "leaseId"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobRequestConditions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions\"></xref>"
    name: "sourceRequestConditions"
    type: "<xref href=\"com.azure.storage.blob.models.BlobRequestConditions?alt=com.azure.storage.blob.models.BlobRequestConditions&text=BlobRequestConditions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<Void>> stageBlockFromUrlWithResponse(String base64BlockId, String sourceUrl, BlobRange sourceRange, byte[] sourceContentMd5, String leaseId, BlobRequestConditions sourceRequestConditions)"
  desc: "Creates a new block to be committed as part of a blob where the contents are read from a URL. For more information, see the [Azure Docs][].\n\n**Code Samples**\n\n```java\nBlobRequestConditions sourceRequestConditions = new BlobRequestConditions()\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.stageBlockFromUrlWithResponse(base64BlockID, sourceUrl, new BlobRange(offset, count), null,\n     leaseId, sourceRequestConditions).subscribe(response ->\n     System.out.printf(\"Staging block from URL completed with status %d%n\", response.getStatusCode()));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-block-from-url"
  returns:
    description: "A reactive response signalling completion."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlockWithResponse(java.lang.String,reactor.core.publisher.Flux<java.nio.ByteBuffer>,long,byte[],java.lang.String)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlockWithResponse(String base64BlockId, Flux<ByteBuffer> data, long length, byte[] contentMd5, String leaseId)"
  name: "stageBlockWithResponse(String base64BlockId, Flux<ByteBuffer> data, long length, byte[] contentMd5, String leaseId)"
  nameWithType: "BlockBlobAsyncClient.stageBlockWithResponse(String base64BlockId, Flux<ByteBuffer> data, long length, byte[] contentMd5, String leaseId)"
  summary: "Uploads the specified block to the block blob's \"staging area\" to be later committed by a call to commit<wbr>Block<wbr>List."
  parameters:
  - description: "A Base64 encoded <code>String</code> that specifies the ID for this block. Note that all block\n ids for a given blob must be the same length."
    name: "base64BlockId"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The data to write to the block. Note that this <code>Flux</code> must be replayable if retries are enabled\n (the default). In other words, the Flux must produce the same data each time it is subscribed to."
    name: "data"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "The exact length of the data. It is important that this value match precisely the length of the\n data emitted by the <code>Flux</code>."
    name: "length"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  - description: "An MD5 hash of the block content. This hash is used to verify the integrity of the block during\n transport. When this header is specified, the storage service compares the hash of the content that has arrived\n with this header value. Note that this MD5 hash is not stored with the blob. If the two hashes do not match, the\n operation will fail."
    name: "contentMd5"
    type: "<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]"
  - description: "The lease ID the active lease on the blob must match."
    name: "leaseId"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<Void>> stageBlockWithResponse(String base64BlockId, Flux<ByteBuffer> data, long length, byte[] contentMd5, String leaseId)"
  desc: "Uploads the specified block to the block blob's \"staging area\" to be later committed by a call to commitBlockList. For more information, see the [Azure Docs][].\n\nNote that the data passed must be replayable if retries are enabled (the default). In other words, the `Flux` must produce the same data each time it is subscribed to.\n\n**Code Samples**\n\n```java\nclient.stageBlockWithResponse(base64BlockID, data, length, md5, leaseId).subscribe(response ->\n     System.out.printf(\"Staging block completed with status %d%n\", response.getStatusCode()));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-block"
  returns:
    description: "A reactive response signalling completion."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.upload(reactor.core.publisher.Flux<java.nio.ByteBuffer>,long)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.upload(Flux<ByteBuffer> data, long length)"
  name: "upload(Flux<ByteBuffer> data, long length)"
  nameWithType: "BlockBlobAsyncClient.upload(Flux<ByteBuffer> data, long length)"
  summary: "Creates a new block blob."
  parameters:
  - description: "The data to write to the blob. Note that this <code>Flux</code> must be replayable if retries are enabled\n (the default). In other words, the Flux must produce the same data each time it is subscribed to."
    name: "data"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "The exact length of the data. It is important that this value match precisely the length of the\n data emitted by the <code>Flux</code>."
    name: "length"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<BlockBlobItem> upload(Flux<ByteBuffer> data, long length)"
  desc: "Creates a new block blob. By default, this method will not overwrite an existing blob. Updating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with PutBlob; the content of the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use PutBlock and PutBlockList. For more information, see the [Azure Docs][].\n\nNote that the data passed must be replayable if retries are enabled (the default). In other words, the `Flux` must produce the same data each time it is subscribed to.\n\n**Code Samples**\n\n```java\nclient.upload(data, length).subscribe(response ->\n     System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getContentMd5())));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-blob"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.upload(reactor.core.publisher.Flux<java.nio.ByteBuffer>,long,boolean)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.upload(Flux<ByteBuffer> data, long length, boolean overwrite)"
  name: "upload(Flux<ByteBuffer> data, long length, boolean overwrite)"
  nameWithType: "BlockBlobAsyncClient.upload(Flux<ByteBuffer> data, long length, boolean overwrite)"
  summary: "Creates a new block blob, or updates the content of an existing block blob."
  parameters:
  - description: "The data to write to the blob. Note that this <code>Flux</code> must be replayable if retries are enabled\n (the default). In other words, the Flux must produce the same data each time it is subscribed to."
    name: "data"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "The exact length of the data. It is important that this value match precisely the length of the\n data emitted by the <code>Flux</code>."
    name: "length"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  - description: "Whether to overwrite, should data exist on the blob."
    name: "overwrite"
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<BlockBlobItem> upload(Flux<ByteBuffer> data, long length, boolean overwrite)"
  desc: "Creates a new block blob, or updates the content of an existing block blob. Updating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with PutBlob; the content of the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use PutBlock and PutBlockList. For more information, see the [Azure Docs][].\n\nNote that the data passed must be replayable if retries are enabled (the default). In other words, the `Flux` must produce the same data each time it is subscribed to.\n\n**Code Samples**\n\n```java\nboolean overwrite = false; // Default behavior\n client.upload(data, length, overwrite).subscribe(response ->\n     System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getContentMd5())));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-blob"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.uploadFromUrl(java.lang.String)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.uploadFromUrl(String sourceUrl)"
  name: "uploadFromUrl(String sourceUrl)"
  nameWithType: "BlockBlobAsyncClient.uploadFromUrl(String sourceUrl)"
  summary: "Creates a new block blob, or updates the content of an existing block blob."
  parameters:
  - description: "The source URL to upload from."
    name: "sourceUrl"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<BlockBlobItem> uploadFromUrl(String sourceUrl)"
  desc: "Creates a new block blob, or updates the content of an existing block blob.\n\nUpdating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with PutBlobFromUrl; the content of the existing blob is overwritten with the new content. For more information, see the [Azure Docs][].\n\n**Code Samples**\n\n```java\nclient.uploadFromUrl(sourceUrl)\n     .subscribe(response ->\n         System.out.printf(\"Uploaded BlockBlob from URL, MD5 is %s%n\",\n             Base64.getEncoder().encodeToString(response.getContentMd5())));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-blob-from-url"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.uploadFromUrl(java.lang.String,boolean)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.uploadFromUrl(String sourceUrl, boolean overwrite)"
  name: "uploadFromUrl(String sourceUrl, boolean overwrite)"
  nameWithType: "BlockBlobAsyncClient.uploadFromUrl(String sourceUrl, boolean overwrite)"
  summary: "Creates a new block blob, or updates the content of an existing block blob."
  parameters:
  - description: "The source URL to upload from."
    name: "sourceUrl"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "Whether to overwrite, should data exist on the blob."
    name: "overwrite"
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<BlockBlobItem> uploadFromUrl(String sourceUrl, boolean overwrite)"
  desc: "Creates a new block blob, or updates the content of an existing block blob.\n\nUpdating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with PutBlobFromUrl; the content of the existing blob is overwritten with the new content. For more information, see the [Azure Docs][].\n\n**Code Samples**\n\n```java\nboolean overwrite = false; // Default behavior\n client.uploadFromUrl(sourceUrl, overwrite).subscribe(response ->\n     System.out.printf(\"Uploaded BlockBlob from URL, MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getContentMd5())));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-blob-from-url"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.uploadFromUrlWithResponse(com.azure.storage.blob.options.BlobUploadFromUrlOptions)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.uploadFromUrlWithResponse(BlobUploadFromUrlOptions options)"
  name: "uploadFromUrlWithResponse(BlobUploadFromUrlOptions options)"
  nameWithType: "BlockBlobAsyncClient.uploadFromUrlWithResponse(BlobUploadFromUrlOptions options)"
  summary: "Creates a new block blob, or updates the content of an existing block blob."
  parameters:
  - description: "<xref uid=\"com.azure.storage.blob.options.BlobUploadFromUrlOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobUploadFromUrlOptions\"></xref>"
    name: "options"
    type: "<xref href=\"com.azure.storage.blob.options.BlobUploadFromUrlOptions?alt=com.azure.storage.blob.options.BlobUploadFromUrlOptions&text=BlobUploadFromUrlOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<BlockBlobItem>> uploadFromUrlWithResponse(BlobUploadFromUrlOptions options)"
  desc: "Creates a new block blob, or updates the content of an existing block blob.\n\nUpdating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with PutBlobFromUrl; the content of the existing blob is overwritten with the new content. For more information, see the [Azure Docs][].\n\nTo avoid overwriting, pass \"\\*\" to <xref uid=\"com.azure.storage.blob.models.BlobRequestConditions.setIfNoneMatch(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions#setIfNoneMatch(String)\"></xref>.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n     .setContentLanguage(\"en-US\")\n     .setContentType(\"binary\");\n\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n Map<String, String> tags = Collections.singletonMap(\"tag\", \"value\");\n byte[] md5 = MessageDigest.getInstance(\"MD5\").digest(\"data\".getBytes(StandardCharsets.UTF_8));\n BlobRequestConditions requestConditions = new BlobRequestConditions()\n     .setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.uploadFromUrlWithResponse(new BlobUploadFromUrlOptions(sourceUrl).setHeaders(headers)\n     .setTags(tags).setTier(AccessTier.HOT).setContentMd5(md5)\n     .setDestinationRequestConditions(requestConditions))\n     .subscribe(response -> System.out.printf(\"Uploaded BlockBlob from URL, MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getValue().getContentMd5())));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-blob-from-url"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.uploadWithResponse(com.azure.storage.blob.options.BlockBlobSimpleUploadOptions)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.uploadWithResponse(BlockBlobSimpleUploadOptions options)"
  name: "uploadWithResponse(BlockBlobSimpleUploadOptions options)"
  nameWithType: "BlockBlobAsyncClient.uploadWithResponse(BlockBlobSimpleUploadOptions options)"
  summary: "Creates a new block blob, or updates the content of an existing block blob."
  parameters:
  - description: "<xref uid=\"com.azure.storage.blob.options.BlockBlobSimpleUploadOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobSimpleUploadOptions\"></xref>"
    name: "options"
    type: "<xref href=\"com.azure.storage.blob.options.BlockBlobSimpleUploadOptions?alt=com.azure.storage.blob.options.BlockBlobSimpleUploadOptions&text=BlockBlobSimpleUploadOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<BlockBlobItem>> uploadWithResponse(BlockBlobSimpleUploadOptions options)"
  desc: "Creates a new block blob, or updates the content of an existing block blob.\n\nUpdating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with PutBlob; the content of the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use PutBlock and PutBlockList. For more information, see the [Azure Docs][].\n\nNote that the data passed must be replayable if retries are enabled (the default). In other words, the `Flux` must produce the same data each time it is subscribed to.\n\nTo avoid overwriting, pass \"\\*\" to <xref uid=\"com.azure.storage.blob.models.BlobRequestConditions.setIfNoneMatch(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions#setIfNoneMatch(String)\"></xref>.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n     .setContentLanguage(\"en-US\")\n     .setContentType(\"binary\");\n\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n Map<String, String> tags = Collections.singletonMap(\"tag\", \"value\");\n byte[] md5 = MessageDigest.getInstance(\"MD5\").digest(\"data\".getBytes(StandardCharsets.UTF_8));\n BlobRequestConditions requestConditions = new BlobRequestConditions()\n     .setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.uploadWithResponse(new BlockBlobSimpleUploadOptions(data, length).setHeaders(headers)\n     .setMetadata(metadata).setTags(tags).setTier(AccessTier.HOT).setContentMd5(md5)\n     .setRequestConditions(requestConditions))\n     .subscribe(response -> System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getValue().getContentMd5())));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-blob"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.uploadWithResponse(reactor.core.publisher.Flux<java.nio.ByteBuffer>,long,com.azure.storage.blob.models.BlobHttpHeaders,java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.AccessTier,byte[],com.azure.storage.blob.models.BlobRequestConditions)"
  fullName: "com.azure.storage.blob.specialized.BlockBlobAsyncClient.uploadWithResponse(Flux<ByteBuffer> data, long length, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, byte[] contentMd5, BlobRequestConditions requestConditions)"
  name: "uploadWithResponse(Flux<ByteBuffer> data, long length, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, byte[] contentMd5, BlobRequestConditions requestConditions)"
  nameWithType: "BlockBlobAsyncClient.uploadWithResponse(Flux<ByteBuffer> data, long length, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, byte[] contentMd5, BlobRequestConditions requestConditions)"
  summary: "Creates a new block blob, or updates the content of an existing block blob."
  parameters:
  - description: "The data to write to the blob. Note that this <code>Flux</code> must be replayable if retries are enabled\n (the default). In other words, the Flux must produce the same data each time it is subscribed to."
    name: "data"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "The exact length of the data. It is important that this value match precisely the length of the\n data emitted by the <code>Flux</code>."
    name: "length"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobHttpHeaders\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobHttpHeaders\"></xref>"
    name: "headers"
    type: "<xref href=\"com.azure.storage.blob.models.BlobHttpHeaders?alt=com.azure.storage.blob.models.BlobHttpHeaders&text=BlobHttpHeaders\" data-throw-if-not-resolved=\"False\" />"
  - description: "Metadata to associate with the blob. If there is leading or trailing whitespace in any\n metadata key or value, it must be removed or encoded."
    name: "metadata"
    type: "<xref href=\"java.util.Map?alt=java.util.Map&text=Map\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />,<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "<xref uid=\"com.azure.storage.blob.models.AccessTier\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AccessTier\"></xref> for the destination blob."
    name: "tier"
    type: "<xref href=\"com.azure.storage.blob.models.AccessTier?alt=com.azure.storage.blob.models.AccessTier&text=AccessTier\" data-throw-if-not-resolved=\"False\" />"
  - description: "An MD5 hash of the blob content. This hash is used to verify the integrity of the blob during\n transport. When this header is specified, the storage service compares the hash of the content that has arrived\n with this header value. Note that this MD5 hash is not stored with the blob. If the two hashes do not match, the\n operation will fail."
    name: "contentMd5"
    type: "<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobRequestConditions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions\"></xref>"
    name: "requestConditions"
    type: "<xref href=\"com.azure.storage.blob.models.BlobRequestConditions?alt=com.azure.storage.blob.models.BlobRequestConditions&text=BlobRequestConditions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<BlockBlobItem>> uploadWithResponse(Flux<ByteBuffer> data, long length, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, byte[] contentMd5, BlobRequestConditions requestConditions)"
  desc: "Creates a new block blob, or updates the content of an existing block blob.\n\nUpdating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with PutBlob; the content of the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use PutBlock and PutBlockList. For more information, see the [Azure Docs][].\n\nNote that the data passed must be replayable if retries are enabled (the default). In other words, the `Flux` must produce the same data each time it is subscribed to.\n\nTo avoid overwriting, pass \"\\*\" to <xref uid=\"com.azure.storage.blob.models.BlobRequestConditions.setIfNoneMatch(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions#setIfNoneMatch(String)\"></xref>.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n     .setContentLanguage(\"en-US\")\n     .setContentType(\"binary\");\n\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n byte[] md5 = MessageDigest.getInstance(\"MD5\").digest(\"data\".getBytes(StandardCharsets.UTF_8));\n BlobRequestConditions requestConditions = new BlobRequestConditions()\n     .setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.uploadWithResponse(data, length, headers, metadata, AccessTier.HOT, md5, requestConditions)\n     .subscribe(response -> System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getValue().getContentMd5())));\n```\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/put-blob"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
type: "class"
desc: "Client to a block blob. It may only be instantiated through a <xref uid=\"com.azure.storage.blob.specialized.SpecializedBlobClientBuilder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SpecializedBlobClientBuilder\"></xref> or via the method <xref uid=\"com.azure.storage.blob.BlobAsyncClient.getBlockBlobAsyncClient()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient#getBlockBlobAsyncClient()\"></xref>. This class does not hold any state about a particular blob, but is instead a convenient way of sending appropriate requests to the resource on the service.\n\nPlease refer to the [Azure Docs][] for more information.\n\nNote this client is an async client that returns reactive responses from Spring Reactor Core project (https://projectreactor.io/). Calling the methods in this client will **NOT** start the actual network operation, until `.subscribe()` is called on the reactive response. You can simply convert one of these responses to a <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"java.util.concurrent.CompletableFuture\"></xref> object through <xref uid=\"reactor.core.publisher.Mono.toFuture*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono#toFuture()\"></xref>.\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs"
metadata: {}
package: "com.azure.storage.blob.specialized"
artifact: com.azure:azure-storage-blob:12.18.0-beta.1
