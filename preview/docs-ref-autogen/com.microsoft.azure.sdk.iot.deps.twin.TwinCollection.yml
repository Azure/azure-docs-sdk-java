### YamlMime:JavaType
uid: "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection"
fullName: "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection"
name: "TwinCollection"
nameWithType: "TwinCollection"
summary: "Representation of a single Twin collection.\n\nThe TwinCollection is an extension of a `HashMap` of `String` and `Object` that contain individual and general versioning mechanism.\n\nBy the Twin definition, the `Object` can contain types of `Boolean`, `Number`, `String`, `Object`, or a sub-TwinCollection, but it cannot be types defined by the user or arrays.\n\nA TwinCollection can contain up to 5 levels of sub TwinCollections. Once the TwinCollection is a extension of the `HashMap`, both TwinCollection as well as its sub-TwinCollections can be casted to Map of String and Object.\n\nThe collection will be represented in the rest API as a JSON in the body. It can or cannot contain the metadata (identified by the **$** character at the beginning of the key.\n\nBecause of the Twin metadata, the character **$** is not allowed in the entry key.\n\nFor instance, the following JSON is a valid TwinCollection with its metadata.\n\n```java\n{\n     \"Color\":\"White\",\n     \"MaxSpeed\":{\n         \"Value\":500,\n         \"NewValue\":300\n     },\n     \"$metadata\":{\n         \"$lastUpdated\":\"2017-09-21T02:07:44.238Z\",\n         \"$lastUpdatedVersion\":4,\n         \"Color\":{\n             \"$lastUpdated\":\"2017-09-21T02:07:44.238Z\",\n             \"$lastUpdatedVersion\":4,\n         },\n         \"MaxSpeed\":{\n             \"$lastUpdated\":\"2017-09-21T02:07:44.238Z\",\n             \"$lastUpdatedVersion\":4,\n             \"Value\":{\n                 \"$lastUpdated\":\"2017-09-21T02:07:44.238Z\",\n                 \"$lastUpdatedVersion\":4\n             },\n             \"NewValue\":{\n                 \"$lastUpdated\":\"2017-09-21T02:07:44.238Z\",\n                 \"$lastUpdatedVersion\":4\n             }\n         }\n     },\n     \"$version\":4\n }\n```\n\nThis class exposes the Twin collection with or without metadata as a Map here user can gat both the value and the metadata. For instance, in the above TwinCollection, <xref uid=\"com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.get*\" data-throw-if-not-resolved=\"false\">#get(Object)</xref> for **Color** will return **White** and the <xref uid=\"com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.getTwinMetadataFinal(java.lang.String)\" data-throw-if-not-resolved=\"false\">#getTwinMetadataFinal(String)</xref> for **Color** will return the Object TwinMetadata that contain <xref uid=\"com.microsoft.azure.sdk.iot.deps.twin.TwinMetadata.getLastUpdated()\" data-throw-if-not-resolved=\"false\">TwinMetadata#getLastUpdated()</xref> that will returns the `Date` **2017-09-21T02:07:44.238Z** and <xref uid=\"com.microsoft.azure.sdk.iot.deps.twin.TwinMetadata.getLastUpdatedVersion()\" data-throw-if-not-resolved=\"false\">TwinMetadata#getLastUpdatedVersion()</xref> that will returns the `Integer` **4**.\n\nFor the nested TwinCollection, you can do the same, for instance, the following code will return the value and metadata of the **NewValue** nested in **MaxSpeed**:\n\n```java\n// Get the value of the MaxSpeed, which is a inner TwinCollection.\n      TwinCollection innerMaxSpeed = (TwinCollection) twinCollection.get(\"MaxSpeed\");\n\n      // From the inner TwinCollection, get the value of the NewValue.\n      Long maxSpeedNewValue = innerMaxSpeed.get(\"NewValue\");\n\n      // As in the root TwinCollection, the inner TwinCollection contain its own metadata.\n      // So, get the metadata information for the inner NewValue.\n      TwinMetadata maxSpeedNewValueMetadata = innerMaxSpeed.getTwinMetadataFinal(\"NewValue\");\n      Date newValueLastUpdated = maxSpeedNewValueMetadata.getLastUpdated(); //Shall contain `2017-09-21T02:07:44.238Z`\n      Integer newValueLastUpdatedVersion = maxSpeedNewValueMetadata.getLastUpdatedVersion(); //Shall contain `4`\n```"
inheritances:
- "<xref href=\"java.lang.Object\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"java.util.AbstractMap\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"java.util.HashMap\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
- "java.util.AbstractMap.equals(java.lang.Object)"
- "java.util.AbstractMap.hashCode()"
- "java.util.AbstractMap.toString()"
- "java.util.HashMap.clear()"
- "java.util.HashMap.clone()"
- "java.util.HashMap.compute(K,java.util.function.BiFunction<? super K,? super V,? extends V>)"
- "java.util.HashMap.computeIfAbsent(K,java.util.function.Function<? super K,? extends V>)"
- "java.util.HashMap.computeIfPresent(K,java.util.function.BiFunction<? super K,? super V,? extends V>)"
- "java.util.HashMap.containsKey(java.lang.Object)"
- "java.util.HashMap.containsValue(java.lang.Object)"
- "java.util.HashMap.entrySet()"
- "java.util.HashMap.forEach(java.util.function.BiConsumer<? super K,? super V>)"
- "java.util.HashMap.get(java.lang.Object)"
- "java.util.HashMap.getOrDefault(java.lang.Object,V)"
- "java.util.HashMap.isEmpty()"
- "java.util.HashMap.keySet()"
- "java.util.HashMap.merge(K,V,java.util.function.BiFunction<? super V,? super V,? extends V>)"
- "java.util.HashMap.put(K,V)"
- "java.util.HashMap.putAll(java.util.Map<? extends K,? extends V>)"
- "java.util.HashMap.putIfAbsent(K,V)"
- "java.util.HashMap.remove(java.lang.Object)"
- "java.util.HashMap.remove(java.lang.Object,java.lang.Object)"
- "java.util.HashMap.replace(K,V)"
- "java.util.HashMap.replace(K,V,V)"
- "java.util.HashMap.replaceAll(java.util.function.BiFunction<? super K,? super V,? extends V>)"
- "java.util.HashMap.size()"
- "java.util.HashMap.values()"
syntax: "public class TwinCollection extends HashMap<String,Object>"
constructors:
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.TwinCollection()"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.TwinCollection(com.microsoft.azure.sdk.iot.deps.twin.TwinCollection)"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.TwinCollection(java.util.Map<? extends java.lang.String,java.lang.Object>)"
methods:
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.createFromRawCollection(java.util.Map<? extends java.lang.String,java.lang.Object>)"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.getTwinMetadata()"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.getTwinMetadata(java.lang.String)"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.getTwinMetadataFinal()"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.getTwinMetadataFinal(java.lang.String)"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.getVersion()"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.getVersionFinal()"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.put(java.lang.String,java.lang.Object)"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.putAll(java.util.Map<? extends java.lang.String,?>)"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.putAllFinal(java.util.Map<? extends java.lang.String,?>)"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.putFinal(java.lang.String,java.lang.Object)"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.toJsonElement()"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.toJsonElementWithMetadata()"
- "com.microsoft.azure.sdk.iot.deps.twin.TwinCollection.toString()"
type: "class"
metadata: {}
package: "com.microsoft.azure.sdk.iot.deps.twin"
artifact: com.microsoft.azure.sdk.iot:iot-deps-preview:1.1.0
