### YamlMime:ManagedReference
items:
- uid: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials
  id: KeyVaultCredentials
  parent: com.microsoft.azure.keyvault.authentication
  children:
  - com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter(OkHttpClient.Builder)
  - com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String,String,String)
  - com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String,String,String,String)
  href: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.yml
  langs:
  - java
  name: KeyVaultCredentials
  nameWithType: KeyVaultCredentials
  fullName: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials
  type: Class
  source:
    remote: &o0
      path: sdk/keyvault/microsoft-azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
      branch: master
      repo: https://github.com/Azure/azure-sdk-for-java
    path: sdk/keyvault/microsoft-azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
    startLine: 33
  package: com.microsoft.azure.keyvault.authentication
  summary: "<p>An implementation of <xref uid=\"\" data-throw-if-not-resolved=\"false\">ServiceClientCredentials</xref> that supports automatic bearer token refresh. </p>"
  syntax:
    content: public class KeyVaultCredentials
  inheritance:
  - java.lang.Object
  - ServiceClientCredentials
- uid: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter(OkHttpClient.Builder)
  id: Builder)
  parent: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials
  href: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.yml
  langs:
  - java
  name: applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
  nameWithType: KeyVaultCredentials.applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
  fullName: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
  overload: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter*
  type: Method
  source:
    remote: *o0
    path: sdk/keyvault/microsoft-azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
    startLine: 47
  package: com.microsoft.azure.keyvault.authentication
  syntax:
    content: public void applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
    parameters:
    - id: clientBuilder
      type: 2c0be77c
- uid: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String,String,String)
  id: doAuthenticate(String,String,String)
  parent: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials
  href: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.yml
  langs:
  - java
  name: doAuthenticate(String authorization, String resource, String scope)
  nameWithType: KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)
  fullName: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)
  overload: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate*
  type: Method
  source:
    remote: *o0
    path: sdk/keyvault/microsoft-azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
    startLine: 324
  package: com.microsoft.azure.keyvault.authentication
  summary: "<p>Abstract method to be implemented.</p>\r\n<p>\r\nAnswers a server challenge with a token header. </p>\r\n<p>Implementations typically use ADAL to get a token, as performed in the sample below: </p>\r\n<p>\r\n  <pre>\r\n&amp;#064;Override\r\npublic String doAuthenticate(String authorization, String resource, String scope) {\r\n    String clientId = ...; // client GUID as shown in Azure portal.\r\n    String clientKey = ...; // client key as provided by Azure portal.\r\n    AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId, clientKey);\r\n    return token.getAccessToken();;\r\n}</pre>\r\n</p>\r\n<p>\r\n  <pre>private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource, String clientId, String clientKey) {\r\n    AuthenticationContext context = null;\r\n    AuthenticationResult result = null;\r\n    ExecutorService service = null;\r\n    try {\r\n        service = Executors.newFixedThreadPool(1);\r\n        context = new AuthenticationContext(authorization, false, service);\r\n        ClientCredential credentials = new ClientCredential(clientId, clientKey);\r\n        Future&lt;AuthenticationResult&gt; future = context.acquireToken(resource, credentials, null);\r\n        result = future.get();\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    } finally {\r\n        service.shutdown();\r\n    }</pre>\r\n</p>\r\n<p>\r\n  <pre>    if (result == null) {\r\n        throw new RuntimeException(\"authentication result was null\");\r\n    }\r\n    return result;\r\n}\r\n        </pre>\r\n</p>\r\n<p>\r\n  <b>Note: The client key must be securely stored. It's advised to use two client applications - one for development and other for production - managed by separate parties.</b>\r\n</p>"
  syntax:
    content: public String doAuthenticate(String authorization, String resource, String scope)
    parameters:
    - id: authorization
      type: "26831127"
      description: <p>Identifier of the authority, a URL. </p>
    - id: resource
      type: "26831127"
      description: <p>Identifier of the target resource that is the recipient of the requested token, a URL.</p>
    - id: scope
      type: "26831127"
      description: <p>The scope of the authentication request.</p>
    return:
      type: "26831127"
      description: <p>AuthenticationResult with authorization token and PoP key.</p>
- uid: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String,String,String,String)
  id: doAuthenticate(String,String,String,String)
  parent: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials
  href: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.yml
  langs:
  - java
  name: doAuthenticate(String authorization, String resource, String scope, String schema)
  nameWithType: KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope, String schema)
  fullName: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope, String schema)
  overload: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate*
  type: Method
  source:
    remote: *o0
    path: sdk/keyvault/microsoft-azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
    startLine: 415
  package: com.microsoft.azure.keyvault.authentication
  summary: "<p>Method to be implemented.</p>\r\n<p>\r\nAnswers a server challenge with a token header. </p>\r\n<p>Implementations sends POST request to receive authentication token like in example below. ADAL currently doesn't support POP authentication. </p>\r\n<p>\r\n  <pre>\r\n        public AuthenticationResult doAuthenticate(String authorization, String resource, String scope, String schema) {\r\n            JsonWebKey clientJwk = GenerateJsonWebKey();\r\n            JsonWebKey clientPublicJwk = GetJwkWithPublicKeyOnly(clientJwk);\r\n            String token = GetAccessToken(authorization, resource, \"pop\".equals(schema), clientPublicJwk);</pre>\r\n</p>\r\n<p>\r\n  <pre>            return new AuthenticationResult(token, clientJwk.toString());\r\n        }</pre>\r\n</p>\r\n<p>\r\n  <pre>        private JsonWebKey GenerateJsonWebKey() {\r\n            final KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\");\r\n            generator.initialize(2048);\r\n            KeyPair clientRsaKeyPair = generator.generateKeyPair();\r\n            JsonWebKey result = JsonWebKey.fromRSA(clientRsaKeyPair);\r\n            result.withKid(UUID.randomUUID().toString());\r\n            return result;\r\n        }</pre>\r\n</p>\r\n<p>\r\n  <pre>        public static JsonWebKey GetJwkWithPublicKeyOnly(JsonWebKey jwk) {\r\n            KeyPair publicOnly = jwk.toRSA(false);\r\n            JsonWebKey jsonkeyPublic = JsonWebKey.fromRSA(publicOnly);\r\n            jsonkeyPublic.withKid(jwk.kid());\r\n            jsonkeyPublic.withKeyOps(Arrays.asList(JsonWebKeyOperation.ENCRYPT, JsonWebKeyOperation.WRAP_KEY,\r\n                    JsonWebKeyOperation.VERIFY));\r\n            return jsonkeyPublic;\r\n        }</pre>\r\n</p>\r\n<p>\r\n  <pre>        private String GetAccessToken(String authorization, String resource, boolean supportspop, JsonWebKey jwkPublic) {\r\n            CloseableHttpClient httpclient = HttpClients.createDefault();\r\n            HttpPost httppost = new HttpPost(authorization + \"/oauth2/token\");</pre>\r\n</p>\r\n<p>\r\n  <pre>            // Request parameters and other properties.\r\n            List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;(2);\r\n            params.add(new BasicNameValuePair(\"resource\", resource));\r\n            params.add(new BasicNameValuePair(\"response_type\", \"token\"));\r\n            params.add(new BasicNameValuePair(\"grant_type\", \"client_credentials\"));\r\n            params.add(new BasicNameValuePair(\"client_id\", this.getApplicationId()));\r\n            params.add(new BasicNameValuePair(\"client_secret\", this.getApplicationSecret()));</pre>\r\n</p>\r\n<p>\r\n  <pre>            if (supportspop) {\r\n                params.add(new BasicNameValuePair(\"pop_jwk\", jwkPublic.toString()));\r\n            }</pre>\r\n</p>\r\n<p>\r\n  <pre>            httppost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));</pre>\r\n</p>\r\n<p>\r\n  <pre>            HttpResponse response = httpclient.execute(httppost);\r\n            HttpEntity entity = response.getEntity();</pre>\r\n</p>\r\n<p>\r\n  <pre>            // Read the contents of an entity and return it as a String.\r\n            String content = EntityUtils.toString(entity);</pre>\r\n</p>\r\n<p>\r\n  <pre>            ObjectMapper mapper = new ObjectMapper();\r\n            authreply reply = mapper.readValue(content, authreply.class);</pre>\r\n</p>\r\n<p>\r\n  <pre>            return reply.access_token;\r\n        }\r\n        </pre>\r\n</p>\r\n<p>\r\n  <b>Note: The client key must be securely stored. It's advised to use two client applications - one for development and other for production - managed by separate parties.</b>\r\n</p>"
  syntax:
    content: public AuthenticationResult doAuthenticate(String authorization, String resource, String scope, String schema)
    parameters:
    - id: authorization
      type: "26831127"
      description: <p>Identifier of the authority, a URL. </p>
    - id: resource
      type: "26831127"
      description: <p>Identifier of the target resource that is the recipient of the requested token, a URL. </p>
    - id: scope
      type: "26831127"
      description: <p>The scope of the authentication request.</p>
    - id: schema
      type: "26831127"
      description: <p>Authentication schema. Can be 'pop' or 'bearer'.</p>
    return:
      type: com.microsoft.azure.keyvault.authentication.AuthenticationResult
      description: <p>AuthenticationResult with authorization token and PoP key.</p>
references:
- uid: 2c0be77c
  spec.java:
  - name: OkHttpClient.Builder
    fullName: OkHttpClient.Builder
- uid: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter*
  name: applyCredentialsFilter
  nameWithType: KeyVaultCredentials.applyCredentialsFilter
  fullName: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter
  package: com.microsoft.azure.keyvault.authentication
- uid: "26831127"
  spec.java:
  - name: String
    fullName: String
- uid: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate*
  name: doAuthenticate
  nameWithType: KeyVaultCredentials.doAuthenticate
  fullName: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate
  package: com.microsoft.azure.keyvault.authentication
- uid: com.microsoft.azure.keyvault.webkey.JsonWebKey
  parent: com.microsoft.azure.keyvault.webkey
  href: com.microsoft.azure.keyvault.webkey.JsonWebKey.yml
  name: JsonWebKey
  nameWithType: JsonWebKey
  fullName: com.microsoft.azure.keyvault.webkey.JsonWebKey
  type: Class
  summary: "<p>As of <a href=\"http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18\">http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18</a>. </p>"
  syntax:
    content: public class JsonWebKey
- uid: com.microsoft.azure.keyvault.authentication.AuthenticationResult
  parent: com.microsoft.azure.keyvault.authentication
  href: com.microsoft.azure.keyvault.authentication.AuthenticationResult.yml
  name: AuthenticationResult
  nameWithType: AuthenticationResult
  fullName: com.microsoft.azure.keyvault.authentication.AuthenticationResult
  type: Class
  summary: "<p>Stores authentication token and client key used for proof of possession authentication. </p>"
  syntax:
    content: public class AuthenticationResult
- uid: com.microsoft.azure.keyvault.messagesecurity.HttpMessageSecurity
  parent: com.microsoft.azure.keyvault.messagesecurity
  href: com.microsoft.azure.keyvault.messagesecurity.HttpMessageSecurity.yml
  name: HttpMessageSecurity
  nameWithType: HttpMessageSecurity
  fullName: com.microsoft.azure.keyvault.messagesecurity.HttpMessageSecurity
  type: Class
  summary: "<p>Implements message security protocol. Encrypts requests &amp; decrypts responses. </p>"
  syntax:
    content: public class HttpMessageSecurity
