### YamlMime:JavaMember
uid: "com.azure.cosmos.implementation.guava25.collect.Multimaps.filterKeys*"
fullName: "com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys"
name: "<K,V>filterKeys"
nameWithType: "Multimaps.<K,V>filterKeys"
members:
- uid: "com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.ListMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)"
  fullName: "com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(ListMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  name: "<K,V>filterKeys(ListMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  nameWithType: "Multimaps.<K,V>filterKeys(ListMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  summary: "Returns a multimap containing the mappings in `unfiltered` whose keys satisfy a predicate. The returned multimap is a live view of `unfiltered`; changes to one affect the other.\n\nThe resulting multimap's views have iterators that don't support `remove()`, but all other methods are supported by the multimap and its views. When adding a key that doesn't satisfy the predicate, the multimap's `put()`, `putAll()`, and `replaceValues()` methods throw an <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"IllegalArgumentException\"></xref>.\n\nWhen methods such as `removeAll()` and `clear()` are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap.\n\nThe returned multimap isn't threadsafe or serializable, even if `unfiltered` is.\n\nMany of the filtered multimap's methods, such as `size()`, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered multimap and use the copy.\n\n**Warning:** `keyPredicate` must be *consistent with equals*, as documented at <xref uid=\"com.azure.cosmos.implementation.guava25.base.Predicate.apply\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Predicate#apply\"></xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals."
  parameters:
  - name: "unfiltered"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.ListMultimap?alt=com.azure.cosmos.implementation.guava25.collect.ListMultimap&text=ListMultimap\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V?alt=V&text=V\" data-throw-if-not-resolved=\"False\" />&gt;"
  - name: "keyPredicate"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.base.Predicate?alt=com.azure.cosmos.implementation.guava25.base.Predicate&text=Predicate\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"? super K?alt=? super K&text=? super K\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static ListMultimap<K,V> <K,V>filterKeys(ListMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  returns:
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.ListMultimap?alt=com.azure.cosmos.implementation.guava25.collect.ListMultimap&text=ListMultimap\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V?alt=V&text=V\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)"
  fullName: "com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(Multimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  name: "<K,V>filterKeys(Multimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  nameWithType: "Multimaps.<K,V>filterKeys(Multimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  summary: "Returns a multimap containing the mappings in `unfiltered` whose keys satisfy a predicate. The returned multimap is a live view of `unfiltered`; changes to one affect the other.\n\nThe resulting multimap's views have iterators that don't support `remove()`, but all other methods are supported by the multimap and its views. When adding a key that doesn't satisfy the predicate, the multimap's `put()`, `putAll()`, and `replaceValues()` methods throw an <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"IllegalArgumentException\"></xref>.\n\nWhen methods such as `removeAll()` and `clear()` are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap.\n\nThe returned multimap isn't threadsafe or serializable, even if `unfiltered` is.\n\nMany of the filtered multimap's methods, such as `size()`, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered multimap and use the copy.\n\n**Warning:** `keyPredicate` must be *consistent with equals*, as documented at <xref uid=\"com.azure.cosmos.implementation.guava25.base.Predicate.apply\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Predicate#apply\"></xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals."
  parameters:
  - name: "unfiltered"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.Multimap?alt=com.azure.cosmos.implementation.guava25.collect.Multimap&text=Multimap\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V?alt=V&text=V\" data-throw-if-not-resolved=\"False\" />&gt;"
  - name: "keyPredicate"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.base.Predicate?alt=com.azure.cosmos.implementation.guava25.base.Predicate&text=Predicate\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"? super K?alt=? super K&text=? super K\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static Multimap<K,V> <K,V>filterKeys(Multimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  returns:
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.Multimap?alt=com.azure.cosmos.implementation.guava25.collect.Multimap&text=Multimap\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V?alt=V&text=V\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(com.azure.cosmos.implementation.guava25.collect.SetMultimap<K,V>,com.azure.cosmos.implementation.guava25.base.Predicate<? super K>)"
  fullName: "com.azure.cosmos.implementation.guava25.collect.Multimaps.<K,V>filterKeys(SetMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  name: "<K,V>filterKeys(SetMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  nameWithType: "Multimaps.<K,V>filterKeys(SetMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  summary: "Returns a multimap containing the mappings in `unfiltered` whose keys satisfy a predicate. The returned multimap is a live view of `unfiltered`; changes to one affect the other.\n\nThe resulting multimap's views have iterators that don't support `remove()`, but all other methods are supported by the multimap and its views. When adding a key that doesn't satisfy the predicate, the multimap's `put()`, `putAll()`, and `replaceValues()` methods throw an <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"IllegalArgumentException\"></xref>.\n\nWhen methods such as `removeAll()` and `clear()` are called on the filtered multimap or its views, only mappings whose keys satisfy the filter will be removed from the underlying multimap.\n\nThe returned multimap isn't threadsafe or serializable, even if `unfiltered` is.\n\nMany of the filtered multimap's methods, such as `size()`, iterate across every key/value mapping in the underlying multimap and determine which satisfy the filter. When a live view is *not* needed, it may be faster to copy the filtered multimap and use the copy.\n\n**Warning:** `keyPredicate` must be *consistent with equals*, as documented at <xref uid=\"com.azure.cosmos.implementation.guava25.base.Predicate.apply\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Predicate#apply\"></xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals."
  parameters:
  - name: "unfiltered"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.SetMultimap?alt=com.azure.cosmos.implementation.guava25.collect.SetMultimap&text=SetMultimap\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V?alt=V&text=V\" data-throw-if-not-resolved=\"False\" />&gt;"
  - name: "keyPredicate"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.base.Predicate?alt=com.azure.cosmos.implementation.guava25.base.Predicate&text=Predicate\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"? super K?alt=? super K&text=? super K\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static SetMultimap<K,V> <K,V>filterKeys(SetMultimap<K,V> unfiltered, Predicate<? super K> keyPredicate)"
  returns:
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.SetMultimap?alt=com.azure.cosmos.implementation.guava25.collect.SetMultimap&text=SetMultimap\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V?alt=V&text=V\" data-throw-if-not-resolved=\"False\" />&gt;"
type: "method"
metadata: {}
package: "com.azure.cosmos.implementation.guava25.collect"
artifact: com.azure:azure-cosmos:4.4.0-beta.1
