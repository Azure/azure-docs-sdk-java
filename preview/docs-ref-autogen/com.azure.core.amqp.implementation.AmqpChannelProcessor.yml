### YamlMime:JavaType
uid: "com.azure.core.amqp.implementation.AmqpChannelProcessor"
fullName: "com.azure.core.amqp.implementation.AmqpChannelProcessor<T>"
name: "AmqpChannelProcessor<T>"
nameWithType: "AmqpChannelProcessor<T>"
inheritances:
- "<xref href=\"java.lang.Object\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
- "reactor.core.publisher.Mono.<E>cast(java.lang.Class<E>)"
- "reactor.core.publisher.Mono.<E>doOnError(java.lang.Class<E>,java.util.function.Consumer<? super E>)"
- "reactor.core.publisher.Mono.<E>onErrorContinue(java.lang.Class<E>,java.util.function.BiConsumer<java.lang.Throwable,java.lang.Object>)"
- "reactor.core.publisher.Mono.<E>onErrorContinue(java.util.function.Predicate<E>,java.util.function.BiConsumer<java.lang.Throwable,java.lang.Object>)"
- "reactor.core.publisher.Mono.<E>onErrorMap(java.lang.Class<E>,java.util.function.Function<? super E,? extends java.lang.Throwable>)"
- "reactor.core.publisher.Mono.<E>onErrorResume(java.lang.Class<E>,java.util.function.Function<? super E,? extends reactor.core.publisher.Mono<? extends T>>)"
- "reactor.core.publisher.Mono.<E>onErrorReturn(java.lang.Class<E>,T)"
- "reactor.core.publisher.Mono.<E>subscribeWith(E)"
- "reactor.core.publisher.Mono.<I>fromDirect(org.reactivestreams.Publisher<? extends I>)"
- "reactor.core.publisher.Mono.<P>as(java.util.function.Function<? super reactor.core.publisher.Mono<T>,P>)"
- "reactor.core.publisher.Mono.<R>doOnDiscard(java.lang.Class<R>,java.util.function.Consumer<? super R>)"
- "reactor.core.publisher.Mono.<R>flatMap(java.util.function.Function<? super T,? extends reactor.core.publisher.Mono<? extends R>>)"
- "reactor.core.publisher.Mono.<R>flatMapIterable(java.util.function.Function<? super T,? extends java.lang.Iterable<? extends R>>)"
- "reactor.core.publisher.Mono.<R>flatMapMany(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends R>>)"
- "reactor.core.publisher.Mono.<R>flatMapMany(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends R>>,java.util.function.Function<? super java.lang.Throwable,? extends org.reactivestreams.Publisher<? extends R>>,java.util.function.Supplier<? extends org.reactivestreams.Publisher<? extends R>>)"
- "reactor.core.publisher.Mono.<R>handle(java.util.function.BiConsumer<? super T,reactor.core.publisher.SynchronousSink<R>>)"
- "reactor.core.publisher.Mono.<R>map(java.util.function.Function<? super T,? extends R>)"
- "reactor.core.publisher.Mono.<R>publish(java.util.function.Function<? super reactor.core.publisher.Mono<T>,? extends reactor.core.publisher.Mono<? extends R>>)"
- "reactor.core.publisher.Mono.<R>zip(java.lang.Iterable<? extends reactor.core.publisher.Mono<?>>,java.util.function.Function<? super java.lang.Object[],? extends R>)"
- "reactor.core.publisher.Mono.<R>zip(java.util.function.Function<? super java.lang.Object[],? extends R>,reactor.core.publisher.Mono<?>...)"
- "reactor.core.publisher.Mono.<R>zipDelayError(java.lang.Iterable<? extends reactor.core.publisher.Mono<?>>,java.util.function.Function<? super java.lang.Object[],? extends R>)"
- "reactor.core.publisher.Mono.<R>zipDelayError(java.util.function.Function<? super java.lang.Object[],? extends R>,reactor.core.publisher.Mono<?>...)"
- "reactor.core.publisher.Mono.<T,D>using(java.util.concurrent.Callable<? extends D>,java.util.function.Function<? super D,? extends reactor.core.publisher.Mono<? extends T>>,java.util.function.Consumer<? super D>)"
- "reactor.core.publisher.Mono.<T,D>using(java.util.concurrent.Callable<? extends D>,java.util.function.Function<? super D,? extends reactor.core.publisher.Mono<? extends T>>,java.util.function.Consumer<? super D>,boolean)"
- "reactor.core.publisher.Mono.<T,D>usingWhen(org.reactivestreams.Publisher<D>,java.util.function.Function<? super D,? extends reactor.core.publisher.Mono<? extends T>>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Mono.<T,D>usingWhen(org.reactivestreams.Publisher<D>,java.util.function.Function<? super D,? extends reactor.core.publisher.Mono<? extends T>>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<?>>,java.util.function.BiFunction<? super D,? super java.lang.Throwable,? extends org.reactivestreams.Publisher<?>>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Mono.<T,D>usingWhen(org.reactivestreams.Publisher<D>,java.util.function.Function<? super D,? extends reactor.core.publisher.Mono<? extends T>>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<?>>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Mono.<T,D>usingWhen(org.reactivestreams.Publisher<D>,java.util.function.Function<? super D,? extends reactor.core.publisher.Mono<? extends T>>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<?>>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<?>>,java.util.function.Function<? super D,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Mono.<T1,T2,O>zip(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,java.util.function.BiFunction<? super T1,? super T2,? extends O>)"
- "reactor.core.publisher.Mono.<T1,T2,T3,T4,T5,T6,T7,T8>zip(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>,reactor.core.publisher.Mono<? extends T4>,reactor.core.publisher.Mono<? extends T5>,reactor.core.publisher.Mono<? extends T6>,reactor.core.publisher.Mono<? extends T7>,reactor.core.publisher.Mono<? extends T8>)"
- "reactor.core.publisher.Mono.<T1,T2,T3,T4,T5,T6,T7,T8>zipDelayError(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>,reactor.core.publisher.Mono<? extends T4>,reactor.core.publisher.Mono<? extends T5>,reactor.core.publisher.Mono<? extends T6>,reactor.core.publisher.Mono<? extends T7>,reactor.core.publisher.Mono<? extends T8>)"
- "reactor.core.publisher.Mono.<T1,T2,T3,T4,T5,T6,T7>zip(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>,reactor.core.publisher.Mono<? extends T4>,reactor.core.publisher.Mono<? extends T5>,reactor.core.publisher.Mono<? extends T6>,reactor.core.publisher.Mono<? extends T7>)"
- "reactor.core.publisher.Mono.<T1,T2,T3,T4,T5,T6,T7>zipDelayError(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>,reactor.core.publisher.Mono<? extends T4>,reactor.core.publisher.Mono<? extends T5>,reactor.core.publisher.Mono<? extends T6>,reactor.core.publisher.Mono<? extends T7>)"
- "reactor.core.publisher.Mono.<T1,T2,T3,T4,T5,T6>zip(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>,reactor.core.publisher.Mono<? extends T4>,reactor.core.publisher.Mono<? extends T5>,reactor.core.publisher.Mono<? extends T6>)"
- "reactor.core.publisher.Mono.<T1,T2,T3,T4,T5,T6>zipDelayError(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>,reactor.core.publisher.Mono<? extends T4>,reactor.core.publisher.Mono<? extends T5>,reactor.core.publisher.Mono<? extends T6>)"
- "reactor.core.publisher.Mono.<T1,T2,T3,T4,T5>zip(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>,reactor.core.publisher.Mono<? extends T4>,reactor.core.publisher.Mono<? extends T5>)"
- "reactor.core.publisher.Mono.<T1,T2,T3,T4,T5>zipDelayError(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>,reactor.core.publisher.Mono<? extends T4>,reactor.core.publisher.Mono<? extends T5>)"
- "reactor.core.publisher.Mono.<T1,T2,T3,T4>zip(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>,reactor.core.publisher.Mono<? extends T4>)"
- "reactor.core.publisher.Mono.<T1,T2,T3,T4>zipDelayError(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>,reactor.core.publisher.Mono<? extends T4>)"
- "reactor.core.publisher.Mono.<T1,T2,T3>zip(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>)"
- "reactor.core.publisher.Mono.<T1,T2,T3>zipDelayError(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>,reactor.core.publisher.Mono<? extends T3>)"
- "reactor.core.publisher.Mono.<T1,T2>zip(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>)"
- "reactor.core.publisher.Mono.<T1,T2>zipDelayError(reactor.core.publisher.Mono<? extends T1>,reactor.core.publisher.Mono<? extends T2>)"
- "reactor.core.publisher.Mono.<T2,O>zipWhen(java.util.function.Function<T,reactor.core.publisher.Mono<? extends T2>>,java.util.function.BiFunction<T,T2,O>)"
- "reactor.core.publisher.Mono.<T2,O>zipWith(reactor.core.publisher.Mono<? extends T2>,java.util.function.BiFunction<? super T,? super T2,? extends O>)"
- "reactor.core.publisher.Mono.<T2>zipWhen(java.util.function.Function<T,reactor.core.publisher.Mono<? extends T2>>)"
- "reactor.core.publisher.Mono.<T2>zipWith(reactor.core.publisher.Mono<? extends T2>)"
- "reactor.core.publisher.Mono.<T>create(java.util.function.Consumer<reactor.core.publisher.MonoSink<T>>)"
- "reactor.core.publisher.Mono.<T>defer(java.util.function.Supplier<? extends reactor.core.publisher.Mono<? extends T>>)"
- "reactor.core.publisher.Mono.<T>deferWithContext(java.util.function.Function<reactor.util.context.Context,? extends reactor.core.publisher.Mono<? extends T>>)"
- "reactor.core.publisher.Mono.<T>empty()"
- "reactor.core.publisher.Mono.<T>error(java.lang.Throwable)"
- "reactor.core.publisher.Mono.<T>error(java.util.function.Supplier<? extends java.lang.Throwable>)"
- "reactor.core.publisher.Mono.<T>first(java.lang.Iterable<? extends reactor.core.publisher.Mono<? extends T>>)"
- "reactor.core.publisher.Mono.<T>first(reactor.core.publisher.Mono<? extends T>...)"
- "reactor.core.publisher.Mono.<T>from(org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Mono.<T>fromCallable(java.util.concurrent.Callable<? extends T>)"
- "reactor.core.publisher.Mono.<T>fromCompletionStage(java.util.concurrent.CompletionStage<? extends T>)"
- "reactor.core.publisher.Mono.<T>fromCompletionStage(java.util.function.Supplier<? extends java.util.concurrent.CompletionStage<? extends T>>)"
- "reactor.core.publisher.Mono.<T>fromFuture(java.util.concurrent.CompletableFuture<? extends T>)"
- "reactor.core.publisher.Mono.<T>fromFuture(java.util.function.Supplier<? extends java.util.concurrent.CompletableFuture<? extends T>>)"
- "reactor.core.publisher.Mono.<T>fromRunnable(java.lang.Runnable)"
- "reactor.core.publisher.Mono.<T>fromSupplier(java.util.function.Supplier<? extends T>)"
- "reactor.core.publisher.Mono.<T>ignoreElements(org.reactivestreams.Publisher<T>)"
- "reactor.core.publisher.Mono.<T>just(T)"
- "reactor.core.publisher.Mono.<T>justOrEmpty(T)"
- "reactor.core.publisher.Mono.<T>justOrEmpty(java.util.Optional<? extends T>)"
- "reactor.core.publisher.Mono.<T>never()"
- "reactor.core.publisher.Mono.<T>onAssembly(reactor.core.publisher.Mono<T>)"
- "reactor.core.publisher.Mono.<T>onLastAssembly(reactor.core.publisher.Mono<T>)"
- "reactor.core.publisher.Mono.<T>sequenceEqual(org.reactivestreams.Publisher<? extends T>,org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Mono.<T>sequenceEqual(org.reactivestreams.Publisher<? extends T>,org.reactivestreams.Publisher<? extends T>,java.util.function.BiPredicate<? super T,? super T>)"
- "reactor.core.publisher.Mono.<T>sequenceEqual(org.reactivestreams.Publisher<? extends T>,org.reactivestreams.Publisher<? extends T>,java.util.function.BiPredicate<? super T,? super T>,int)"
- "reactor.core.publisher.Mono.<U>delaySubscription(org.reactivestreams.Publisher<U>)"
- "reactor.core.publisher.Mono.<U>ofType(java.lang.Class<U>)"
- "reactor.core.publisher.Mono.<U>timeout(org.reactivestreams.Publisher<U>)"
- "reactor.core.publisher.Mono.<U>timeout(org.reactivestreams.Publisher<U>,reactor.core.publisher.Mono<? extends T>)"
- "reactor.core.publisher.Mono.<V>compose(java.util.function.Function<? super reactor.core.publisher.Mono<T>,? extends org.reactivestreams.Publisher<V>>)"
- "reactor.core.publisher.Mono.<V>then(reactor.core.publisher.Mono<V>)"
- "reactor.core.publisher.Mono.<V>thenMany(org.reactivestreams.Publisher<V>)"
- "reactor.core.publisher.Mono.<V>thenReturn(V)"
- "reactor.core.publisher.Mono.<V>transform(java.util.function.Function<? super reactor.core.publisher.Mono<T>,? extends org.reactivestreams.Publisher<V>>)"
- "reactor.core.publisher.Mono.<V>transformDeferred(java.util.function.Function<? super reactor.core.publisher.Mono<T>,? extends org.reactivestreams.Publisher<V>>)"
- "reactor.core.publisher.Mono.<X>dematerialize()"
- "reactor.core.publisher.Mono.and(org.reactivestreams.Publisher<?>)"
- "reactor.core.publisher.Mono.block()"
- "reactor.core.publisher.Mono.block(java.time.Duration)"
- "reactor.core.publisher.Mono.blockOptional()"
- "reactor.core.publisher.Mono.blockOptional(java.time.Duration)"
- "reactor.core.publisher.Mono.cache()"
- "reactor.core.publisher.Mono.cache(java.time.Duration)"
- "reactor.core.publisher.Mono.cache(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.cache(java.util.function.Function<? super T,java.time.Duration>,java.util.function.Function<java.lang.Throwable,java.time.Duration>,java.util.function.Supplier<java.time.Duration>)"
- "reactor.core.publisher.Mono.cancelOn(reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.checkpoint()"
- "reactor.core.publisher.Mono.checkpoint(java.lang.String)"
- "reactor.core.publisher.Mono.checkpoint(java.lang.String,boolean)"
- "reactor.core.publisher.Mono.concatWith(org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Mono.defaultIfEmpty(T)"
- "reactor.core.publisher.Mono.delay(java.time.Duration)"
- "reactor.core.publisher.Mono.delay(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.delayElement(java.time.Duration)"
- "reactor.core.publisher.Mono.delayElement(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.delaySubscription(java.time.Duration)"
- "reactor.core.publisher.Mono.delaySubscription(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.delayUntil(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Mono.doAfterSuccessOrError(java.util.function.BiConsumer<? super T,java.lang.Throwable>)"
- "reactor.core.publisher.Mono.doAfterTerminate(java.lang.Runnable)"
- "reactor.core.publisher.Mono.doFinally(java.util.function.Consumer<reactor.core.publisher.SignalType>)"
- "reactor.core.publisher.Mono.doFirst(java.lang.Runnable)"
- "reactor.core.publisher.Mono.doOnCancel(java.lang.Runnable)"
- "reactor.core.publisher.Mono.doOnEach(java.util.function.Consumer<? super reactor.core.publisher.Signal<T>>)"
- "reactor.core.publisher.Mono.doOnError(java.util.function.Consumer<? super java.lang.Throwable>)"
- "reactor.core.publisher.Mono.doOnError(java.util.function.Predicate<? super java.lang.Throwable>,java.util.function.Consumer<? super java.lang.Throwable>)"
- "reactor.core.publisher.Mono.doOnNext(java.util.function.Consumer<? super T>)"
- "reactor.core.publisher.Mono.doOnRequest(java.util.function.LongConsumer)"
- "reactor.core.publisher.Mono.doOnSubscribe(java.util.function.Consumer<? super org.reactivestreams.Subscription>)"
- "reactor.core.publisher.Mono.doOnSuccess(java.util.function.Consumer<? super T>)"
- "reactor.core.publisher.Mono.doOnSuccessOrError(java.util.function.BiConsumer<? super T,java.lang.Throwable>)"
- "reactor.core.publisher.Mono.doOnTerminate(java.lang.Runnable)"
- "reactor.core.publisher.Mono.elapsed()"
- "reactor.core.publisher.Mono.elapsed(reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.expand(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Mono.expand(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends T>>,int)"
- "reactor.core.publisher.Mono.expandDeep(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends T>>)"
- "reactor.core.publisher.Mono.expandDeep(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<? extends T>>,int)"
- "reactor.core.publisher.Mono.filter(java.util.function.Predicate<? super T>)"
- "reactor.core.publisher.Mono.filterWhen(java.util.function.Function<? super T,? extends org.reactivestreams.Publisher<java.lang.Boolean>>)"
- "reactor.core.publisher.Mono.flux()"
- "reactor.core.publisher.Mono.hasElement()"
- "reactor.core.publisher.Mono.hide()"
- "reactor.core.publisher.Mono.ignoreElement()"
- "reactor.core.publisher.Mono.log()"
- "reactor.core.publisher.Mono.log(java.lang.String)"
- "reactor.core.publisher.Mono.log(java.lang.String,java.util.logging.Level,boolean,reactor.core.publisher.SignalType...)"
- "reactor.core.publisher.Mono.log(java.lang.String,java.util.logging.Level,reactor.core.publisher.SignalType...)"
- "reactor.core.publisher.Mono.log(reactor.util.Logger)"
- "reactor.core.publisher.Mono.log(reactor.util.Logger,java.util.logging.Level,boolean,reactor.core.publisher.SignalType...)"
- "reactor.core.publisher.Mono.materialize()"
- "reactor.core.publisher.Mono.mergeWith(org.reactivestreams.Publisher<? extends T>)"
- "reactor.core.publisher.Mono.metrics()"
- "reactor.core.publisher.Mono.name(java.lang.String)"
- "reactor.core.publisher.Mono.onErrorContinue(java.util.function.BiConsumer<java.lang.Throwable,java.lang.Object>)"
- "reactor.core.publisher.Mono.onErrorMap(java.util.function.Function<? super java.lang.Throwable,? extends java.lang.Throwable>)"
- "reactor.core.publisher.Mono.onErrorMap(java.util.function.Predicate<? super java.lang.Throwable>,java.util.function.Function<? super java.lang.Throwable,? extends java.lang.Throwable>)"
- "reactor.core.publisher.Mono.onErrorResume(java.util.function.Function<? super java.lang.Throwable,? extends reactor.core.publisher.Mono<? extends T>>)"
- "reactor.core.publisher.Mono.onErrorResume(java.util.function.Predicate<? super java.lang.Throwable>,java.util.function.Function<? super java.lang.Throwable,? extends reactor.core.publisher.Mono<? extends T>>)"
- "reactor.core.publisher.Mono.onErrorReturn(T)"
- "reactor.core.publisher.Mono.onErrorReturn(java.util.function.Predicate<? super java.lang.Throwable>,T)"
- "reactor.core.publisher.Mono.onErrorStop()"
- "reactor.core.publisher.Mono.onTerminateDetach()"
- "reactor.core.publisher.Mono.or(reactor.core.publisher.Mono<? extends T>)"
- "reactor.core.publisher.Mono.publishOn(reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.repeat()"
- "reactor.core.publisher.Mono.repeat(java.util.function.BooleanSupplier)"
- "reactor.core.publisher.Mono.repeat(long)"
- "reactor.core.publisher.Mono.repeat(long,java.util.function.BooleanSupplier)"
- "reactor.core.publisher.Mono.repeatWhen(java.util.function.Function<reactor.core.publisher.Flux<java.lang.Long>,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Mono.repeatWhenEmpty(int,java.util.function.Function<reactor.core.publisher.Flux<java.lang.Long>,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Mono.repeatWhenEmpty(java.util.function.Function<reactor.core.publisher.Flux<java.lang.Long>,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Mono.retry()"
- "reactor.core.publisher.Mono.retry(java.util.function.Predicate<? super java.lang.Throwable>)"
- "reactor.core.publisher.Mono.retry(long)"
- "reactor.core.publisher.Mono.retry(long,java.util.function.Predicate<? super java.lang.Throwable>)"
- "reactor.core.publisher.Mono.retryBackoff(long,java.time.Duration)"
- "reactor.core.publisher.Mono.retryBackoff(long,java.time.Duration,java.time.Duration)"
- "reactor.core.publisher.Mono.retryBackoff(long,java.time.Duration,java.time.Duration,double)"
- "reactor.core.publisher.Mono.retryBackoff(long,java.time.Duration,java.time.Duration,double,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.retryBackoff(long,java.time.Duration,java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.retryWhen(java.util.function.Function<reactor.core.publisher.Flux<java.lang.Throwable>,? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Mono.retryWhen(reactor.util.retry.Retry)"
- "reactor.core.publisher.Mono.single()"
- "reactor.core.publisher.Mono.subscribe()"
- "reactor.core.publisher.Mono.subscribe(java.util.function.Consumer<? super T>)"
- "reactor.core.publisher.Mono.subscribe(java.util.function.Consumer<? super T>,java.util.function.Consumer<? super java.lang.Throwable>)"
- "reactor.core.publisher.Mono.subscribe(java.util.function.Consumer<? super T>,java.util.function.Consumer<? super java.lang.Throwable>,java.lang.Runnable)"
- "reactor.core.publisher.Mono.subscribe(java.util.function.Consumer<? super T>,java.util.function.Consumer<? super java.lang.Throwable>,java.lang.Runnable,java.util.function.Consumer<? super org.reactivestreams.Subscription>)"
- "reactor.core.publisher.Mono.subscribe(java.util.function.Consumer<? super T>,java.util.function.Consumer<? super java.lang.Throwable>,java.lang.Runnable,reactor.util.context.Context)"
- "reactor.core.publisher.Mono.subscribe(org.reactivestreams.Subscriber<? super T>)"
- "reactor.core.publisher.Mono.subscribe(reactor.core.CoreSubscriber<? super T>)"
- "reactor.core.publisher.Mono.subscribeOn(reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.subscriberContext()"
- "reactor.core.publisher.Mono.subscriberContext(java.util.function.Function<reactor.util.context.Context,reactor.util.context.Context>)"
- "reactor.core.publisher.Mono.subscriberContext(reactor.util.context.Context)"
- "reactor.core.publisher.Mono.switchIfEmpty(reactor.core.publisher.Mono<? extends T>)"
- "reactor.core.publisher.Mono.tag(java.lang.String,java.lang.String)"
- "reactor.core.publisher.Mono.take(java.time.Duration)"
- "reactor.core.publisher.Mono.take(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.takeUntilOther(org.reactivestreams.Publisher<?>)"
- "reactor.core.publisher.Mono.then()"
- "reactor.core.publisher.Mono.thenEmpty(org.reactivestreams.Publisher<java.lang.Void>)"
- "reactor.core.publisher.Mono.timeout(java.time.Duration)"
- "reactor.core.publisher.Mono.timeout(java.time.Duration,reactor.core.publisher.Mono<? extends T>)"
- "reactor.core.publisher.Mono.timeout(java.time.Duration,reactor.core.publisher.Mono<? extends T>,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.timeout(java.time.Duration,reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.timestamp()"
- "reactor.core.publisher.Mono.timestamp(reactor.core.scheduler.Scheduler)"
- "reactor.core.publisher.Mono.toFuture()"
- "reactor.core.publisher.Mono.toProcessor()"
- "reactor.core.publisher.Mono.toString()"
- "reactor.core.publisher.Mono.when(java.lang.Iterable<? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Mono.when(org.reactivestreams.Publisher<?>...)"
- "reactor.core.publisher.Mono.whenDelayError(java.lang.Iterable<? extends org.reactivestreams.Publisher<?>>)"
- "reactor.core.publisher.Mono.whenDelayError(org.reactivestreams.Publisher<?>...)"
syntax: "public class AmqpChannelProcessor<T> extends Mono<T> implements Processor<T,T>, CoreSubscriber<T>, Disposable"
constructors:
- "com.azure.core.amqp.implementation.AmqpChannelProcessor.AmqpChannelProcessor(java.lang.String,java.lang.String,java.util.function.Function<T,reactor.core.publisher.Flux<com.azure.core.amqp.AmqpEndpointState>>,com.azure.core.amqp.AmqpRetryPolicy,com.azure.core.util.logging.ClientLogger)"
methods:
- "com.azure.core.amqp.implementation.AmqpChannelProcessor.dispose()"
- "com.azure.core.amqp.implementation.AmqpChannelProcessor.isDisposed()"
- "com.azure.core.amqp.implementation.AmqpChannelProcessor.onComplete()"
- "com.azure.core.amqp.implementation.AmqpChannelProcessor.onError(java.lang.Throwable)"
- "com.azure.core.amqp.implementation.AmqpChannelProcessor.onNext(T)"
- "com.azure.core.amqp.implementation.AmqpChannelProcessor.onSubscribe(org.reactivestreams.Subscription)"
- "com.azure.core.amqp.implementation.AmqpChannelProcessor.subscribe(reactor.core.CoreSubscriber<? super T>)"
type: "class"
typeParameters:
- name: "T"
implements:
- "<xref href=\"org.reactivestreams.Processor?alt=org.reactivestreams.Processor&text=Processor\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />,<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
- "<xref href=\"reactor.core.CoreSubscriber?alt=reactor.core.CoreSubscriber&text=CoreSubscriber\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
- "<xref href=\"reactor.core.Disposable?alt=reactor.core.Disposable&text=Disposable\" data-throw-if-not-resolved=\"False\" />"
metadata: {}
package: "com.azure.core.amqp.implementation"
artifact: com.azure:azure-core-amqp:1.6.0-beta.1
