### YamlMime:JavaType
uid: "com.azure.storage.blob.nio.AzureFileSystemProvider"
fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider"
name: "AzureFileSystemProvider"
nameWithType: "AzureFileSystemProvider"
summary: "The `AzureFileSystemProvider` is Azure Storage's implementation of the nio interface on top of Azure Blob Storage."
inheritances:
- "<xref href=\"java.lang.Object?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"java.nio.file.spi.FileSystemProvider?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
- "java.nio.file.spi.FileSystemProvider.<A>readAttributes(java.nio.file.Path,java.lang.Class<A>,java.nio.file.LinkOption...)"
- "java.nio.file.spi.FileSystemProvider.<V>getFileAttributeView(java.nio.file.Path,java.lang.Class<V>,java.nio.file.LinkOption...)"
- "java.nio.file.spi.FileSystemProvider.checkAccess(java.nio.file.Path,java.nio.file.AccessMode...)"
- "java.nio.file.spi.FileSystemProvider.copy(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)"
- "java.nio.file.spi.FileSystemProvider.createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute<?>...)"
- "java.nio.file.spi.FileSystemProvider.createLink(java.nio.file.Path,java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.createSymbolicLink(java.nio.file.Path,java.nio.file.Path,java.nio.file.attribute.FileAttribute<?>...)"
- "java.nio.file.spi.FileSystemProvider.delete(java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.deleteIfExists(java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.getFileStore(java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.getFileSystem(java.net.URI)"
- "java.nio.file.spi.FileSystemProvider.getPath(java.net.URI)"
- "java.nio.file.spi.FileSystemProvider.getScheme()"
- "java.nio.file.spi.FileSystemProvider.installedProviders()"
- "java.nio.file.spi.FileSystemProvider.isHidden(java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.isSameFile(java.nio.file.Path,java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.move(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)"
- "java.nio.file.spi.FileSystemProvider.newAsynchronousFileChannel(java.nio.file.Path,java.util.Set<? extends java.nio.file.OpenOption>,java.util.concurrent.ExecutorService,java.nio.file.attribute.FileAttribute<?>...)"
- "java.nio.file.spi.FileSystemProvider.newByteChannel(java.nio.file.Path,java.util.Set<? extends java.nio.file.OpenOption>,java.nio.file.attribute.FileAttribute<?>...)"
- "java.nio.file.spi.FileSystemProvider.newDirectoryStream(java.nio.file.Path,java.nio.file.DirectoryStream.Filter<? super java.nio.file.Path>)"
- "java.nio.file.spi.FileSystemProvider.newFileChannel(java.nio.file.Path,java.util.Set<? extends java.nio.file.OpenOption>,java.nio.file.attribute.FileAttribute<?>...)"
- "java.nio.file.spi.FileSystemProvider.newFileSystem(java.net.URI,java.util.Map<java.lang.String,?>)"
- "java.nio.file.spi.FileSystemProvider.newFileSystem(java.nio.file.Path,java.util.Map<java.lang.String,?>)"
- "java.nio.file.spi.FileSystemProvider.newInputStream(java.nio.file.Path,java.nio.file.OpenOption...)"
- "java.nio.file.spi.FileSystemProvider.newOutputStream(java.nio.file.Path,java.nio.file.OpenOption...)"
- "java.nio.file.spi.FileSystemProvider.readAttributes(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)"
- "java.nio.file.spi.FileSystemProvider.readSymbolicLink(java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)"
syntax: "public final class AzureFileSystemProvider extends FileSystemProvider"
constructors:
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.AzureFileSystemProvider()"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.AzureFileSystemProvider()"
  name: "AzureFileSystemProvider()"
  nameWithType: "AzureFileSystemProvider.AzureFileSystemProvider()"
  summary: "Creates an Azure<wbr>File<wbr>System<wbr>Provider."
  syntax: "public AzureFileSystemProvider()"
  desc: "Creates an AzureFileSystemProvider."
fields:
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.CACHE_CONTROL"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.CACHE_CONTROL"
  name: "CACHE_CONTROL"
  nameWithType: "AzureFileSystemProvider.CACHE_CONTROL"
  summary: "A helper for setting the HTTP properties when creating a directory."
  modifiers:
  - "static"
  - "final"
  field:
    value: "Cache-Control"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final String CACHE_CONTROL"
  desc: "A helper for setting the HTTP properties when creating a directory."
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_DISPOSITION"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_DISPOSITION"
  name: "CONTENT_DISPOSITION"
  nameWithType: "AzureFileSystemProvider.CONTENT_DISPOSITION"
  summary: "A helper for setting the HTTP properties when creating a directory."
  modifiers:
  - "static"
  - "final"
  field:
    value: "Content-Disposition"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final String CONTENT_DISPOSITION"
  desc: "A helper for setting the HTTP properties when creating a directory."
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_ENCODING"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_ENCODING"
  name: "CONTENT_ENCODING"
  nameWithType: "AzureFileSystemProvider.CONTENT_ENCODING"
  summary: "A helper for setting the HTTP properties when creating a directory."
  modifiers:
  - "static"
  - "final"
  field:
    value: "Content-Encoding"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final String CONTENT_ENCODING"
  desc: "A helper for setting the HTTP properties when creating a directory."
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_LANGUAGE"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_LANGUAGE"
  name: "CONTENT_LANGUAGE"
  nameWithType: "AzureFileSystemProvider.CONTENT_LANGUAGE"
  summary: "A helper for setting the HTTP properties when creating a directory."
  modifiers:
  - "static"
  - "final"
  field:
    value: "Content-Language"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final String CONTENT_LANGUAGE"
  desc: "A helper for setting the HTTP properties when creating a directory."
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_MD5"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_MD5"
  name: "CONTENT_MD5"
  nameWithType: "AzureFileSystemProvider.CONTENT_MD5"
  summary: "A helper for setting the HTTP properties when creating a directory."
  modifiers:
  - "static"
  - "final"
  field:
    value: "Content-MD5"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final String CONTENT_MD5"
  desc: "A helper for setting the HTTP properties when creating a directory."
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_TYPE"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_TYPE"
  name: "CONTENT_TYPE"
  nameWithType: "AzureFileSystemProvider.CONTENT_TYPE"
  summary: "A helper for setting the HTTP properties when creating a directory."
  modifiers:
  - "static"
  - "final"
  field:
    value: "Content-Type"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final String CONTENT_TYPE"
  desc: "A helper for setting the HTTP properties when creating a directory."
methods:
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.<A>readAttributes(java.nio.file.Path,java.lang.Class<A>,java.nio.file.LinkOption...)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.<A>readAttributes(Path path, Class<A> type, LinkOption[] linkOptions)"
  name: "<A>readAttributes(Path path, Class<A> type, LinkOption[] linkOptions)"
  nameWithType: "AzureFileSystemProvider.<A>readAttributes(Path path, Class<A> type, LinkOption[] linkOptions)"
  summary: "Reads a file's attributes as a bulk operation."
  overridden: "java.nio.file.spi.FileSystemProvider.<A>readAttributes(java.nio.file.Path,java.lang.Class<A>,java.nio.file.LinkOption...)"
  parameters:
  - description: "the path to the file"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "the Class of the file attributes required to read"
    name: "type"
    type: "<xref href=\"java.lang.Class?alt=java.lang.Class&text=Class\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"A?alt=A&text=A\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "ignored"
    name: "linkOptions"
    type: "<xref href=\"java.nio.file.LinkOption?alt=java.nio.file.LinkOption&text=LinkOption\" data-throw-if-not-resolved=\"False\" />[]"
  syntax: "public A <A>readAttributes(Path path, Class<A> type, LinkOption[] linkOptions)"
  exceptions:
  - description: "if an attributes of the given type are not supported"
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Reads a file's attributes as a bulk operation.\n\nSee <xref uid=\"com.azure.storage.blob.nio.AzureBasicFileAttributes\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureBasicFileAttributes\"></xref> and <xref uid=\"com.azure.storage.blob.nio.AzureBlobFileAttributes\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureBlobFileAttributes\"></xref> for more information.\n\nReading attributes on a virtual directory will return `null` for most properties other than <xref uid=\"com.azure.storage.blob.nio.AzureBlobFileAttributes.isVirtualDirectory()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureBlobFileAttributes#isVirtualDirectory()\"></xref>, which will return true. See <xref uid=\"com.azure.storage.blob.nio.AzureFileSystemProvider.createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute<?>...)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#createDirectory(Path, FileAttribute[])\"></xref> for more information on virtual directories."
  returns:
    description: "the file attributes"
    type: "<xref href=\"A?alt=A&text=A\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.<V>getFileAttributeView(java.nio.file.Path,java.lang.Class<V>,java.nio.file.LinkOption...)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.<V>getFileAttributeView(Path path, Class<V> type, LinkOption[] linkOptions)"
  name: "<V>getFileAttributeView(Path path, Class<V> type, LinkOption[] linkOptions)"
  nameWithType: "AzureFileSystemProvider.<V>getFileAttributeView(Path path, Class<V> type, LinkOption[] linkOptions)"
  summary: "Returns a file attribute view of a given type."
  overridden: "java.nio.file.spi.FileSystemProvider.<V>getFileAttributeView(java.nio.file.Path,java.lang.Class<V>,java.nio.file.LinkOption...)"
  parameters:
  - description: "the path to the file"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "the Class object corresponding to the file attribute view"
    name: "type"
    type: "<xref href=\"java.lang.Class?alt=java.lang.Class&text=Class\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"V?alt=V&text=V\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "ignored"
    name: "linkOptions"
    type: "<xref href=\"java.nio.file.LinkOption?alt=java.nio.file.LinkOption&text=LinkOption\" data-throw-if-not-resolved=\"False\" />[]"
  syntax: "public V <V>getFileAttributeView(Path path, Class<V> type, LinkOption[] linkOptions)"
  desc: "Returns a file attribute view of a given type.\n\nSee <xref uid=\"com.azure.storage.blob.nio.AzureBasicFileAttributeView\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureBasicFileAttributeView\"></xref> and <xref uid=\"com.azure.storage.blob.nio.AzureBlobFileAttributeView\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureBlobFileAttributeView\"></xref> for more information.\n\nReading attributes on a virtual directory will return `null` for most properties other than <xref uid=\"com.azure.storage.blob.nio.AzureBlobFileAttributes.isVirtualDirectory()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureBlobFileAttributes#isVirtualDirectory()\"></xref>, which will return true. See <xref uid=\"com.azure.storage.blob.nio.AzureFileSystemProvider.createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute<?>...)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#createDirectory(Path, FileAttribute[])\"></xref> for more information on virtual directories."
  returns:
    description: "a file attribute view of the specified type, or null if the attribute view type is not available"
    type: "<xref href=\"V?alt=V&text=V\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.checkAccess(java.nio.file.Path,java.nio.file.AccessMode...)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.checkAccess(Path path, AccessMode[] accessModes)"
  name: "checkAccess(Path path, AccessMode[] accessModes)"
  nameWithType: "AzureFileSystemProvider.checkAccess(Path path, AccessMode[] accessModes)"
  summary: "Checks the existence, and optionally the accessibility, of a file."
  overridden: "java.nio.file.spi.FileSystemProvider.checkAccess(java.nio.file.Path,java.nio.file.AccessMode...)"
  parameters:
  - description: "the path to the file to check"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "The access modes to check; may have zero elements"
    name: "accessModes"
    type: "<xref href=\"java.nio.file.AccessMode?alt=java.nio.file.AccessMode&text=AccessMode\" data-throw-if-not-resolved=\"False\" />[]"
  syntax: "public void checkAccess(Path path, AccessMode[] accessModes)"
  exceptions:
  - description: "if a file does not exist"
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Checks the existence, and optionally the accessibility, of a file.\n\nThis method may only be used to check the existence of a file. It is not possible to determine the permissions granted to a given client, so if any mode argument is specified, an <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"UnsupportedOperationException\"></xref> will be thrown."
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.copy(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.copy(Path source, Path destination, CopyOption[] copyOptions)"
  name: "copy(Path source, Path destination, CopyOption[] copyOptions)"
  nameWithType: "AzureFileSystemProvider.copy(Path source, Path destination, CopyOption[] copyOptions)"
  summary: "Copies the resource at the source location to the destination."
  overridden: "java.nio.file.spi.FileSystemProvider.copy(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)"
  parameters:
  - description: "the path to the file to copy"
    name: "source"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "the path to the target file"
    name: "destination"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "specifying how the copy should be done"
    name: "copyOptions"
    type: "<xref href=\"java.nio.file.CopyOption?alt=java.nio.file.CopyOption&text=CopyOption\" data-throw-if-not-resolved=\"False\" />[]"
  syntax: "public void copy(Path source, Path destination, CopyOption[] copyOptions)"
  exceptions:
  - description: "if the array contains a copy option that is not supported"
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Copies the resource at the source location to the destination.\n\nThis method is not atomic with respect to other file system operations. More specifically, the checks necessary to validate the inputs and state of the file system are not atomic with the actual copying of data. If the copy is triggered, the copy itself is atomic and only a complete copy will ever be left at the destination.\n\nIn addition to those in the docs for <xref uid=\"java.nio.file.spi.FileSystemProvider.copy*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"FileSystemProvider#copy(Path, Path, CopyOption...)\"></xref>, this method has the following requirements for successful completion. <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"StandardCopyOption#COPY_ATTRIBUTES\"></xref> must be passed as it is impossible not to copy blob properties; if this option is not passed, an <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"UnsupportedOperationException\"></xref> will be thrown. Neither the source nor the destination can be a root directory; if either is a root directory, an <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"IllegalArgumentException\"></xref> will be thrown. The parent directory of the destination must at least weakly exist; if it does not, an <xref uid=\"java.io.IOException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"IOException\"></xref> will be thrown. The only supported option other than <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"StandardCopyOption#COPY_ATTRIBUTES\"></xref> is <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"StandardCopyOption#REPLACE_EXISTING\"></xref>; the presence of any other option will result in an <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"UnsupportedOperationException\"></xref>.\n\nThis method supports both virtual and concrete directories as both the source and destination. Unlike when creating a directory, the existence of a virtual directory at the destination will cause this operation to fail. This is in order to prevent the possibility of overwriting a non-empty virtual directory with a file. Still, as mentioned above, this check is not atomic with the creation of the resultant directory."
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute<?>...)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.createDirectory(Path path, FileAttribute<?>[] fileAttributes)"
  name: "createDirectory(Path path, FileAttribute<?>[] fileAttributes)"
  nameWithType: "AzureFileSystemProvider.createDirectory(Path path, FileAttribute<?>[] fileAttributes)"
  summary: "Creates a new directory at the specified path."
  overridden: "java.nio.file.spi.FileSystemProvider.createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute<?>...)"
  parameters:
  - description: "the directory to create"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "an optional list of file attributes to set atomically when creating the directory"
    name: "fileAttributes"
    type: "<xref href=\"java.nio.file.attribute.FileAttribute?alt=java.nio.file.attribute.FileAttribute&text=FileAttribute\" data-throw-if-not-resolved=\"False\" />&lt;?&gt;[]"
  syntax: "public void createDirectory(Path path, FileAttribute<?>[] fileAttributes)"
  exceptions:
  - description: "If the path type is not an instance of <xref uid=\"AzurePath\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzurePath\"></xref>."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Creates a new directory at the specified path.\n\nThe existence of a directory in the `AzureFileSystem` is defined on two levels. *Weak existence* is defined by the presence of a non-zero number of blobs prefixed with the directory's path. This concept is also known as a *virtual directory* and enables the file system to work with containers that were pre-loaded with data by another source but need to be accessed by this file system. *Strong existence* is defined as the presence of an actual storage resource at the given path, which in the case of directories, is a zero-length blob whose name is the directory path with a particular metadata field indicating the blob's status as a directory. This is also known as a *concrete directory*. Directories created by this file system will strongly exist. Operations targeting directories themselves as the object (e.g. setting properties) will target marker blobs underlying concrete directories. Other operations (e.g. listing) will operate on the blob-name prefix.\n\nThis method fulfills the nio contract of: \"The check for the existence of the file and the creation of the directory if it does not exist are a single operation that is atomic with respect to all other filesystem activities that might affect the directory.\" More specifically, this method will atomically check for *strong existence* of another file or directory at the given path and fail if one is present. On the other hand, we only check for *weak existence* of the parent to determine if the given path is valid. Additionally, the action of checking whether the parent exists, is *not* atomic with the creation of the directory. Note that while it is possible that the parent may be deleted between when the parent is determined to exist and the creation of the child, the creation of the child will always ensure the existence of a virtual parent, so the child will never be left floating and unreachable. The different checks on parent and child is due to limitations in the Storage service API.\n\nThere may be some unintuitive behavior when working with directories in this file system, particularly virtual directories (usually those not created by this file system). A virtual directory will disappear as soon as all its children have been deleted. Furthermore, if a directory with the given path weakly exists at the time of calling this method, this method will still return success and create a concrete directory at the target location. In other words, it is possible to \"double create\" a directory if it first weakly exists and then is strongly created. This is both because it is impossible to atomically check if a virtual directory exists while creating a concrete directory and because such behavior will have minimal side effects--no files will be overwritten and the directory will still be available for writing as intended, though it may not be empty. This is not a complete list of such unintuitive behavior.\n\nThis method will attempt to extract standard HTTP content headers from the list of file attributes to set them as blob headers. All other attributes will be set as blob metadata. The value of every attribute will be converted to a `String` except the Content-MD5 attribute which expects a `byte[]`. When extracting the content headers, the following strings will be used for comparison (constants for these values can be found on this type):\n\n *  `Content-Type`\n *  `Content-Disposition`\n *  `Content-Language`\n *  `Content-Encoding`\n *  `Content-MD5`\n *  `Cache-Control`\n\nNote that these properties also have a particular semantic in that if one is specified, all are updated. In other words, if any of the above is set, all those that are not set will be cleared. See the [Azure Docs][] for more information.\n\n\n[Azure Docs]: https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.delete(java.nio.file.Path)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.delete(Path path)"
  name: "delete(Path path)"
  nameWithType: "AzureFileSystemProvider.delete(Path path)"
  summary: "Deletes the specified resource."
  overridden: "java.nio.file.spi.FileSystemProvider.delete(java.nio.file.Path)"
  parameters:
  - description: "the path to the file to delete"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public void delete(Path path)"
  exceptions:
  - description: "If the path type is not an instance of <xref uid=\"AzurePath\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzurePath\"></xref>."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Deletes the specified resource.\n\nThis method is not atomic with respect to other file system operations. It is possible to delete a file in use by another process, and doing so will not immediately invalidate any channels open to that file--they will simply start to fail. Root directories cannot be deleted even when empty."
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.getFileStore(java.nio.file.Path)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.getFileStore(Path path)"
  name: "getFileStore(Path path)"
  nameWithType: "AzureFileSystemProvider.getFileStore(Path path)"
  summary: "Unsupported."
  overridden: "java.nio.file.spi.FileSystemProvider.getFileStore(java.nio.file.Path)"
  parameters:
  - description: "path"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public FileStore getFileStore(Path path)"
  exceptions:
  - description: "Operation is not supported."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Unsupported."
  returns:
    description: "the file store where the file is stored."
    type: "<xref href=\"java.nio.file.FileStore?alt=java.nio.file.FileStore&text=FileStore\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.getFileSystem(java.net.URI)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.getFileSystem(URI uri)"
  name: "getFileSystem(URI uri)"
  nameWithType: "AzureFileSystemProvider.getFileSystem(URI uri)"
  summary: "Returns an existing File<wbr>System created by this provider."
  overridden: "java.nio.file.spi.FileSystemProvider.getFileSystem(java.net.URI)"
  parameters:
  - description: "URI reference"
    name: "uri"
    type: "<xref href=\"java.net.URI?alt=java.net.URI&text=URI\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public FileSystem getFileSystem(URI uri)"
  desc: "Returns an existing FileSystem created by this provider.\n\nThe format of a `URI` identifying a file system is `\"azb://?endpoint=<endpoint>\"`.\n\nTrying to retrieve a closed file system will throw a <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"FileSystemNotFoundException\"></xref>. Once closed, a file system with the same identifier may be reopened."
  returns:
    description: "the file system"
    type: "<xref href=\"java.nio.file.FileSystem?alt=java.nio.file.FileSystem&text=FileSystem\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.getPath(java.net.URI)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.getPath(URI uri)"
  name: "getPath(URI uri)"
  nameWithType: "AzureFileSystemProvider.getPath(URI uri)"
  summary: "Return a Path object by converting the given URI."
  overridden: "java.nio.file.spi.FileSystemProvider.getPath(java.net.URI)"
  parameters:
  - description: "The URI to convert"
    name: "uri"
    type: "<xref href=\"java.net.URI?alt=java.net.URI&text=URI\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Path getPath(URI uri)"
  desc: "Return a Path object by converting the given URI. The resulting Path is associated with a FileSystem that already exists."
  returns:
    description: "The path identified by the URI."
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.getScheme()"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.getScheme()"
  name: "getScheme()"
  nameWithType: "AzureFileSystemProvider.getScheme()"
  summary: "Returns the URI scheme that identifies this provider: `\"azb\".`"
  overridden: "java.nio.file.spi.FileSystemProvider.getScheme()"
  syntax: "public String getScheme()"
  desc: "Returns the URI scheme that identifies this provider: `\"azb\".`"
  returns:
    description: "<code>\"azb\"</code>"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.isHidden(java.nio.file.Path)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.isHidden(Path path)"
  name: "isHidden(Path path)"
  nameWithType: "AzureFileSystemProvider.isHidden(Path path)"
  summary: "Always returns false as hidden files are not supported."
  overridden: "java.nio.file.spi.FileSystemProvider.isHidden(java.nio.file.Path)"
  parameters:
  - description: "the path"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public boolean isHidden(Path path)"
  exceptions:
  - description: "If an I/O error occurs."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Always returns false as hidden files are not supported."
  returns:
    description: "false"
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.isSameFile(java.nio.file.Path,java.nio.file.Path)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.isSameFile(Path path, Path path1)"
  name: "isSameFile(Path path, Path path1)"
  nameWithType: "AzureFileSystemProvider.isSameFile(Path path, Path path1)"
  summary: "Unsupported."
  overridden: "java.nio.file.spi.FileSystemProvider.isSameFile(java.nio.file.Path,java.nio.file.Path)"
  parameters:
  - description: "path"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "path"
    name: "path1"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public boolean isSameFile(Path path, Path path1)"
  exceptions:
  - description: "Operation is not supported."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Unsupported."
  returns:
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.move(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.move(Path path, Path path1, CopyOption[] copyOptions)"
  name: "move(Path path, Path path1, CopyOption[] copyOptions)"
  nameWithType: "AzureFileSystemProvider.move(Path path, Path path1, CopyOption[] copyOptions)"
  summary: "Unsupported."
  overridden: "java.nio.file.spi.FileSystemProvider.move(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)"
  parameters:
  - description: "path"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "path"
    name: "path1"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "options"
    name: "copyOptions"
    type: "<xref href=\"java.nio.file.CopyOption?alt=java.nio.file.CopyOption&text=CopyOption\" data-throw-if-not-resolved=\"False\" />[]"
  syntax: "public void move(Path path, Path path1, CopyOption[] copyOptions)"
  exceptions:
  - description: "Operation is not supported."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Unsupported."
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.newByteChannel(java.nio.file.Path,java.util.Set<? extends java.nio.file.OpenOption>,java.nio.file.attribute.FileAttribute<?>...)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.newByteChannel(Path path, Set<? extends OpenOption> set, FileAttribute<?>[] fileAttributes)"
  name: "newByteChannel(Path path, Set<? extends OpenOption> set, FileAttribute<?>[] fileAttributes)"
  nameWithType: "AzureFileSystemProvider.newByteChannel(Path path, Set<? extends OpenOption> set, FileAttribute<?>[] fileAttributes)"
  summary: "Opens or creates a file, returning a seekable byte channel to access the file."
  overridden: "java.nio.file.spi.FileSystemProvider.newByteChannel(java.nio.file.Path,java.util.Set<? extends java.nio.file.OpenOption>,java.nio.file.attribute.FileAttribute<?>...)"
  parameters:
  - description: "the path of the file to open"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "options specifying how the file should be opened"
    name: "set"
    type: "<xref href=\"java.util.Set?alt=java.util.Set&text=Set\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"? extends java.nio.file.OpenOption?alt=? extends java.nio.file.OpenOption&text=OpenOption\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "an optional list of file attributes to set atomically when creating the directory"
    name: "fileAttributes"
    type: "<xref href=\"java.nio.file.attribute.FileAttribute?alt=java.nio.file.attribute.FileAttribute&text=FileAttribute\" data-throw-if-not-resolved=\"False\" />&lt;?&gt;[]"
  syntax: "public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> set, FileAttribute<?>[] fileAttributes)"
  exceptions:
  - description: "Operation is not supported."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Opens or creates a file, returning a seekable byte channel to access the file.\n\nThis method is primarily offered to support some jdk convenience methods such as <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Files#createFile(Path, FileAttribute[])\"></xref> which requires opening a channel and closing it. A channel may only be opened in read mode OR write mode. It may not be opened in read/write mode. Seeking is supported for reads, but not for writes. Modifications to existing files is not permitted--only creating new files or overwriting existing files.\n\nThis type is not threadsafe to prevent having to hold locks across network calls."
  returns:
    description: "a new seekable byte channel"
    type: "<xref href=\"java.nio.channels.SeekableByteChannel?alt=java.nio.channels.SeekableByteChannel&text=SeekableByteChannel\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.newDirectoryStream(java.nio.file.Path,java.nio.file.DirectoryStream.Filter<? super java.nio.file.Path>)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.newDirectoryStream(Path path, DirectoryStream.Filter<? super Path> filter)"
  name: "newDirectoryStream(Path path, DirectoryStream.Filter<? super Path> filter)"
  nameWithType: "AzureFileSystemProvider.newDirectoryStream(Path path, DirectoryStream.Filter<? super Path> filter)"
  summary: "Returns an <xref uid=\"com.azure.storage.blob.nio.AzureDirectoryStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureDirectoryStream\"></xref> for iterating over the contents of a directory."
  overridden: "java.nio.file.spi.FileSystemProvider.newDirectoryStream(java.nio.file.Path,java.nio.file.DirectoryStream.Filter<? super java.nio.file.Path>)"
  parameters:
  - description: "the path to the directory"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "the directory stream filter"
    name: "filter"
    type: "<xref href=\"java.nio.file.DirectoryStream.Filter?alt=java.nio.file.DirectoryStream.Filter&text=Filter\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"? super java.nio.file.Path?alt=? super java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public DirectoryStream<Path> newDirectoryStream(Path path, DirectoryStream.Filter<? super Path> filter)"
  exceptions:
  - description: "If the path type is not an instance of <xref uid=\"AzurePath\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzurePath\"></xref>."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Returns an <xref uid=\"com.azure.storage.blob.nio.AzureDirectoryStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureDirectoryStream\"></xref> for iterating over the contents of a directory. The elements returned by the directory stream's iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir. The entries returned by the iterator are filtered by the given filter.\n\nWhen not using the try-with-resources construct, then directory stream's close method should be invoked after iteration is completed to free any resources held for the open directory.\n\nWhere the filter terminates due to an uncaught error or runtime exception then it is propagated to the hasNext or next method. Where an IOException is thrown, it results in the hasNext or next method throwing a DirectoryIteratorException with the IOException as the cause."
  returns:
    description: "a new and open <code>DirectoryStream</code> object"
    type: "<xref href=\"java.nio.file.DirectoryStream?alt=java.nio.file.DirectoryStream&text=DirectoryStream\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.newFileSystem(java.net.URI,java.util.Map<java.lang.String,?>)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.newFileSystem(URI uri, Map<String,?> config)"
  name: "newFileSystem(URI uri, Map<String,?> config)"
  nameWithType: "AzureFileSystemProvider.newFileSystem(URI uri, Map<String,?> config)"
  summary: "Constructs a new File<wbr>System object identified by a URI."
  overridden: "java.nio.file.spi.FileSystemProvider.newFileSystem(java.net.URI,java.util.Map<java.lang.String,?>)"
  parameters:
  - description: "URI reference"
    name: "uri"
    type: "<xref href=\"java.net.URI?alt=java.net.URI&text=URI\" data-throw-if-not-resolved=\"False\" />"
  - description: "A map of provider specific properties to configure the file system"
    name: "config"
    type: "<xref href=\"java.util.Map?alt=java.util.Map&text=Map\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />,?&gt;"
  syntax: "public FileSystem newFileSystem(URI uri, Map<String,?> config)"
  exceptions:
  - description: "If the pre-conditions for the uri parameter aren't met, or the env parameter\n does not contain properties required by the provider, or a property value is invalid."
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Constructs a new FileSystem object identified by a URI.\n\nThe format of a `URI` identifying a file system is `\"azb://?endpoint=\"`.\n\nOnce closed, a file system with the same identifier may be reopened."
  returns:
    description: "a new file system."
    type: "<xref href=\"java.nio.file.FileSystem?alt=java.nio.file.FileSystem&text=FileSystem\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.newInputStream(java.nio.file.Path,java.nio.file.OpenOption...)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.newInputStream(Path path, OpenOption[] options)"
  name: "newInputStream(Path path, OpenOption[] options)"
  nameWithType: "AzureFileSystemProvider.newInputStream(Path path, OpenOption[] options)"
  summary: "Opens an <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> to the given path."
  overridden: "java.nio.file.spi.FileSystemProvider.newInputStream(java.nio.file.Path,java.nio.file.OpenOption...)"
  parameters:
  - description: "the path to the file to open"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "options specifying how the file is opened"
    name: "options"
    type: "<xref href=\"java.nio.file.OpenOption?alt=java.nio.file.OpenOption&text=OpenOption\" data-throw-if-not-resolved=\"False\" />[]"
  syntax: "public InputStream newInputStream(Path path, OpenOption[] options)"
  exceptions:
  - description: "if an invalid combination of options is specified"
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Opens an <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> to the given path.\n\nThe stream will not attempt to read or buffer the entire file. However, when fetching data, it will always request the same size chunk of several MB to prevent network thrashing on small reads. Mark and reset are supported.\n\nOnly <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"StandardOpenOption#READ\"></xref> is supported. Any other option will throw."
  returns:
    description: "a new input stream"
    type: "<xref href=\"java.io.InputStream?alt=java.io.InputStream&text=InputStream\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.newOutputStream(java.nio.file.Path,java.nio.file.OpenOption...)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.newOutputStream(Path path, OpenOption[] options)"
  name: "newOutputStream(Path path, OpenOption[] options)"
  nameWithType: "AzureFileSystemProvider.newOutputStream(Path path, OpenOption[] options)"
  summary: "Opens an <xref uid=\"java.io.OutputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"OutputStream\"></xref> to the given path."
  overridden: "java.nio.file.spi.FileSystemProvider.newOutputStream(java.nio.file.Path,java.nio.file.OpenOption...)"
  parameters:
  - description: "the path to the file to open or create"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "options specifying how the file is opened"
    name: "options"
    type: "<xref href=\"java.nio.file.OpenOption?alt=java.nio.file.OpenOption&text=OpenOption\" data-throw-if-not-resolved=\"False\" />[]"
  syntax: "public OutputStream newOutputStream(Path path, OpenOption[] options)"
  exceptions:
  - description: "if an invalid combination of options is specified"
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Opens an <xref uid=\"java.io.OutputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"OutputStream\"></xref> to the given path. The resulting file will be stored as a block blob.\n\nThe only supported options are <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"StandardOpenOption#CREATE\"></xref>, <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"StandardOpenOption#CREATE_NEW\"></xref>, <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"StandardOpenOption#WRITE\"></xref>, <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"StandardOpenOption#TRUNCATE_EXISTING\"></xref>. Any other options will throw an <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"UnsupportedOperationException\"></xref>. `WRITE` and `TRUNCATE_EXISTING` must be specified or an <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"IllegalArgumentException\"></xref> will be thrown. Hence, files cannot be updated, only overwritten completely.\n\nThis stream will not attempt to buffer the entire file, however some buffering will be done for potential optimizations and to avoid network thrashing. Specifically, up to <xref uid=\"com.azure.storage.blob.nio.AzureFileSystem.AZURE_STORAGE_PUT_BLOB_THRESHOLD\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureFileSystem#AZURE_STORAGE_PUT_BLOB_THRESHOLD\"></xref> bytes will be buffered initially. If that threshold is exceeded, the data will be broken into chunks and sent in blocks, and writes will be buffered into sizes of <xref uid=\"com.azure.storage.blob.nio.AzureFileSystem.AZURE_STORAGE_UPLOAD_BLOCK_SIZE\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureFileSystem#AZURE_STORAGE_UPLOAD_BLOCK_SIZE\"></xref>. The maximum number of buffers of this size to be allocated is defined by <xref uid=\"com.azure.storage.blob.nio.AzureFileSystem.AZURE_STORAGE_MAX_CONCURRENCY_PER_REQUEST\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureFileSystem#AZURE_STORAGE_MAX_CONCURRENCY_PER_REQUEST\"></xref>, which also configures the level of parallelism with which we may write and thus may affect write speeds as well.\n\nThe data is only committed when the steam is closed. Hence, data cannot be read from the destination until the stream is closed. When the close method returns, it is guaranteed that, barring any errors, the data is finalized and available for reading.\n\nWriting happens asynchronously. Bytes passed for writing are stored until either the threshold or block size are met at which time they are sent to the service. When the write method returns, there is no guarantee about which phase of this process the data is in other than it has been accepted and will be written. Again, closing will guarantee that the data is written and available.\n\nFlush is a no-op as regards data transfers, but it can be used to check the state of the stream for errors. This can be a useful tool because writing happens asynchronously, and therefore an error from a previous write may not otherwise be thrown unless the stream is flushed, closed, or written to again."
  returns:
    description: "a new output stream"
    type: "<xref href=\"java.io.OutputStream?alt=java.io.OutputStream&text=OutputStream\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.readAttributes(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.readAttributes(Path path, String attributes, LinkOption[] linkOptions)"
  name: "readAttributes(Path path, String attributes, LinkOption[] linkOptions)"
  nameWithType: "AzureFileSystemProvider.readAttributes(Path path, String attributes, LinkOption[] linkOptions)"
  summary: "Reads a set of file attributes as a bulk operation."
  overridden: "java.nio.file.spi.FileSystemProvider.readAttributes(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)"
  parameters:
  - description: "the path to the file"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "the attributes to read"
    name: "attributes"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "ignored"
    name: "linkOptions"
    type: "<xref href=\"java.nio.file.LinkOption?alt=java.nio.file.LinkOption&text=LinkOption\" data-throw-if-not-resolved=\"False\" />[]"
  syntax: "public Map<String,Object> readAttributes(Path path, String attributes, LinkOption[] linkOptions)"
  exceptions:
  - description: "if an attributes of the given type are not supported"
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Reads a set of file attributes as a bulk operation.\n\nSee <xref uid=\"com.azure.storage.blob.nio.AzureBasicFileAttributes\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureBasicFileAttributes\"></xref> and <xref uid=\"com.azure.storage.blob.nio.AzureBlobFileAttributes\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureBlobFileAttributes\"></xref> for more information.\n\nReading attributes on a virtual directory will return `null` for all properties other than <xref uid=\"com.azure.storage.blob.nio.AzureBlobFileAttributes.isVirtualDirectory()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureBlobFileAttributes#isVirtualDirectory()\"></xref>, which will return true. See <xref uid=\"com.azure.storage.blob.nio.AzureFileSystemProvider.createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute<?>...)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#createDirectory(Path, FileAttribute[])\"></xref> for more information on virtual directories."
  returns:
    description: "a map of the attributes returned; may be empty. The map's keys are the attribute names, its values are\n the attribute values"
    type: "<xref href=\"java.util.Map?alt=java.util.Map&text=Map\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />,<xref href=\"java.lang.Object?alt=java.lang.Object&text=Object\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.nio.AzureFileSystemProvider.setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)"
  fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider.setAttribute(Path path, String attributes, Object value, LinkOption[] linkOptions)"
  name: "setAttribute(Path path, String attributes, Object value, LinkOption[] linkOptions)"
  nameWithType: "AzureFileSystemProvider.setAttribute(Path path, String attributes, Object value, LinkOption[] linkOptions)"
  summary: "Sets the value of a file attribute."
  overridden: "java.nio.file.spi.FileSystemProvider.setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)"
  parameters:
  - description: "the path to the file"
    name: "path"
    type: "<xref href=\"java.nio.file.Path?alt=java.nio.file.Path&text=Path\" data-throw-if-not-resolved=\"False\" />"
  - description: "the attribute to set"
    name: "attributes"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "the attribute value"
    name: "value"
    type: "<xref href=\"java.lang.Object?alt=java.lang.Object&text=Object\" data-throw-if-not-resolved=\"False\" />"
  - description: "ignored"
    name: "linkOptions"
    type: "<xref href=\"java.nio.file.LinkOption?alt=java.nio.file.LinkOption&text=LinkOption\" data-throw-if-not-resolved=\"False\" />[]"
  syntax: "public void setAttribute(Path path, String attributes, Object value, LinkOption[] linkOptions)"
  exceptions:
  - description: "if an attribute view is not available"
    type: "<xref href=\"java.io.IOException?alt=java.io.IOException&text=IOException\" data-throw-if-not-resolved=\"False\" />"
  desc: "Sets the value of a file attribute.\n\nSee <xref uid=\"com.azure.storage.blob.nio.AzureBlobFileAttributeView\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureBlobFileAttributeView\"></xref> for more information.\n\nSetting attributes on a virtual directory is not supported and will throw an <xref uid=\"java.io.IOException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"IOException\"></xref>. See <xref uid=\"com.azure.storage.blob.nio.AzureFileSystemProvider.createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute<?>...)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#createDirectory(Path, FileAttribute[])\"></xref> for more information on virtual directories."
type: "class"
desc: "The `AzureFileSystemProvider` is Azure Storage's implementation of the nio interface on top of Azure Blob Storage.\n\nParticular care should be taken when working with a remote storage service. This implementation makes no guarantees on behavior or state should other processes operate on the same data concurrently; file systems from this provider will assume they have exclusive access to their data and will behave without regard for potential of interfering applications. Moreover, remote file stores introduce higher latencies. Therefore, additional consideration should be given to managing concurrency: race conditions are more likely to manifest and network failures occur more frequently than disk failures. These and other such distributed application scenarios must be considered when working with this file system. While the `AzureFileSystem` will ensure it takes appropriate steps towards robustness and reliability, the application developer must design around these failure scenarios and have fallback and retry options available.\n\nThe Azure Blob Storage service backing these APIs is not a true FileSystem, nor is it the goal of this implementation to force Azure Blob Storage to act like a full-fledged file system. Some APIs and scenarios will remain unsupported indefinitely until they may be sensibly implemented. Other APIs may experience lower performance than is expected because of the number of network requests needed to ensure correctness. The javadocs for each type and method should also be read carefully to understand what guarantees are made and how they may differ from the contract defined by <xref uid=\"java.nio.file.spi.FileSystemProvider\" data-throw-if-not-resolved=\"false\" data-raw-source=\"FileSystemProvider\"></xref>.\n\nThe scheme for this provider is `\"azb\"`, and the format of the URI to identify an `AzureFileSystem` is `\"azb://?endpoint=\"`. The endpoint of the Storage account is used to uniquely identify the filesystem.\n\nAn <xref uid=\"com.azure.storage.blob.nio.AzureFileSystem\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureFileSystem\"></xref> is backed by an account. An <xref uid=\"com.azure.storage.blob.nio.AzureFileStore\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureFileStore\"></xref> is backed by a container. Any number of containers may be specified as file stores upon creation of the file system. When a file system is created, it will try to retrieve the properties of each container to ensure connection to the account. If any of the containers does not exist, it will be created. Failure to access or create containers as necessary will result in an exception and failure to create the file system. Any data existing in the containers will be preserved and accessible via the file system, though customers should be aware that it must be in a format understandable by the types in this package or behavior will be undefined.\n\n<xref uid=\"com.azure.storage.blob.nio.AzureFileSystemProvider.newFileSystem(java.net.URI,java.util.Map<java.lang.String,?>)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#newFileSystem(URI, Map)\"></xref> will check for the following keys in the configuration map and expect the named types. Any entries not listed here will be ignored. Note that <xref uid=\"com.azure.storage.blob.nio.AzureFileSystem\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureFileSystem\"></xref> has public constants defined for each of the keys for convenience. Most values are documented in the blob package. Any values which are unique to nio will be documented here.\n\n *  `AzureStorageSharedKeyCredential:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.storage.common.StorageSharedKeyCredential\"></xref>\n *  `AzureStorageSasTokenCredential:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.core.credential.AzureSasCredential\"></xref>\n *  `AzureStorageHttpLogDetailLevel:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.core.http.policy.HttpLogDetailLevel\"></xref>\n *  `AzureStorageMaxTries:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Integer\"></xref>\n *  `AzureStorageTryTimeout:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Integer\"></xref>\n *  `AzureStorageRetryDelayInMs:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Long\"></xref>\n *  `AzureStorageMaxRetryDelayInMs:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Long\"></xref>\n *  `AzureStorageRetryPolicyType:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.storage.common.policy.RetryPolicyType\"></xref>\n *  `AzureStorageSecondaryHost:`<xref uid=\"java.lang.String\" data-throw-if-not-resolved=\"false\" data-raw-source=\"String\"></xref>\n *  `AzureStorageSecondaryHost:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Integer\"></xref>\n *  `AzureStorageBlockSize:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Long\"></xref>\n *  `AzureStoragePutBlobThreshold:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Long\"></xref>\n *  `AzureStorageMaxConcurrencyPerRequest:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Integer\"></xref>\n *  `AzureStorageDownloadResumeRetries:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Integer\"></xref>\n *  `AzureStorageFileStores:`<xref uid=\"java.lang.String\" data-throw-if-not-resolved=\"false\" data-raw-source=\"String\"></xref>\n *  `AzureStorageSkipInitialContainerCheck:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Boolean\"></xref>. Indicates that the initial check which confirms the existence of the containers meant to act as file stores should be skipped. This can be useful in cases where a sas token that is scoped to only one file is used to authenticate.\n\nEither an account key or a sas token must be specified. If both are provided, the account key will be preferred. If a sas token is specified, the customer must take care that it has appropriate permissions to perform the actions demanded of the file system in a given workflow, including the initial connection check specified above. The same token will be applied to all operations.\n\nAn iterable of file stores must also be provided; each entry should simply be the name of a container. The first container listed will be considered the default file store and the root directory of which will be the file system's default directory. All other values listed are used to configure the underlying <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.storage.blob.BlobServiceClient\"></xref>. Please refer to that type for more information on these values."
metadata: {}
package: "com.azure.storage.blob.nio"
artifact: com.azure:azure-storage-blob-nio:12.0.0-beta.19
