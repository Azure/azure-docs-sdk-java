### YamlMime:JavaType
uid: "com.azure.storage.blob.nio.AzureFileSystemProvider"
fullName: "com.azure.storage.blob.nio.AzureFileSystemProvider"
name: "AzureFileSystemProvider"
nameWithType: "AzureFileSystemProvider"
summary: "The `AzureFileSystemProvider` is Azure Storage's implementation of the nio interface on top of Azure Blob Storage.\n\nParticular care should be taken when working with a remote storage service. This implementation makes no guarantees on behavior or state should other processes operate on the same data concurrently; file systems from this provider will assume they have exclusive access to their data and will behave without regard for potential of interfering applications. Moreover, remote file stores introduce higher latencies. Therefore, additional consideration should be given to managing concurrency: race conditions are more likely to manifest and network failures occur more frequently than disk failures. These and other such distributed application scenarios must be considered when working with this file system. While the `AzureFileSystem` will ensure it takes appropriate steps towards robustness and reliability, the application developer must design around these failure scenarios and have fallback and retry options available.\n\nThe Azure Blob Storage service backing these APIs is not a true FileSystem, nor is it the goal of this implementation to force Azure Blob Storage to act like a full-fledged file system. Some APIs and scenarios will remain unsupported indefinitely until they may be sensibly implemented. Other APIs may experience lower performance than is expected because of the number of network requests needed to ensure correctness. The javadocs for each type and method should also be read carefully to understand what guarantees are made and how they may differ from the contract defined by <xref uid=\"java.nio.file.spi.FileSystemProvider\" data-throw-if-not-resolved=\"false\" data-raw-source=\"FileSystemProvider\"></xref>.\n\nThe scheme for this provider is `\"azb\"`, and the format of the URI to identify an `AzureFileSystem` is `\"azb://?account=\"`. The name of the Storage account is used to uniquely identify the file system.\n\nAn <xref uid=\"com.azure.storage.blob.nio.AzureFileSystem\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureFileSystem\"></xref> is backed by an account. An <xref uid=\"com.azure.storage.blob.nio.AzureFileStore\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureFileStore\"></xref> is backed by a container. Any number of containers may be specified as file stores upon creation of the file system. When a file system is created, it will try to retrieve the properties of each container to ensure connection to the account. If any of the containers does not exist, it will be created. Failure to access or create containers as necessary will result in an exception and failure to create the file system. Any data existing in the containers will be preserved and accessible via the file system, though customers should be aware that it must be in a format understandable by the types in this package or behavior will be undefined.\n\n<xref uid=\"com.azure.storage.blob.nio.AzureFileSystemProvider.newFileSystem(java.net.URI,java.util.Map&lt;java.lang.String,?&gt;)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#newFileSystem(URI, Map)\"></xref> will check for the following keys in the configuration map and expect the named types. Any entries not listed here will be ignored. Note that <xref uid=\"com.azure.storage.blob.nio.AzureFileSystem\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AzureFileSystem\"></xref> has public constants defined for each of the keys for convenience.\n\n *  `AzureStorageAccountKey:`<xref uid=\"java.lang.String\" data-throw-if-not-resolved=\"false\" data-raw-source=\"String\"></xref>\n *  `AzureStorageSasToken:`<xref uid=\"java.lang.String\" data-throw-if-not-resolved=\"false\" data-raw-source=\"String\"></xref>\n *  `AzureStorageHttpLogDetailLevel:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.core.http.policy.HttpLogDetailLevel\"></xref>\n *  `AzureStorageMaxTries:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Integer\"></xref>\n *  `AzureStorageTryTimeout:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Integer\"></xref>\n *  `AzureStorageRetryDelayInMs:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Long\"></xref>\n *  `AzureStorageMaxRetryDelayInMs:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Long\"></xref>\n *  `AzureStorageRetryPolicyType:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.storage.common.policy.RetryPolicyType\"></xref>\n *  `AzureStorageSecondaryHost:`<xref uid=\"java.lang.String\" data-throw-if-not-resolved=\"false\" data-raw-source=\"String\"></xref>\n *  `AzureStorageSecondaryHost:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Integer\"></xref>\n *  `AzureStorageBlockSize:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Long\"></xref>\n *  `AzureStoragePutBlobThreshold:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Long\"></xref>\n *  `AzureStorageMaxConcurrencyPerRequest:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Integer\"></xref>\n *  `AzureStorageDownloadResumeRetries:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Integer\"></xref>\n *  `AzureStorageUseHttps:`<xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Boolean\"></xref>\n *  `AzureStorageFileStores:`<xref uid=\"java.lang.String\" data-throw-if-not-resolved=\"false\" data-raw-source=\"String\"></xref>\n\nEither an account key or a sas token must be specified. If both are provided, the account key will be preferred. If a sas token is specified, the customer must take care that it has appropriate permissions to perform the actions demanded of the file system in a given workflow, including the initial connection check specified above. Furthermore, it must have an expiry time that lasts at least until the file system is closed as there is no token refresh offered at this time. The same token will be applied to all containers.\n\nAn iterable of file stores must also be provided; each entry should simply be the name of a container. The first container listed will be considered the default file store and the root directory of which will be the file system's default directory. All other values listed are used to configure the underlying <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"com.azure.storage.blob.BlobServiceClient\"></xref>. Please refer to that type for more information on these values."
inheritances:
- "<xref href=\"java.lang.Object\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"java.nio.file.spi.FileSystemProvider\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
- "java.nio.file.spi.FileSystemProvider.<A>readAttributes(java.nio.file.Path,java.lang.Class<A>,java.nio.file.LinkOption...)"
- "java.nio.file.spi.FileSystemProvider.<V>getFileAttributeView(java.nio.file.Path,java.lang.Class<V>,java.nio.file.LinkOption...)"
- "java.nio.file.spi.FileSystemProvider.checkAccess(java.nio.file.Path,java.nio.file.AccessMode...)"
- "java.nio.file.spi.FileSystemProvider.copy(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)"
- "java.nio.file.spi.FileSystemProvider.createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute<?>...)"
- "java.nio.file.spi.FileSystemProvider.createLink(java.nio.file.Path,java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.createSymbolicLink(java.nio.file.Path,java.nio.file.Path,java.nio.file.attribute.FileAttribute<?>...)"
- "java.nio.file.spi.FileSystemProvider.delete(java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.deleteIfExists(java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.getFileStore(java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.getFileSystem(java.net.URI)"
- "java.nio.file.spi.FileSystemProvider.getPath(java.net.URI)"
- "java.nio.file.spi.FileSystemProvider.getScheme()"
- "java.nio.file.spi.FileSystemProvider.installedProviders()"
- "java.nio.file.spi.FileSystemProvider.isHidden(java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.isSameFile(java.nio.file.Path,java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.move(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)"
- "java.nio.file.spi.FileSystemProvider.newAsynchronousFileChannel(java.nio.file.Path,java.util.Set<? extends java.nio.file.OpenOption>,java.util.concurrent.ExecutorService,java.nio.file.attribute.FileAttribute<?>...)"
- "java.nio.file.spi.FileSystemProvider.newByteChannel(java.nio.file.Path,java.util.Set<? extends java.nio.file.OpenOption>,java.nio.file.attribute.FileAttribute<?>...)"
- "java.nio.file.spi.FileSystemProvider.newDirectoryStream(java.nio.file.Path,java.nio.file.DirectoryStream.Filter<? super java.nio.file.Path>)"
- "java.nio.file.spi.FileSystemProvider.newFileChannel(java.nio.file.Path,java.util.Set<? extends java.nio.file.OpenOption>,java.nio.file.attribute.FileAttribute<?>...)"
- "java.nio.file.spi.FileSystemProvider.newFileSystem(java.net.URI,java.util.Map<java.lang.String,?>)"
- "java.nio.file.spi.FileSystemProvider.newFileSystem(java.nio.file.Path,java.util.Map<java.lang.String,?>)"
- "java.nio.file.spi.FileSystemProvider.newInputStream(java.nio.file.Path,java.nio.file.OpenOption...)"
- "java.nio.file.spi.FileSystemProvider.newOutputStream(java.nio.file.Path,java.nio.file.OpenOption...)"
- "java.nio.file.spi.FileSystemProvider.readAttributes(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)"
- "java.nio.file.spi.FileSystemProvider.readSymbolicLink(java.nio.file.Path)"
- "java.nio.file.spi.FileSystemProvider.setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)"
syntax: "public final class AzureFileSystemProvider extends FileSystemProvider"
constructors:
- "com.azure.storage.blob.nio.AzureFileSystemProvider.AzureFileSystemProvider()"
fields:
- "com.azure.storage.blob.nio.AzureFileSystemProvider.CACHE_CONTROL"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_DISPOSITION"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_ENCODING"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_LANGUAGE"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_MD5"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.CONTENT_TYPE"
methods:
- "com.azure.storage.blob.nio.AzureFileSystemProvider.<A>readAttributes(java.nio.file.Path,java.lang.Class<A>,java.nio.file.LinkOption...)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.<V>getFileAttributeView(java.nio.file.Path,java.lang.Class<V>,java.nio.file.LinkOption...)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.checkAccess(java.nio.file.Path,java.nio.file.AccessMode...)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.copy(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute<?>...)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.delete(java.nio.file.Path)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.getFileStore(java.nio.file.Path)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.getFileSystem(java.net.URI)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.getPath(java.net.URI)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.getScheme()"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.isHidden(java.nio.file.Path)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.isSameFile(java.nio.file.Path,java.nio.file.Path)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.move(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.newByteChannel(java.nio.file.Path,java.util.Set<? extends java.nio.file.OpenOption>,java.nio.file.attribute.FileAttribute<?>...)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.newDirectoryStream(java.nio.file.Path,java.nio.file.DirectoryStream.Filter<? super java.nio.file.Path>)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.newFileSystem(java.net.URI,java.util.Map<java.lang.String,?>)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.newInputStream(java.nio.file.Path,java.nio.file.OpenOption...)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.newOutputStream(java.nio.file.Path,java.nio.file.OpenOption...)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.readAttributes(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)"
- "com.azure.storage.blob.nio.AzureFileSystemProvider.setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)"
type: "class"
metadata: {}
package: "com.azure.storage.blob.nio"
artifact: com.azure:azure-storage-blob-nio:12.0.0-beta.2
