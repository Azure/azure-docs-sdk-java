### YamlMime:JavaMember
uid: "com.azure.cosmos.implementation.guava25.collect.Streams.mapWithIndex*"
fullName: "com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex"
name: "<R>mapWithIndex"
nameWithType: "Streams.<R>mapWithIndex"
members:
- uid: "com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(java.util.stream.DoubleStream,com.azure.cosmos.implementation.guava25.collect.Streams.DoubleFunctionWithIndex<R>)"
  fullName: "com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(DoubleStream stream, Streams.DoubleFunctionWithIndex<R> function)"
  name: "<R>mapWithIndex(DoubleStream stream, Streams.DoubleFunctionWithIndex<R> function)"
  nameWithType: "Streams.<R>mapWithIndex(DoubleStream stream, Streams.DoubleFunctionWithIndex<R> function)"
  summary: "Returns a stream consisting of the results of applying the given function to the elements of `stream` and their indexes in the stream. For example,\n\n```java\nmapWithIndex(\n     DoubleStream.of(0, 1, 2),\n     (x, index) -> x + \":\" + index)\n```\n\n...would return `Stream.of(\"0.0:0\", \"1.0:1\", \"2.0:2\")`.\n\nThe resulting stream is [efficiently splittable][] if and only if `stream` was efficiently splittable and its underlying spliterator reported <xref uid=\"java.util.Spliterator.SUBSIZED\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Spliterator#SUBSIZED\"></xref>. This is generally the case if the underlying stream comes from a data structure supporting efficient indexed random access, typically an array or list.\n\nThe order of the resulting stream is defined if and only if the order of the original stream was defined.\n\n\n[efficiently splittable]: http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html"
  parameters:
  - name: "stream"
    type: "<xref href=\"java.util.stream.DoubleStream?alt=java.util.stream.DoubleStream&text=DoubleStream\" data-throw-if-not-resolved=\"False\" />"
  - name: "function"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.Streams.DoubleFunctionWithIndex?alt=com.azure.cosmos.implementation.guava25.collect.Streams.DoubleFunctionWithIndex&text=DoubleFunctionWithIndex\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"R?alt=R&text=R\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static Stream<R> <R>mapWithIndex(DoubleStream stream, Streams.DoubleFunctionWithIndex<R> function)"
  returns:
    type: "<xref href=\"java.util.stream.Stream?alt=java.util.stream.Stream&text=Stream\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"R?alt=R&text=R\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(java.util.stream.IntStream,com.azure.cosmos.implementation.guava25.collect.Streams.IntFunctionWithIndex<R>)"
  fullName: "com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(IntStream stream, Streams.IntFunctionWithIndex<R> function)"
  name: "<R>mapWithIndex(IntStream stream, Streams.IntFunctionWithIndex<R> function)"
  nameWithType: "Streams.<R>mapWithIndex(IntStream stream, Streams.IntFunctionWithIndex<R> function)"
  summary: "Returns a stream consisting of the results of applying the given function to the elements of `stream` and their indexes in the stream. For example,\n\n```java\nmapWithIndex(\n     IntStream.of(0, 1, 2),\n     (i, index) -> i + \":\" + index)\n```\n\n...would return `Stream.of(\"0:0\", \"1:1\", \"2:2\")`.\n\nThe resulting stream is [efficiently splittable][] if and only if `stream` was efficiently splittable and its underlying spliterator reported <xref uid=\"java.util.Spliterator.SUBSIZED\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Spliterator#SUBSIZED\"></xref>. This is generally the case if the underlying stream comes from a data structure supporting efficient indexed random access, typically an array or list.\n\nThe order of the resulting stream is defined if and only if the order of the original stream was defined.\n\n\n[efficiently splittable]: http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html"
  parameters:
  - name: "stream"
    type: "<xref href=\"java.util.stream.IntStream?alt=java.util.stream.IntStream&text=IntStream\" data-throw-if-not-resolved=\"False\" />"
  - name: "function"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.Streams.IntFunctionWithIndex?alt=com.azure.cosmos.implementation.guava25.collect.Streams.IntFunctionWithIndex&text=IntFunctionWithIndex\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"R?alt=R&text=R\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static Stream<R> <R>mapWithIndex(IntStream stream, Streams.IntFunctionWithIndex<R> function)"
  returns:
    type: "<xref href=\"java.util.stream.Stream?alt=java.util.stream.Stream&text=Stream\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"R?alt=R&text=R\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(java.util.stream.LongStream,com.azure.cosmos.implementation.guava25.collect.Streams.LongFunctionWithIndex<R>)"
  fullName: "com.azure.cosmos.implementation.guava25.collect.Streams.<R>mapWithIndex(LongStream stream, Streams.LongFunctionWithIndex<R> function)"
  name: "<R>mapWithIndex(LongStream stream, Streams.LongFunctionWithIndex<R> function)"
  nameWithType: "Streams.<R>mapWithIndex(LongStream stream, Streams.LongFunctionWithIndex<R> function)"
  summary: "Returns a stream consisting of the results of applying the given function to the elements of `stream` and their indexes in the stream. For example,\n\n```java\nmapWithIndex(\n     LongStream.of(0, 1, 2),\n     (i, index) -> i + \":\" + index)\n```\n\n...would return `Stream.of(\"0:0\", \"1:1\", \"2:2\")`.\n\nThe resulting stream is [efficiently splittable][] if and only if `stream` was efficiently splittable and its underlying spliterator reported <xref uid=\"java.util.Spliterator.SUBSIZED\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Spliterator#SUBSIZED\"></xref>. This is generally the case if the underlying stream comes from a data structure supporting efficient indexed random access, typically an array or list.\n\nThe order of the resulting stream is defined if and only if the order of the original stream was defined.\n\n\n[efficiently splittable]: http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html"
  parameters:
  - name: "stream"
    type: "<xref href=\"java.util.stream.LongStream?alt=java.util.stream.LongStream&text=LongStream\" data-throw-if-not-resolved=\"False\" />"
  - name: "function"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.Streams.LongFunctionWithIndex?alt=com.azure.cosmos.implementation.guava25.collect.Streams.LongFunctionWithIndex&text=LongFunctionWithIndex\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"R?alt=R&text=R\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static Stream<R> <R>mapWithIndex(LongStream stream, Streams.LongFunctionWithIndex<R> function)"
  returns:
    type: "<xref href=\"java.util.stream.Stream?alt=java.util.stream.Stream&text=Stream\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"R?alt=R&text=R\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.cosmos.implementation.guava25.collect.Streams.<T,R>mapWithIndex(java.util.stream.Stream<T>,com.azure.cosmos.implementation.guava25.collect.Streams.FunctionWithIndex<? super T,? extends R>)"
  fullName: "com.azure.cosmos.implementation.guava25.collect.Streams.<T,R>mapWithIndex(Stream<T> stream, Streams.FunctionWithIndex<? super T,? extends R> function)"
  name: "<T,R>mapWithIndex(Stream<T> stream, Streams.FunctionWithIndex<? super T,? extends R> function)"
  nameWithType: "Streams.<T,R>mapWithIndex(Stream<T> stream, Streams.FunctionWithIndex<? super T,? extends R> function)"
  summary: "Returns a stream consisting of the results of applying the given function to the elements of `stream` and their indices in the stream. For example,\n\n```java\nmapWithIndex(\n     Stream.of(\"a\", \"b\", \"c\"),\n     (str, index) -> str + \":\" + index)\n```\n\nwould return `Stream.of(\"a:0\", \"b:1\", \"c:2\")`.\n\nThe resulting stream is [efficiently splittable][] if and only if `stream` was efficiently splittable and its underlying spliterator reported <xref uid=\"java.util.Spliterator.SUBSIZED\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Spliterator#SUBSIZED\"></xref>. This is generally the case if the underlying stream comes from a data structure supporting efficient indexed random access, typically an array or list.\n\nThe order of the resulting stream is defined if and only if the order of the original stream was defined.\n\n\n[efficiently splittable]: http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html"
  parameters:
  - name: "stream"
    type: "<xref href=\"java.util.stream.Stream?alt=java.util.stream.Stream&text=Stream\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
  - name: "function"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.Streams.FunctionWithIndex?alt=com.azure.cosmos.implementation.guava25.collect.Streams.FunctionWithIndex&text=FunctionWithIndex\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"? super T?alt=? super T&text=? super T\" data-throw-if-not-resolved=\"False\" />,<xref href=\"? extends R?alt=? extends R&text=? extends R\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static Stream<R> <T,R>mapWithIndex(Stream<T> stream, Streams.FunctionWithIndex<? super T,? extends R> function)"
  returns:
    type: "<xref href=\"java.util.stream.Stream?alt=java.util.stream.Stream&text=Stream\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"R?alt=R&text=R\" data-throw-if-not-resolved=\"False\" />&gt;"
type: "method"
metadata: {}
package: "com.azure.cosmos.implementation.guava25.collect"
artifact: com.azure:azure-cosmos:4.4.0-beta.1
