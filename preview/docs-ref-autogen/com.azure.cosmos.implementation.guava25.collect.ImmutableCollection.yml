### YamlMime:JavaType
uid: "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection"
fullName: "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection<E>"
name: "ImmutableCollection<E>"
nameWithType: "ImmutableCollection<E>"
summary: "A <xref uid=\"java.util.Collection\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Collection\"></xref> whose contents will never change, and which offers a few additional guarantees detailed below.\n\n**Warning:** avoid *direct* usage of <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableCollection\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ImmutableCollection\"></xref> as a type (just as with <xref uid=\"java.util.Collection\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Collection\"></xref> itself). Prefer subtypes such as <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableSet\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ImmutableSet\"></xref> or <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableList\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ImmutableList\"></xref>, which have well-defined <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.equals\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#equals\"></xref> semantics, thus avoiding a common source of bugs and confusion.\n\n### About *all* `Immutable-` collections ###\n\nThe remainder of this documentation applies to every public `Immutable-` type in this package, whether it is a subtype of `ImmutableCollection` or not.\n\n#### Guarantees ####\n\nEach makes the following guarantees:\n\n *  **Shallow immutability.** Elements can never be added, removed or replaced in this collection. This is a stronger guarantee than that of <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Collections#unmodifiableCollection\"></xref>, whose contents change whenever the wrapped collection is modified.\n *  **Null-hostility.** This collection will never contain a null element.\n *  **Deterministic iteration.** The iteration order is always well-defined, depending on how the collection was created. Typically this is insertion order unless an explicit ordering is otherwise specified (e.g. <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableSortedSet.naturalOrder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ImmutableSortedSet#naturalOrder\"></xref>). See the appropriate factory method for details. View collections such as <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableMultiset.elementSet\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ImmutableMultiset#elementSet\"></xref> iterate in the same order as the parent, except as noted.\n *  **Thread safety.** It is safe to access this collection concurrently from multiple threads.\n *  **Integrity.** This type cannot be subclassed outside this package (which would allow these guarantees to be violated).\n\n#### \"Interfaces\", not implementations ####\n\nThese are classes instead of interfaces to prevent external subtyping, but should be thought of as interfaces in every important sense. Each public class such as <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableSet\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ImmutableSet\"></xref> is a *type* offering meaningful behavioral guarantees. This is substantially different from the case of (say) <xref uid=\"java.util.HashSet\" data-throw-if-not-resolved=\"false\" data-raw-source=\"HashSet\"></xref>, which is an *implementation*, with semantics that were largely defined by its supertype.\n\nFor field types and method return types, you should generally use the immutable type (such as <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableList\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ImmutableList\"></xref>) instead of the general collection interface type (such as <xref uid=\"java.util.List\" data-throw-if-not-resolved=\"false\" data-raw-source=\"List\"></xref>). This communicates to your callers all of the semantic guarantees listed above, which is almost always very useful information.\n\nOn the other hand, a *parameter* type of <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableList\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ImmutableList\"></xref> is generally a nuisance to callers. Instead, accept <xref uid=\"java.lang.Iterable\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Iterable\"></xref> and have your method or constructor body pass it to the appropriate `copyOf` method itself.\n\nExpressing the immutability guarantee directly in the type that user code references is a powerful advantage. Although Java 9 offers certain immutable collection factory methods, like [`Set.of`][Set.of], we recommend continuing to use these immutable collection classes for this reason.\n\n#### Creation ####\n\nExcept for logically \"abstract\" types like `ImmutableCollection` itself, each `Immutable` type provides the static operations you need to obtain instances of that type. These usually include:\n\n *  Static methods named `of`, accepting an explicit list of elements or entries.\n *  Static methods named `copyOf` (or `copyOfSorted`), accepting an existing collection whose contents should be copied.\n *  A static nested `Builder` class which can be used to populate a new immutable instance.\n\n#### Warnings ####\n\n *  **Warning:** as with any collection, it is almost always a bad idea to modify an element (in a way that affects its <xref uid=\"java.lang.Object.equals\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Object#equals\"></xref> behavior) while it is contained in a collection. Undefined behavior and bugs will result. It's generally best to avoid using mutable objects as elements at all, as many users may expect your \"immutable\" object to be *deeply* immutable.\n\n#### Performance notes ####\n\n *  Implementations can be generally assumed to prioritize memory efficiency, then speed of access, and lastly speed of creation.\n *  The `copyOf` methods will sometimes recognize that the actual copy operation is unnecessary; for example, `copyOf(copyOf(anArrayList))` should copy the data only once. This reduces the expense of habitually making defensive copies at API boundaries. However, the precise conditions for skipping the copy operation are undefined.\n *  **Warning:** a view collection such as <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableMap.keySet\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ImmutableMap#keySet\"></xref> or <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableList.subList\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ImmutableList#subList\"></xref> may retain a reference to the entire data set, preventing it from being garbage collected. If some of the data is no longer reachable through other means, this constitutes a memory leak. Pass the view collection to the appropriate `copyOf` method to obtain a correctly-sized copy.\n *  The performance of using the associated `Builder` class can be assumed to be no worse, and possibly better, than creating a mutable collection and copying it.\n *  Implementations generally do not cache hash codes. If your element or key type has a slow `hashCode` implementation, it should cache it itself.\n\n#### Example usage ####\n\n```java\nclass Foo {\n   private static final ImmutableSet RESERVED_CODES =\n       ImmutableSet.of(\"AZ\", \"CQ\", \"ZX\");\n\n   private final ImmutableSet codes;\n\n   public Foo(Iterable codes) {\n     this.codes = ImmutableSet.copyOf(codes);\n     checkArgument(Collections.disjoint(this.codes, RESERVED_CODES));\n   }\n }\n```\n\n### See also ###\n\nSee the Guava User Guide article on [ immutable collections][immutable collections].\n\n\n[Set.of]: https://docs.oracle.com/javase/9/docs/api/java/util/Set.html#immutable\n[immutable collections]: https://github.com/google/guava/wiki/ImmutableCollectionsExplained"
inheritances:
- "<xref href=\"java.lang.Object\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"java.util.AbstractCollection\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
- "java.util.AbstractCollection.<T>toArray(T[])"
- "java.util.AbstractCollection.add(E)"
- "java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"
- "java.util.AbstractCollection.clear()"
- "java.util.AbstractCollection.contains(java.lang.Object)"
- "java.util.AbstractCollection.containsAll(java.util.Collection<?>)"
- "java.util.AbstractCollection.isEmpty()"
- "java.util.AbstractCollection.iterator()"
- "java.util.AbstractCollection.remove(java.lang.Object)"
- "java.util.AbstractCollection.removeAll(java.util.Collection<?>)"
- "java.util.AbstractCollection.retainAll(java.util.Collection<?>)"
- "java.util.AbstractCollection.size()"
- "java.util.AbstractCollection.toArray()"
- "java.util.AbstractCollection.toString()"
syntax: "public abstract class ImmutableCollection<E> extends AbstractCollection<E> implements Serializable"
methods:
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.<T>toArray(T[])"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.add(E)"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.asList()"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.clear()"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.contains(java.lang.Object)"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.iterator()"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.remove(java.lang.Object)"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.spliterator()"
- "com.azure.cosmos.implementation.guava25.collect.ImmutableCollection.toArray()"
type: "class"
typeParameters:
- name: "E"
implements:
- "<xref href=\"java.io.Serializable?alt=java.io.Serializable&text=Serializable\" data-throw-if-not-resolved=\"False\" />"
metadata: {}
package: "com.azure.cosmos.implementation.guava25.collect"
artifact: com.azure:azure-cosmos:4.4.0-beta.1
