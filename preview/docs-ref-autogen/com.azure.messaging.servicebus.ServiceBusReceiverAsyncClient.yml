### YamlMime:JavaType
uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
name: "ServiceBusReceiverAsyncClient"
nameWithType: "ServiceBusReceiverAsyncClient"
summary: "An **asynchronous** receiver responsible for receiving <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"messages\"></xref> from an Azure Service Bus queue or topic/subscription."
inheritances:
- "<xref href=\"java.lang.Object?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
inheritedClassMethods:
- classRef: "java.lang.<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html\">Object</a>"
  methodsRef:
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--\">clone</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-\">equals</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize--\">finalize</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--\">getClass</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--\">hashCode</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify--\">notify</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll--\">notifyAll</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--\">toString</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--\">wait</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait-long-\">wait</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait-long-int-\">wait</a>"
syntax: "public final class **ServiceBusReceiverAsyncClient**</br> implements <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html\">AutoCloseable</a>"
methods:
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(ServiceBusReceivedMessage message)"
  name: "abandon(ServiceBusReceivedMessage message)"
  nameWithType: "ServiceBusReceiverAsyncClient.abandon(ServiceBusReceivedMessage message)"
  summary: "Abandons a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref>."
  parameters:
  - description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref> to perform this operation."
    name: "message"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> abandon(ServiceBusReceivedMessage message)"
  desc: "Abandons a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref>. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that completes when the Service Bus abandon operation completes."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.models.AbandonOptions)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(ServiceBusReceivedMessage message, AbandonOptions options)"
  name: "abandon(ServiceBusReceivedMessage message, AbandonOptions options)"
  nameWithType: "ServiceBusReceiverAsyncClient.abandon(ServiceBusReceivedMessage message, AbandonOptions options)"
  summary: "Abandons a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref> updates the message's properties."
  parameters:
  - description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref> to perform this operation."
    name: "message"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />"
  - description: "The options to set while abandoning the message."
    name: "options"
    type: "<xref href=\"com.azure.messaging.servicebus.models.AbandonOptions?alt=com.azure.messaging.servicebus.models.AbandonOptions&text=AbandonOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> abandon(ServiceBusReceivedMessage message, AbandonOptions options)"
  desc: "Abandons a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref> updates the message's properties. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that completes when the Service Bus operation finishes."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.close()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.close()"
  name: "close()"
  nameWithType: "ServiceBusReceiverAsyncClient.close()"
  summary: "Disposes of the consumer by closing the underlying links to the service."
  syntax: "public void close()"
  desc: "Disposes of the consumer by closing the underlying links to the service."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.commitTransaction(com.azure.messaging.servicebus.ServiceBusTransactionContext)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.commitTransaction(ServiceBusTransactionContext transactionContext)"
  name: "commitTransaction(ServiceBusTransactionContext transactionContext)"
  nameWithType: "ServiceBusReceiverAsyncClient.commitTransaction(ServiceBusTransactionContext transactionContext)"
  summary: "Commits the transaction and all the operations associated with it."
  parameters:
  - description: "The transaction to be commit."
    name: "transactionContext"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusTransactionContext?alt=com.azure.messaging.servicebus.ServiceBusTransactionContext&text=ServiceBusTransactionContext\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> commitTransaction(ServiceBusTransactionContext transactionContext)"
  desc: "Commits the transaction and all the operations associated with it.\n\n**Creating and using a transaction**\n\n```java\n// This mono creates a transaction and caches the output value, so we can associate operations with the\n // transaction. It does not cache the value if it is an error or completes with no items, effectively retrying\n // the operation.\n Mono<ServiceBusTransactionContext> transactionContext = asyncReceiver.createTransaction()\n     .cache(value -> Duration.ofMillis(Long.MAX_VALUE),\n         error -> Duration.ZERO,\n         () -> Duration.ZERO);\n\n // Dispose of the disposable to cancel the operation.\n Disposable disposable = transactionContext.flatMap(transaction -> {\n     // Process messages and associate operations with the transaction.\n     Mono<Void> operations = Mono.when(\n         asyncReceiver.receiveDeferredMessage(sequenceNumber).flatMap(message ->\n             asyncReceiver.complete(message, new CompleteOptions().setTransactionContext(transaction))),\n         asyncReceiver.abandon(receivedMessage, new AbandonOptions().setTransactionContext(transaction)));\n\n     // Finally, either commit or rollback the transaction once all the operations are associated with it.\n     return operations.then(asyncReceiver.commitTransaction(transaction));\n }).subscribe(unused -> {\n }, error -> {\n     System.err.println(\"Error occurred processing transaction: \" + error);\n }, () -> {\n     System.out.println(\"Completed transaction\");\n });\n```"
  returns:
    description: "The <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that finishes this operation on service bus resource."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(ServiceBusReceivedMessage message)"
  name: "complete(ServiceBusReceivedMessage message)"
  nameWithType: "ServiceBusReceiverAsyncClient.complete(ServiceBusReceivedMessage message)"
  summary: "Completes a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref>."
  parameters:
  - description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref> to perform this operation."
    name: "message"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> complete(ServiceBusReceivedMessage message)"
  desc: "Completes a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref>. This will delete the message from the service."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that finishes when the message is completed on Service Bus."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.models.CompleteOptions)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(ServiceBusReceivedMessage message, CompleteOptions options)"
  name: "complete(ServiceBusReceivedMessage message, CompleteOptions options)"
  nameWithType: "ServiceBusReceiverAsyncClient.complete(ServiceBusReceivedMessage message, CompleteOptions options)"
  summary: "Completes a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref> with the given options."
  parameters:
  - description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref> to perform this operation."
    name: "message"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />"
  - description: "Options used to complete the message."
    name: "options"
    type: "<xref href=\"com.azure.messaging.servicebus.models.CompleteOptions?alt=com.azure.messaging.servicebus.models.CompleteOptions&text=CompleteOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> complete(ServiceBusReceivedMessage message, CompleteOptions options)"
  desc: "Completes a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref> with the given options. This will delete the message from the service."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that finishes when the message is completed on Service Bus."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.createTransaction()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.createTransaction()"
  name: "createTransaction()"
  nameWithType: "ServiceBusReceiverAsyncClient.createTransaction()"
  summary: "Starts a new service side transaction."
  syntax: "public Mono<ServiceBusTransactionContext> createTransaction()"
  desc: "Starts a new service side transaction. The <xref uid=\"com.azure.messaging.servicebus.ServiceBusTransactionContext\" data-throw-if-not-resolved=\"false\" data-raw-source=\"transaction context\"></xref> should be passed to all operations that needs to be in this transaction.\n\n**Creating and using a transaction**\n\n```java\n// This mono creates a transaction and caches the output value, so we can associate operations with the\n // transaction. It does not cache the value if it is an error or completes with no items, effectively retrying\n // the operation.\n Mono<ServiceBusTransactionContext> transactionContext = asyncReceiver.createTransaction()\n     .cache(value -> Duration.ofMillis(Long.MAX_VALUE),\n         error -> Duration.ZERO,\n         () -> Duration.ZERO);\n\n // Dispose of the disposable to cancel the operation.\n Disposable disposable = transactionContext.flatMap(transaction -> {\n     // Process messages and associate operations with the transaction.\n     Mono<Void> operations = Mono.when(\n         asyncReceiver.receiveDeferredMessage(sequenceNumber).flatMap(message ->\n             asyncReceiver.complete(message, new CompleteOptions().setTransactionContext(transaction))),\n         asyncReceiver.abandon(receivedMessage, new AbandonOptions().setTransactionContext(transaction)));\n\n     // Finally, either commit or rollback the transaction once all the operations are associated with it.\n     return operations.then(asyncReceiver.commitTransaction(transaction));\n }).subscribe(unused -> {\n }, error -> {\n     System.err.println(\"Error occurred processing transaction: \" + error);\n }, () -> {\n     System.out.println(\"Completed transaction\");\n });\n```"
  returns:
    description: "The <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that finishes this operation on service bus resource."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.messaging.servicebus.ServiceBusTransactionContext?alt=com.azure.messaging.servicebus.ServiceBusTransactionContext&text=ServiceBusTransactionContext\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(ServiceBusReceivedMessage message)"
  name: "deadLetter(ServiceBusReceivedMessage message)"
  nameWithType: "ServiceBusReceiverAsyncClient.deadLetter(ServiceBusReceivedMessage message)"
  summary: "Moves a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref> to the dead-letter sub-queue."
  parameters:
  - description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref> to perform this operation."
    name: "message"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> deadLetter(ServiceBusReceivedMessage message)"
  desc: "Moves a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref> to the dead-letter sub-queue."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that completes when the dead letter operation finishes."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.models.DeadLetterOptions)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(ServiceBusReceivedMessage message, DeadLetterOptions options)"
  name: "deadLetter(ServiceBusReceivedMessage message, DeadLetterOptions options)"
  nameWithType: "ServiceBusReceiverAsyncClient.deadLetter(ServiceBusReceivedMessage message, DeadLetterOptions options)"
  summary: "Moves a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref> to the dead-letter sub-queue with the given options."
  parameters:
  - description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref> to perform this operation."
    name: "message"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />"
  - description: "Options used to dead-letter the message."
    name: "options"
    type: "<xref href=\"com.azure.messaging.servicebus.models.DeadLetterOptions?alt=com.azure.messaging.servicebus.models.DeadLetterOptions&text=DeadLetterOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> deadLetter(ServiceBusReceivedMessage message, DeadLetterOptions options)"
  desc: "Moves a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref> to the dead-letter sub-queue with the given options."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that completes when the dead letter operation finishes."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(ServiceBusReceivedMessage message)"
  name: "defer(ServiceBusReceivedMessage message)"
  nameWithType: "ServiceBusReceiverAsyncClient.defer(ServiceBusReceivedMessage message)"
  summary: "Defers a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref>."
  parameters:
  - description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref> to perform this operation."
    name: "message"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> defer(ServiceBusReceivedMessage message)"
  desc: "Defers a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref>. This will move message into the deferred sub-queue."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that completes when the Service Bus defer operation finishes."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.models.DeferOptions)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(ServiceBusReceivedMessage message, DeferOptions options)"
  name: "defer(ServiceBusReceivedMessage message, DeferOptions options)"
  nameWithType: "ServiceBusReceiverAsyncClient.defer(ServiceBusReceivedMessage message, DeferOptions options)"
  summary: "Defers a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref> with the options set."
  parameters:
  - description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref> to perform this operation."
    name: "message"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />"
  - description: "Options used to defer the message."
    name: "options"
    type: "<xref href=\"com.azure.messaging.servicebus.models.DeferOptions?alt=com.azure.messaging.servicebus.models.DeferOptions&text=DeferOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> defer(ServiceBusReceivedMessage message, DeferOptions options)"
  desc: "Defers a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref> with the options set. This will move message into the deferred sub-queue."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that completes when the defer operation finishes."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deleteMessages(int)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deleteMessages(int messageCount)"
  name: "deleteMessages(int messageCount)"
  nameWithType: "ServiceBusReceiverAsyncClient.deleteMessages(int messageCount)"
  summary: "Deletes up to `messageCount` messages from the entity enqueued before <xref uid=\"java.time.OffsetDateTime.now*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"OffsetDateTime#now()\"></xref>."
  parameters:
  - description: "the desired number of messages to delete."
    name: "messageCount"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Integer> deleteMessages(int messageCount)"
  desc: "Deletes up to `messageCount` messages from the entity enqueued before <xref uid=\"java.time.OffsetDateTime.now*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"OffsetDateTime#now()\"></xref>. The actual number of deleted messages may be less if there are fewer eligible messages in the entity.\n\nIf the lock for a message is held by a receiver, it will be respected and the message will not be deleted."
  returns:
    description: "a <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> indicating the number of messages deleted."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html\">Integer</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deleteMessages(int,com.azure.messaging.servicebus.models.DeleteMessagesOptions)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deleteMessages(int messageCount, DeleteMessagesOptions options)"
  name: "deleteMessages(int messageCount, DeleteMessagesOptions options)"
  nameWithType: "ServiceBusReceiverAsyncClient.deleteMessages(int messageCount, DeleteMessagesOptions options)"
  summary: "Deletes up to `messageCount` messages from the entity."
  parameters:
  - description: "the desired number of messages to delete."
    name: "messageCount"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  - description: "options used to delete the messages."
    name: "options"
    type: "<xref href=\"com.azure.messaging.servicebus.models.DeleteMessagesOptions?alt=com.azure.messaging.servicebus.models.DeleteMessagesOptions&text=DeleteMessagesOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Integer> deleteMessages(int messageCount, DeleteMessagesOptions options)"
  desc: "Deletes up to `messageCount` messages from the entity. The actual number of deleted messages may be less if there are fewer eligible messages in the entity.\n\nIf the lock for a message is held by a receiver, it will be respected and the message will not be deleted."
  returns:
    description: "a <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> indicating the number of messages deleted."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html\">Integer</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getEntityPath()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getEntityPath()"
  name: "getEntityPath()"
  nameWithType: "ServiceBusReceiverAsyncClient.getEntityPath()"
  summary: "Gets the Service Bus resource this client interacts with."
  syntax: "public String getEntityPath()"
  desc: "Gets the Service Bus resource this client interacts with."
  returns:
    description: "The Service Bus resource this client interacts with."
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace()"
  name: "getFullyQualifiedNamespace()"
  nameWithType: "ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace()"
  summary: "Gets the fully qualified Service Bus namespace that the connection is associated with."
  syntax: "public String getFullyQualifiedNamespace()"
  desc: "Gets the fully qualified Service Bus namespace that the connection is associated with. This is likely similar to `{yournamespace}.servicebus.windows.net`."
  returns:
    description: "The fully qualified Service Bus namespace that the connection is associated with."
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getIdentifier()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getIdentifier()"
  name: "getIdentifier()"
  nameWithType: "ServiceBusReceiverAsyncClient.getIdentifier()"
  summary: "Gets the identifier of the instance of <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiverAsyncClient\"></xref>."
  syntax: "public String getIdentifier()"
  desc: "Gets the identifier of the instance of <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiverAsyncClient\"></xref>."
  returns:
    description: "The identifier that can identify the instance of <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiverAsyncClient\"></xref>."
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getSessionId()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getSessionId()"
  name: "getSessionId()"
  nameWithType: "ServiceBusReceiverAsyncClient.getSessionId()"
  summary: "Gets the Session<wbr>Id of the session if this receiver is a session receiver."
  syntax: "public String getSessionId()"
  desc: "Gets the SessionId of the session if this receiver is a session receiver."
  returns:
    description: "The SessionId or null if this is not a session receiver."
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getSessionState()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getSessionState()"
  name: "getSessionState()"
  nameWithType: "ServiceBusReceiverAsyncClient.getSessionState()"
  summary: "Gets the state of the session if this receiver is a session receiver."
  syntax: "public Mono<byte[]> getSessionState()"
  desc: "Gets the state of the session if this receiver is a session receiver."
  returns:
    description: "The session state or an empty Mono if there is no state set for the session."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessage()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessage()"
  name: "peekMessage()"
  nameWithType: "ServiceBusReceiverAsyncClient.peekMessage()"
  summary: "Reads the next active message without changing the state of the receiver or the message source."
  syntax: "public Mono<ServiceBusReceivedMessage> peekMessage()"
  desc: "Reads the next active message without changing the state of the receiver or the message source. The first call to `peek()` fetches the first active message for this receiver. Each subsequent call fetches the subsequent message in the entity."
  returns:
    description: "A peeked <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref>."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessage(long)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessage(long sequenceNumber)"
  name: "peekMessage(long sequenceNumber)"
  nameWithType: "ServiceBusReceiverAsyncClient.peekMessage(long sequenceNumber)"
  summary: "Starting from the given sequence number, reads next the active message without changing the state of the receiver or the message source."
  parameters:
  - description: "The sequence number from where to read the message."
    name: "sequenceNumber"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<ServiceBusReceivedMessage> peekMessage(long sequenceNumber)"
  desc: "Starting from the given sequence number, reads next the active message without changing the state of the receiver or the message source."
  returns:
    description: "A peeked <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref>."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessages(int)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessages(int maxMessages)"
  name: "peekMessages(int maxMessages)"
  nameWithType: "ServiceBusReceiverAsyncClient.peekMessages(int maxMessages)"
  summary: "Reads the next batch of active messages without changing the state of the receiver or the message source."
  parameters:
  - description: "The number of messages."
    name: "maxMessages"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Flux<ServiceBusReceivedMessage> peekMessages(int maxMessages)"
  desc: "Reads the next batch of active messages without changing the state of the receiver or the message source."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"messages\"></xref> that are peeked."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\">Flux</a>&lt;<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessages(int,long)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessages(int maxMessages, long sequenceNumber)"
  name: "peekMessages(int maxMessages, long sequenceNumber)"
  nameWithType: "ServiceBusReceiverAsyncClient.peekMessages(int maxMessages, long sequenceNumber)"
  summary: "Starting from the given sequence number, reads the next batch of active messages without changing the state of the receiver or the message source."
  parameters:
  - description: "The number of messages."
    name: "maxMessages"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  - description: "The sequence number from where to start reading messages."
    name: "sequenceNumber"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Flux<ServiceBusReceivedMessage> peekMessages(int maxMessages, long sequenceNumber)"
  desc: "Starting from the given sequence number, reads the next batch of active messages without changing the state of the receiver or the message source."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"messages\"></xref> peeked."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\">Flux</a>&lt;<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.purgeMessages(com.azure.messaging.servicebus.models.PurgeMessagesOptions)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.purgeMessages(PurgeMessagesOptions options)"
  name: "purgeMessages(PurgeMessagesOptions options)"
  nameWithType: "ServiceBusReceiverAsyncClient.purgeMessages(PurgeMessagesOptions options)"
  summary: "Attempts to purge all messages from an entity."
  parameters:
  - description: "options used to purge the messages."
    name: "options"
    type: "<xref href=\"com.azure.messaging.servicebus.models.PurgeMessagesOptions?alt=com.azure.messaging.servicebus.models.PurgeMessagesOptions&text=PurgeMessagesOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Integer> purgeMessages(PurgeMessagesOptions options)"
  desc: "Attempts to purge all messages from an entity. Locked messages are not eligible for removal and will remain in the entity.\n\nIf the lock for a message is held by a receiver, it will be respected and the message will not be deleted.\n\nThis method may invoke multiple service requests to delete all messages. Because multiple service requests may be made, the possibility of partial success exists. In this scenario, the method will stop attempting to delete additional messages and throw the exception that was encountered."
  returns:
    description: "a <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> indicating the number of messages deleted."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html\">Integer</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessage(long)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessage(long sequenceNumber)"
  name: "receiveDeferredMessage(long sequenceNumber)"
  nameWithType: "ServiceBusReceiverAsyncClient.receiveDeferredMessage(long sequenceNumber)"
  summary: "Receives a deferred <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref>."
  parameters:
  - description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage.getSequenceNumber()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"sequence number\"></xref> of the\n     message."
    name: "sequenceNumber"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<ServiceBusReceivedMessage> receiveDeferredMessage(long sequenceNumber)"
  desc: "Receives a deferred <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref>. Deferred messages can only be received by using sequence number."
  returns:
    description: "A deferred message with the matching <code>sequenceNumber</code>."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessages(java.lang.Iterable<java.lang.Long>)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessages(Iterable<Long> sequenceNumbers)"
  name: "receiveDeferredMessages(Iterable<Long> sequenceNumbers)"
  nameWithType: "ServiceBusReceiverAsyncClient.receiveDeferredMessages(Iterable<Long> sequenceNumbers)"
  summary: "Receives a batch of deferred <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"messages\"></xref>."
  parameters:
  - description: "The sequence numbers of the deferred messages."
    name: "sequenceNumbers"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html\">Iterable</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html\">Long</a>&gt;"
  syntax: "public Flux<ServiceBusReceivedMessage> receiveDeferredMessages(Iterable<Long> sequenceNumbers)"
  desc: "Receives a batch of deferred <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"messages\"></xref>. Deferred messages can only be received by using sequence number."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of deferred <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"messages\"></xref>."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\">Flux</a>&lt;<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveMessages()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveMessages()"
  name: "receiveMessages()"
  nameWithType: "ServiceBusReceiverAsyncClient.receiveMessages()"
  summary: "Receives an **infinite** stream of <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"messages\"></xref> from the Service Bus entity."
  syntax: "public Flux<ServiceBusReceivedMessage> receiveMessages()"
  desc: "Receives an **infinite** stream of <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"messages\"></xref> from the Service Bus entity. This Flux continuously receives messages from a Service Bus entity until either:\n\n *  The receiver is closed.\n *  The subscription to the Flux is disposed.\n *  A terminal signal from a downstream subscriber is propagated upstream (ie. <xref uid=\"reactor.core.publisher.Flux.take*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux#take(long)\"></xref> or <xref uid=\"reactor.core.publisher.Flux.take*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux#take(Duration)\"></xref>).\n *  An <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AmqpException\"></xref> occurs that causes the receive link to stop.\n\nThe client uses an AMQP link underneath to receive the messages; the client will transparently transition to a new AMQP link if the current one encounters a retriable error. When the client experiences a non-retriable error or exhausts the retries, the Subscriber's <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"org.reactivestreams.Subscriber#onError(Throwable)\"></xref> terminal handler will be notified with this error. No further messages will be delivered to <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"org.reactivestreams.Subscriber#onNext(Object)\"></xref> after the terminal event; the application must create a new client to resume the receive. Re-subscribing to the Flux of the old client will have no effect.\n\nNote: A few examples of non-retriable errors are - the application attempting to connect to a queue that does not exist, deleting or disabling the queue in the middle of receiving, the user explicitly initiating Geo-DR. These are certain events where the Service Bus communicates to the client that a non-retriable error occurred."
  returns:
    description: "An <b>infinite</b> stream of messages from the Service Bus entity."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\">Flux</a>&lt;<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(ServiceBusReceivedMessage message)"
  name: "renewMessageLock(ServiceBusReceivedMessage message)"
  nameWithType: "ServiceBusReceiverAsyncClient.renewMessageLock(ServiceBusReceivedMessage message)"
  summary: "Asynchronously renews the lock on the message."
  parameters:
  - description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref> to perform auto-lock renewal."
    name: "message"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message)"
  desc: "Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified on the entity. When a message is received in <xref uid=\"com.azure.messaging.servicebus.models.ServiceBusReceiveMode.PEEK_LOCK\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiveMode#PEEK_LOCK\"></xref> mode, the message is locked on the server for this receiver instance for a duration as specified during the entity creation (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to the entity's LockDuration value."
  returns:
    description: "The new expiration time for the message."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/time/OffsetDateTime.html\">OffsetDateTime</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(com.azure.messaging.servicebus.ServiceBusReceivedMessage,java.time.Duration)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration)"
  name: "renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration)"
  nameWithType: "ServiceBusReceiverAsyncClient.renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration)"
  summary: "Starts the auto lock renewal for a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref>."
  parameters:
  - description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceivedMessage\"></xref> to perform this operation."
    name: "message"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage?alt=com.azure.messaging.servicebus.ServiceBusReceivedMessage&text=ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"False\" />"
  - description: "Maximum duration to keep renewing the lock token."
    name: "maxLockRenewalDuration"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html\">Duration</a>"
  syntax: "public Mono<Void> renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration)"
  desc: "Starts the auto lock renewal for a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"message\"></xref>."
  returns:
    description: "A Mono that completes when the message renewal operation has completed up until\n      <code>maxLockRenewalDuration</code>."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewSessionLock()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewSessionLock()"
  name: "renewSessionLock()"
  nameWithType: "ServiceBusReceiverAsyncClient.renewSessionLock()"
  summary: "Renews the session lock if this receiver is a session receiver."
  syntax: "public Mono<OffsetDateTime> renewSessionLock()"
  desc: "Renews the session lock if this receiver is a session receiver."
  returns:
    description: "The next expiration time for the session lock."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/time/OffsetDateTime.html\">OffsetDateTime</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewSessionLock(java.time.Duration)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewSessionLock(Duration maxLockRenewalDuration)"
  name: "renewSessionLock(Duration maxLockRenewalDuration)"
  nameWithType: "ServiceBusReceiverAsyncClient.renewSessionLock(Duration maxLockRenewalDuration)"
  summary: "Starts the auto lock renewal for the session this receiver works for."
  parameters:
  - description: "Maximum duration to keep renewing the session lock."
    name: "maxLockRenewalDuration"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html\">Duration</a>"
  syntax: "public Mono<Void> renewSessionLock(Duration maxLockRenewalDuration)"
  desc: "Starts the auto lock renewal for the session this receiver works for."
  returns:
    description: "A lock renewal operation for the message."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.rollbackTransaction(com.azure.messaging.servicebus.ServiceBusTransactionContext)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.rollbackTransaction(ServiceBusTransactionContext transactionContext)"
  name: "rollbackTransaction(ServiceBusTransactionContext transactionContext)"
  nameWithType: "ServiceBusReceiverAsyncClient.rollbackTransaction(ServiceBusTransactionContext transactionContext)"
  summary: "Rollbacks the transaction given and all operations associated with it."
  parameters:
  - description: "The transaction to rollback."
    name: "transactionContext"
    type: "<xref href=\"com.azure.messaging.servicebus.ServiceBusTransactionContext?alt=com.azure.messaging.servicebus.ServiceBusTransactionContext&text=ServiceBusTransactionContext\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> rollbackTransaction(ServiceBusTransactionContext transactionContext)"
  desc: "Rollbacks the transaction given and all operations associated with it.\n\n**Creating and using a transaction**\n\n```java\n// This mono creates a transaction and caches the output value, so we can associate operations with the\n // transaction. It does not cache the value if it is an error or completes with no items, effectively retrying\n // the operation.\n Mono<ServiceBusTransactionContext> transactionContext = asyncReceiver.createTransaction()\n     .cache(value -> Duration.ofMillis(Long.MAX_VALUE),\n         error -> Duration.ZERO,\n         () -> Duration.ZERO);\n\n // Dispose of the disposable to cancel the operation.\n Disposable disposable = transactionContext.flatMap(transaction -> {\n     // Process messages and associate operations with the transaction.\n     Mono<Void> operations = Mono.when(\n         asyncReceiver.receiveDeferredMessage(sequenceNumber).flatMap(message ->\n             asyncReceiver.complete(message, new CompleteOptions().setTransactionContext(transaction))),\n         asyncReceiver.abandon(receivedMessage, new AbandonOptions().setTransactionContext(transaction)));\n\n     // Finally, either commit or rollback the transaction once all the operations are associated with it.\n     return operations.then(asyncReceiver.commitTransaction(transaction));\n }).subscribe(unused -> {\n }, error -> {\n     System.err.println(\"Error occurred processing transaction: \" + error);\n }, () -> {\n     System.out.println(\"Completed transaction\");\n });\n```"
  returns:
    description: "The <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that finishes this operation on service bus resource."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.setSessionState(byte[])"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.setSessionState(byte[] sessionState)"
  name: "setSessionState(byte[] sessionState)"
  nameWithType: "ServiceBusReceiverAsyncClient.setSessionState(byte[] sessionState)"
  summary: "Sets the state of the session this receiver works for."
  parameters:
  - description: "State to set on the session."
    name: "sessionState"
    type: "<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]"
  syntax: "public Mono<Void> setSessionState(byte[] sessionState)"
  desc: "Sets the state of the session this receiver works for."
  returns:
    description: "A Mono that completes when the session is set"
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html\">Void</a>&gt;"
type: "class"
desc: "An **asynchronous** receiver responsible for receiving <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\" data-raw-source=\"messages\"></xref> from an Azure Service Bus queue or topic/subscription.\n\nThe examples shown in this document use a credential object named DefaultAzureCredential for authentication, which is appropriate for most scenarios, including local development and production environments. Additionally, we recommend using [managed identity][] for authentication in production environments. You can find more information on different ways of authenticating and their corresponding credential types in the [Azure Identity documentation\"][Azure Identity documentation].\n\n**Sample: Creating a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiverAsyncClient\"></xref>**\n\nThe following code sample demonstrates the creation of the asynchronous client <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiverAsyncClient\"></xref>. The `fullyQualifiedNamespace` is the Service Bus namespace's host name. It is listed under the \"Essentials\" panel after navigating to the Event Hubs Namespace via Azure Portal. The credential used is `DefaultAzureCredential` because it combines commonly used credentials in deployment and development and chooses the credential to used based on its running environment. <xref uid=\"com.azure.messaging.servicebus.models.ServiceBusReceiveMode.PEEK_LOCK\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiveMode#PEEK_LOCK\"></xref> (the default receive mode) and <xref uid=\"com.azure.messaging.servicebus.ServiceBusClientBuilder.ServiceBusReceiverClientBuilder.disableAutoComplete()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"disableAutoComplete()\"></xref> are **strongly** recommended so users have control over message settlement.\n\n```java\nTokenCredential credential = new DefaultAzureCredentialBuilder().build();\n\n // 'fullyQualifiedNamespace' will look similar to \"{your-namespace}.servicebus.windows.net\"\n // 'disableAutoComplete' indicates that users will explicitly settle their message.\n ServiceBusReceiverAsyncClient asyncReceiver = new ServiceBusClientBuilder()\n     .credential(fullyQualifiedNamespace, credential)\n     .receiver()\n     .disableAutoComplete()\n     .queueName(queueName)\n     .buildAsyncClient();\n\n // When users are done with the receiver, dispose of the receiver.\n // Clients should be long-lived objects as they require resources\n // and time to establish a connection to the service.\n asyncReceiver.close();\n```\n\n**Sample: Receive all messages from Service Bus resource**\n\nThis returns an infinite stream of messages from Service Bus. The stream ends when the subscription is disposed or other terminal scenarios. See <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveMessages()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#receiveMessages()\"></xref> for more information.\n\n```java\n// Keep a reference to `subscription`. When the program is finished receiving messages, call\n // subscription.dispose(). This will stop fetching messages from the Service Bus.\n // Consider using Flux.usingWhen to scope the creation, usage, and cleanup of the receiver.\n Disposable subscription = asyncReceiver.receiveMessages()\n     .flatMap(message -> {\n         System.out.printf(\"Received Seq #: %s%n\", message.getSequenceNumber());\n         System.out.printf(\"Contents of message as string: %s%n\", message.getBody());\n\n         // Explicitly settle the message using complete, abandon, defer, dead-letter, etc.\n         if (isMessageProcessed) {\n             return asyncReceiver.complete(message);\n         } else {\n             return asyncReceiver.abandon(message);\n         }\n     })\n     .subscribe(unused -> {\n     }, error -> System.out.println(\"Error occurred: \" + error),\n         () -> System.out.println(\"Receiving complete.\"));\n\n // When program ends, or you're done receiving all messages, dispose of the receiver.\n // Clients should be long-lived objects as they\n // require resources and time to establish a connection to the service.\n asyncReceiver.close();\n```\n\n**Sample: Receive messages in <xref uid=\"com.azure.messaging.servicebus.models.ServiceBusReceiveMode.RECEIVE_AND_DELETE\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiveMode#RECEIVE_AND_DELETE\"></xref> mode from a Service Bus entity**\n\nThe following code sample demonstrates the creation of the asynchronous client <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiverAsyncClient\"></xref> using <xref uid=\"com.azure.messaging.servicebus.models.ServiceBusReceiveMode.RECEIVE_AND_DELETE\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiveMode#RECEIVE_AND_DELETE\"></xref>. The `fullyQualifiedNamespace` is the Service Bus namespace's host name. It is listed under the \"Essentials\" panel after navigating to the Event Hubs Namespace via Azure Portal. The credential used is `DefaultAzureCredential` because it combines commonly used credentials in deployment and development and chooses the credential to used based on its running environment. See <xref uid=\"com.azure.messaging.servicebus.models.ServiceBusReceiveMode.RECEIVE_AND_DELETE\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiveMode#RECEIVE_AND_DELETE\"></xref> docs for more information about receiving messages using this mode.\n\n```java\nTokenCredential credential = new DefaultAzureCredentialBuilder().build();\n\n // Keep a reference to `subscription`. When the program is finished receiving messages, call\n // subscription.dispose(). This will stop fetching messages from the Service Bus.\n Disposable subscription = Flux.usingWhen(\n         Mono.fromCallable(() -> {\n             // Setting the receiveMode when creating the receiver enables receive and delete mode. By default,\n             // peek lock mode is used. In peek lock mode, users are responsible for settling messages.\n             return new ServiceBusClientBuilder()\n                 .credential(fullyQualifiedNamespace, credential)\n                 .receiver()\n                 .receiveMode(ServiceBusReceiveMode.RECEIVE_AND_DELETE)\n                 .queueName(queueName)\n                 .buildAsyncClient();\n         }), receiver -> {\n             return receiver.receiveMessages();\n         }, receiver -> {\n             return Mono.fromRunnable(() -> receiver.close());\n         })\n     .subscribe(message -> {\n             // Messages received in RECEIVE_AND_DELETE mode do not have to be settled because they are automatically\n             // removed from the queue.\n         System.out.printf(\"Received Seq #: %s%n\", message.getSequenceNumber());\n         System.out.printf(\"Contents of message as string: %s%n\", message.getBody());\n     },\n         error -> System.out.println(\"Error occurred: \" + error),\n         () -> System.out.println(\"Receiving complete.\"));\n```\n\n**Sample: Receive messages from a specific session**\n\nTo fetch messages from a specific session, switch to <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusSessionReceiverClientBuilder\"></xref> and build the session receiver client. Use <xref uid=\"com.azure.messaging.servicebus.ServiceBusSessionReceiverAsyncClient.acceptSession(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusSessionReceiverAsyncClient#acceptSession(String)\"></xref> to create a session-bound <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusReceiverAsyncClient\"></xref>. The sample assumes that Service Bus sessions were [enabled at the time of the queue creation][].\n\n```java\nTokenCredential credential = new DefaultAzureCredentialBuilder().build();\n\n // 'fullyQualifiedNamespace' will look similar to \"{your-namespace}.servicebus.windows.net\"\n // 'disableAutoComplete' indicates that users will explicitly settle their message.\n ServiceBusSessionReceiverAsyncClient sessionReceiver = new ServiceBusClientBuilder()\n     .credential(fullyQualifiedNamespace, credential)\n     .sessionReceiver()\n     .disableAutoComplete()\n     .queueName(sessionEnabledQueueName)\n     .buildAsyncClient();\n\n // acceptSession(String) completes successfully with a receiver when \"<<my-session-id>>\" session is\n // successfully locked.\n // `Flux.usingWhen` is used, so we dispose of the receiver resource after `receiveMessages()` and the settlement\n // operations complete.\n // `Mono.usingWhen` can also be used if the resource closure returns a single item.\n Flux<Void> sessionMessages = Flux.usingWhen(\n     sessionReceiver.acceptSession(\"<<my-session-id>>\"),\n     receiver -> {\n         // Receive messages from <<my-session-id>> session.\n         return receiver.receiveMessages().flatMap(message -> {\n             System.out.printf(\"Received Sequence #: %s. Contents: %s%n\", message.getSequenceNumber(),\n                 message.getBody());\n\n             // Explicitly settle the message using complete, abandon, defer, dead-letter, etc.\n             if (isMessageProcessed) {\n                 return receiver.complete(message);\n             } else {\n                 return receiver.abandon(message);\n             }\n         });\n     },\n     receiver -> Mono.fromRunnable(() -> {\n         // Dispose of resources.\n         receiver.close();\n         sessionReceiver.close();\n     }));\n\n // When program ends, or you're done receiving all messages, the `subscription` can be disposed of. This code\n // is non-blocking and kicks off the operation.\n Disposable subscription = sessionMessages.subscribe(\n     unused -> {\n     }, error -> System.err.print(\"Error receiving message from session: \" + error),\n     () -> System.out.println(\"Completed receiving from session.\"));\n```\n\n**Sample: Receive messages from the first available session**\n\nTo process messages from the first available session, switch to <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ServiceBusSessionReceiverClientBuilder\"></xref> and build the session receiver client. Use <xref uid=\"com.azure.messaging.servicebus.ServiceBusSessionReceiverAsyncClient.acceptNextSession()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"acceptNextSession()\"></xref> to find the first available session to process messages from.\n\n```java\nTokenCredential credential = new DefaultAzureCredentialBuilder().build();\n\n // 'fullyQualifiedNamespace' will look similar to \"{your-namespace}.servicebus.windows.net\"\n // 'disableAutoComplete' indicates that users will explicitly settle their message.\n ServiceBusSessionReceiverAsyncClient sessionReceiver = new ServiceBusClientBuilder()\n     .credential(fullyQualifiedNamespace, credential)\n     .sessionReceiver()\n     .disableAutoComplete()\n     .queueName(sessionEnabledQueueName)\n     .buildAsyncClient();\n\n // Creates a client to receive messages from the first available session. It waits until\n // AmqpRetryOptions.getTryTimeout() elapses. If no session is available within that operation timeout, it\n // completes with a retriable error. Otherwise, a receiver is returned when a lock on the session is acquired.\n Mono<ServiceBusReceiverAsyncClient> receiverMono = sessionReceiver.acceptNextSession();\n\n Flux<Void> receiveMessagesFlux = Flux.usingWhen(receiverMono,\n     receiver -> receiver.receiveMessages().flatMap(message -> {\n         System.out.println(\"Received message: \" + message.getBody());\n\n         // Explicitly settle the message via complete, abandon, defer, dead-letter, etc.\n         if (isMessageProcessed) {\n             return receiver.complete(message);\n         } else {\n             return receiver.abandon(message);\n         }\n     }),\n     receiver -> Mono.fromRunnable(() -> {\n         // Dispose of the receiver and sessionReceiver when done receiving messages.\n         receiver.close();\n         sessionReceiver.close();\n     }));\n\n // This is a non-blocking call that moves onto the next line of code after setting up and starting the receive\n // operation. Customers can keep a reference to `subscription` and dispose of it when they want to stop\n // receiving messages.\n Disposable subscription = receiveMessagesFlux.subscribe(unused -> {\n }, error -> System.out.println(\"Error occurred: \" + error),\n     () -> System.out.println(\"Receiving complete.\"));\n```\n\n**Sample: Rate limiting consumption of messages from a Service Bus entity**\n\nFor message receivers that need to limit the number of messages they receive at a given time, they can use <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BaseSubscriber#request(long)\"></xref>.\n\n```java\n// This is a non-blocking call. The program will move to the next line of code after setting up the operation.\n asyncReceiver.receiveMessages().subscribe(new BaseSubscriber<ServiceBusReceivedMessage>() {\n     private static final int NUMBER_OF_MESSAGES = 5;\n     private final AtomicInteger currentNumberOfMessages = new AtomicInteger();\n\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n         // Tell the Publisher we only want 5 message at a time.\n         request(NUMBER_OF_MESSAGES);\n     }\n\n     @Override\n     protected void hookOnNext(ServiceBusReceivedMessage message) {\n         // Process the ServiceBusReceivedMessage\n         // If the number of messages we have currently received is a multiple of 5, that means we have reached\n         // the last message the Subscriber will provide to us. Invoking request(long) here, tells the Publisher\n         // that the subscriber is ready to get more messages from upstream.\n         if (currentNumberOfMessages.incrementAndGet() % 5 == 0) {\n             request(NUMBER_OF_MESSAGES);\n         }\n     }\n });\n```\n\n\n[managed identity]: https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/\n[Azure Identity documentation]: https://learn.microsoft.com/java/api/overview/azure/identity-readme\n[enabled at the time of the queue creation]: https://learn.microsoft.com/azure/service-bus-messaging/enable-message-sessions"
implements:
- "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html\">AutoCloseable</a>"
metadata: {}
package: "com.azure.messaging.servicebus"
artifact: com.azure:azure-messaging-servicebus:7.18.0-beta.1
