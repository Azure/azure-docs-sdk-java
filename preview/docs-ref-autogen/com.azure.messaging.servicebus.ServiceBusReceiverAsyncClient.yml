### YamlMime:JavaType
uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
name: "ServiceBusReceiverAsyncClient"
nameWithType: "ServiceBusReceiverAsyncClient"
summary: "An **asynchronous** receiver responsible for receiving <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">ServiceBusReceivedMessage</xref> from a specific queue or topic on Azure Service Bus.\n\n**Create an instance of receiver**\n\n```java\n// The required parameters is connectionString, a way to authenticate with Service Bus using credentials.\n ServiceBusReceiverAsyncClient consumer = new ServiceBusClientBuilder()\n     .connectionString(\"Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};\"\n         + \"SharedAccessKey={key};EntityPath={eh-name}\")\n     .receiver()\n     .queueName(\"<< QUEUE NAME >>\")\n     .buildAsyncClient();\n```\n\n**Create an instance of receiver using default credential**\n\n```java\n// The required parameters is connectionString, a way to authenticate with Service Bus using credentials.\n ServiceBusReceiverAsyncClient receiver = new ServiceBusClientBuilder()\n     .credential(\"<<fully-qualified-namespace>>\",\n         new DefaultAzureCredentialBuilder().build())\n     .receiver()\n     .queueName(\"<< QUEUE NAME >>\")\n     .buildAsyncClient();\n```\n\n**Receive all messages from Service Bus resource**\n\nThis returns an infinite stream of messages from Service Bus. The stream ends when the subscription is disposed or other terminal scenarios. See <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveMessages()\" data-throw-if-not-resolved=\"false\">#receiveMessages()</xref> for more information.\n\n```java\nDisposable subscription = receiver.receiveMessages().flatMap(context -> {\n     ServiceBusReceivedMessage message = context.getMessage();\n     System.out.printf(\"Received message id: %s%n\", message.getMessageId());\n     System.out.printf(\"Contents of message as string: %s%n\", new String(message.getBody(), UTF_8));\n     return receiver.complete(message);\n }).subscribe(aVoid -> System.out.println(\"Processed message.\"),\n     error -> System.out.println(\"Error occurred: \" + error));\n \n // When program ends, or you're done receiving all messages.\n subscription.dispose();\n receiver.close();\n```\n\n**Receive messages in <xref uid=\"com.azure.messaging.servicebus.models.ReceiveMode.RECEIVE_AND_DELETE\" data-throw-if-not-resolved=\"false\">ReceiveMode#RECEIVE_AND_DELETE</xref> mode from Service Bus resource**\n\n```java\n// Keep a reference to `subscription`. When the program is finished receiving messages, call\n // subscription.dispose(). This will stop fetching messages from the Service Bus.\n Disposable subscription = receiver.receiveMessages()\n     .subscribe(context -> {\n         ServiceBusReceivedMessage message = context.getMessage();\n         System.out.printf(\"Received message id: %s%n\", message.getMessageId());\n         System.out.printf(\"Contents of message as string: %s%n\", new String(message.getBody(), UTF_8));\n     }, error -> System.err.print(error));\n```\n\n**Receive messages from a specific session**\n\nTo fetch messages from a specific session, set <xref uid=\"\" data-throw-if-not-resolved=\"false\">ServiceBusSessionReceiverClientBuilder#sessionId(String)</xref>.\n\n```java\nServiceBusReceiverAsyncClient consumer = new ServiceBusClientBuilder()\n     .connectionString(\"Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};\"\n         + \"SharedAccessKey={key};EntityPath={eh-name}\")\n     .sessionReceiver()\n     .topicName(\"<< TOPIC NAME >>\")\n     .subscriptionName(\"<< SUBSCRIPTION NAME >>\")\n     .sessionId(\"<< my-session-id >>\")\n     .buildAsyncClient();\n```\n\n**Process messages from multiple sessions**\n\nTo process messages from multiple sessions, set <xref uid=\"\" data-throw-if-not-resolved=\"false\">ServiceBusSessionReceiverClientBuilder#maxConcurrentSessions(int)</xref>. This will process in parallel at most `maxConcurrentSessions`. In addition, when all the messages in a session have been consumed, it will find the next available session to process.\n\n```java\nServiceBusReceiverAsyncClient consumer = new ServiceBusClientBuilder()\n     .connectionString(\"Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};\"\n         + \"SharedAccessKey={key};EntityPath={eh-name}\")\n     .sessionReceiver()\n     .topicName(\"<< TOPIC NAME >>\")\n     .subscriptionName(\"<< SUBSCRIPTION NAME >>\")\n     .maxConcurrentSessions(3)\n     .buildAsyncClient();\n```\n\n**Process messages from the first available session**\n\nTo process messages from the first available session, switch to <xref uid=\"\" data-throw-if-not-resolved=\"false\">ServiceBusSessionReceiverClientBuilder</xref> and build the receiver client. It will find the first available session to process messages from.\n\n```java\nServiceBusReceiverAsyncClient receiver = new ServiceBusClientBuilder()\n     .connectionString(\"Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};\"\n         + \"SharedAccessKey={key};EntityPath={eh-name}\")\n     .sessionReceiver()\n     .queueName(\"<< QUEUE NAME >>\")\n     .buildAsyncClient();\n```\n\n**Rate limiting consumption of messages from Service Bus resource**\n\nFor message receivers that need to limit the number of messages they receive at a given time, they can use <xref uid=\"\" data-throw-if-not-resolved=\"false\">BaseSubscriber#request(long)</xref>.\n\n```java\nreceiver.receiveMessages().subscribe(new BaseSubscriber<ServiceBusReceivedMessageContext>() {\n     private static final int NUMBER_OF_MESSAGES = 5;\n     private final AtomicInteger currentNumberOfMessages = new AtomicInteger();\n \n     {@literal @}Override\n     protected void hookOnSubscribe(Subscription subscription) {\n         // Tell the Publisher we only want 5 message at a time.\n         request(NUMBER_OF_MESSAGES);\n     }\n \n     {@literal @}Override\n     protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n         // Process the ServiceBusReceivedMessage\n         ServiceBusReceivedMessage message = value.getMessage();\n \n         // If the number of messages we have currently received is a multiple of 5, that means we have reached\n         // the last message the Subscriber will provide to us. Invoking request(long) here, tells the Publisher\n         // that the subscriber is ready to get more messages from upstream.\n         if (currentNumberOfMessages.incrementAndGet() % 5 == 0) {\n             request(NUMBER_OF_MESSAGES);\n         }\n     }\n });\n```"
inheritances:
- "<xref href=\"java.lang.Object\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
syntax: "public final class ServiceBusReceiverAsyncClient implements AutoCloseable"
methods:
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.ServiceBusReceivedMessage,java.util.Map<java.lang.String,java.lang.Object>)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.ServiceBusReceivedMessage,java.util.Map<java.lang.String,java.lang.Object>,com.azure.messaging.servicebus.ServiceBusTransactionContext)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.close()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.commitTransaction(com.azure.messaging.servicebus.ServiceBusTransactionContext)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.ServiceBusTransactionContext)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.createTransaction()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.ServiceBusTransactionContext)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.administration.models.DeadLetterOptions)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.ServiceBusReceivedMessage,com.azure.messaging.servicebus.administration.models.DeadLetterOptions,com.azure.messaging.servicebus.ServiceBusTransactionContext)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(com.azure.messaging.servicebus.ServiceBusReceivedMessage,java.util.Map<java.lang.String,java.lang.Object>)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(com.azure.messaging.servicebus.ServiceBusReceivedMessage,java.util.Map<java.lang.String,java.lang.Object>,com.azure.messaging.servicebus.ServiceBusTransactionContext)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getEntityPath()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getSessionState(java.lang.String)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessage()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessage(java.lang.String)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessageAt(long)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessageAt(long,java.lang.String)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessages(int)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessages(int,java.lang.String)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessagesAt(int,long)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekMessagesAt(int,long,java.lang.String)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessage(long)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessage(long,java.lang.String)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessages(java.lang.Iterable<java.lang.Long>)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessages(java.lang.Iterable<java.lang.Long>,java.lang.String)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveMessages()"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(com.azure.messaging.servicebus.ServiceBusReceivedMessage)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(com.azure.messaging.servicebus.ServiceBusReceivedMessage,java.time.Duration)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewSessionLock(java.lang.String)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewSessionLock(java.lang.String,java.time.Duration)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.rollbackTransaction(com.azure.messaging.servicebus.ServiceBusTransactionContext)"
- "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.setSessionState(java.lang.String,byte[])"
type: "class"
implements:
- "<xref href=\"java.lang.AutoCloseable?alt=java.lang.AutoCloseable&text=AutoCloseable\" data-throw-if-not-resolved=\"False\" />"
metadata: {}
package: "com.azure.messaging.servicebus"
artifact: com.azure:azure-messaging-servicebus:7.0.0-beta.6
