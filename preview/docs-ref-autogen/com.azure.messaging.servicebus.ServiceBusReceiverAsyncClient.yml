### YamlMime:ManagedReference
items:
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  id: "ServiceBusReceiverAsyncClient"
  parent: "com.azure.messaging.servicebus"
  children:
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.ServiceBusReceiverAsyncClient(java.lang.String,java.lang.String,com.azure.messaging.servicebus.implementation.MessagingEntityType,boolean,com.azure.messaging.servicebus.ReceiverOptions,com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor,com.azure.core.amqp.implementation.TracerProvider,com.azure.core.amqp.implementation.MessageSerializer,com.azure.messaging.servicebus.implementation.MessageLockContainer,java.lang.Runnable)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.MessageLockToken)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.MessageLockToken,java.util.Map<java.lang.String,java.lang.Object>)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.close()"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(com.azure.messaging.servicebus.MessageLockToken)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.MessageLockToken)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.MessageLockToken,com.azure.messaging.servicebus.DeadLetterOptions)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(com.azure.messaging.servicebus.MessageLockToken)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(com.azure.messaging.servicebus.MessageLockToken,java.util.Map<java.lang.String,java.lang.Object>)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getEntityPath()"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace()"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peek()"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekAt(long)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatch(int)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatchAt(int,long)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receive()"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receive(com.azure.messaging.servicebus.models.ReceiveAsyncOptions)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessage(long)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessageBatch(long...)"
  - "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(com.azure.messaging.servicebus.MessageLockToken)"
  langs:
  - "java"
  name: "ServiceBusReceiverAsyncClient"
  nameWithType: "ServiceBusReceiverAsyncClient"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  type: "Class"
  package: "com.azure.messaging.servicebus"
  summary: "An **asynchronous** receiver responsible for receiving <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">ServiceBusReceivedMessage</xref> from a specific queue or topic on Azure Service Bus.\n\n**Create an instance of receiver**\n\n```java\n// The required parameters is connectionString, a way to authenticate with Service Bus using credentials.\n ServiceBusReceiverAsyncClient consumer = new ServiceBusClientBuilder()\n     .connectionString(\"Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};\"\n         + \"SharedAccessKey={key};EntityPath={eh-name}\")\n     .receiver()\n     .queueName(\"<< QUEUE NAME >>\")\n     .buildAsyncClient();\n```\n\n**Create an instance of sender using default credential**\n\n```java\n// The required parameters is connectionString, a way to authenticate with Service Bus using credentials.\n ServiceBusReceiverAsyncClient receiver = new ServiceBusClientBuilder()\n     .credential(\"<<fully-qualified-namespace>>\",\n         new DefaultAzureCredentialBuilder().build())\n     .receiver()\n     .queueName(\"<< QUEUE NAME >>\")\n     .buildAsyncClient();\n```\n\n**Receive all messages from Service Bus resource**\n\n```java\nDisposable subscription = receiver.receive().subscribe(receivedMessage -> {\n     String messageId = receivedMessage.getMessageId();\n \n     System.out.printf(\"Received message messageId %s%n\", messageId);\n     System.out.printf(\"Contents of message as string: %s%n\", new String(receivedMessage.getBody(), UTF_8));\n });\n \n // When program ends, or you're done receiving all messages.\n receiver.close();\n subscription.dispose();\n```\n\n**Receive messages in <xref uid=\"com.azure.messaging.servicebus.models.ReceiveMode.RECEIVE_AND_DELETE\" data-throw-if-not-resolved=\"false\">ReceiveMode#RECEIVE_AND_DELETE</xref> mode from Service Bus resource**\n\n```java\n// Keep a reference to `subscription`. When the program is finished receiving messages, call\n // subscription.dispose(). This will stop fetching messages from the Service Bus.\n Disposable subscription = receiver.receive()\n     .subscribe(receivedMessage -> {\n         String messageId = receivedMessage.getMessageId();\n \n         System.out.printf(\"Received message messageId %s%n\", messageId);\n         System.out.printf(\"Contents of message as string: %s%n\", new String(receivedMessage.getBody(), UTF_8));\n     }, error -> System.err.print(error.toString()));\n```\n\n**Rate limiting consumption of messages from Service Bus resource**\n\nFor message receivers that need to limit the number of messages they receive at a given time, they can use\n\n```java\nreceiver.receive().subscribe(new BaseSubscriber<ServiceBusReceivedMessage>() {\n     private static final int NUMBER_OF_MESSAGES = 5;\n     private final AtomicInteger currentNumberOfMessages = new AtomicInteger();\n \n     {@literal @}Override\n     protected void hookOnSubscribe(Subscription subscription) {\n         // Tell the Publisher we only want 5 message at a time.\n         request(NUMBER_OF_MESSAGES);\n     }\n \n     {@literal @}Override\n     protected void hookOnNext(ServiceBusReceivedMessage value) {\n         // Process the ServiceBusReceivedMessage\n \n         // If the number of messages we have currently received is a multiple of 5, that means we have reached\n         // the last message the Subscriber will provide to us. Invoking request(long) here, tells the Publisher\n         // that the subscriber is ready to get more messages from upstream.\n         if (currentNumberOfMessages.incrementAndGet() % 5 == 0) {\n             request(NUMBER_OF_MESSAGES);\n         }\n     }\n });\n```"
  syntax:
    content: "public final class ServiceBusReceiverAsyncClient implements AutoCloseable"
  inheritance:
  - "java.lang.Object"
  implements:
  - "java.lang.AutoCloseable"
  inheritedMembers:
  - "java.lang.Object.clone()"
  - "java.lang.Object.equals(java.lang.Object)"
  - "java.lang.Object.finalize()"
  - "java.lang.Object.getClass()"
  - "java.lang.Object.hashCode()"
  - "java.lang.Object.notify()"
  - "java.lang.Object.notifyAll()"
  - "java.lang.Object.toString()"
  - "java.lang.Object.wait()"
  - "java.lang.Object.wait(long)"
  - "java.lang.Object.wait(long,int)"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.ServiceBusReceiverAsyncClient(java.lang.String,java.lang.String,com.azure.messaging.servicebus.implementation.MessagingEntityType,boolean,com.azure.messaging.servicebus.ReceiverOptions,com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor,com.azure.core.amqp.implementation.TracerProvider,com.azure.core.amqp.implementation.MessageSerializer,com.azure.messaging.servicebus.implementation.MessageLockContainer,java.lang.Runnable)"
  id: "ServiceBusReceiverAsyncClient(java.lang.String,java.lang.String,com.azure.messaging.servicebus.implementation.MessagingEntityType,boolean,com.azure.messaging.servicebus.ReceiverOptions,com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor,com.azure.core.amqp.implementation.TracerProvider,com.azure.core.amqp.implementation.MessageSerializer,com.azure.messaging.servicebus.implementation.MessageLockContainer,java.lang.Runnable)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "ServiceBusReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath, MessagingEntityType entityType, boolean isSessionEnabled, ReceiverOptions receiverOptions, ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider, MessageSerializer messageSerializer, MessageLockContainer messageLockContainer, Runnable onClientClose)"
  nameWithType: "ServiceBusReceiverAsyncClient.ServiceBusReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath, MessagingEntityType entityType, boolean isSessionEnabled, ReceiverOptions receiverOptions, ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider, MessageSerializer messageSerializer, MessageLockContainer messageLockContainer, Runnable onClientClose)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.ServiceBusReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath, MessagingEntityType entityType, boolean isSessionEnabled, ReceiverOptions receiverOptions, ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider, MessageSerializer messageSerializer, MessageLockContainer messageLockContainer, Runnable onClientClose)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.ServiceBusReceiverAsyncClient*"
  type: "Constructor"
  package: "com.azure.messaging.servicebus"
  summary: "Creates a receiver that listens to a Service Bus resource."
  syntax:
    content: " ServiceBusReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath, MessagingEntityType entityType, boolean isSessionEnabled, ReceiverOptions receiverOptions, ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider, MessageSerializer messageSerializer, MessageLockContainer messageLockContainer, Runnable onClientClose)"
    parameters:
    - id: "fullyQualifiedNamespace"
      type: "java.lang.String"
      description: "The fully qualified domain name for the Service Bus resource."
    - id: "entityPath"
      type: "java.lang.String"
      description: "The name of the topic or queue."
    - id: "entityType"
      type: "com.azure.messaging.servicebus.implementation.MessagingEntityType"
      description: "The type of the Service Bus resource."
    - id: "isSessionEnabled"
      type: "boolean"
      description: "<code>true</code> if sessions are enabled; <code>false</code> otherwise."
    - id: "receiverOptions"
      type: "com.azure.messaging.servicebus.ReceiverOptions"
      description: "Options when receiving messages."
    - id: "connectionProcessor"
      type: "com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor"
      description: "The AMQP connection to the Service Bus resource."
    - id: "tracerProvider"
      type: "com.azure.core.amqp.implementation.TracerProvider"
      description: "Tracer for telemetry."
    - id: "messageSerializer"
      type: "com.azure.core.amqp.implementation.MessageSerializer"
      description: "Serializes and deserializes Service Bus messages."
    - id: "messageLockContainer"
      type: "com.azure.messaging.servicebus.implementation.MessageLockContainer"
      description: "Container for message locks."
    - id: "onClientClose"
      type: "java.lang.Runnable"
      description: "Operation to run when the client completes."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.MessageLockToken)"
  id: "abandon(com.azure.messaging.servicebus.MessageLockToken)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "abandon(MessageLockToken lockToken)"
  nameWithType: "ServiceBusReceiverAsyncClient.abandon(MessageLockToken lockToken)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(MessageLockToken lockToken)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Abandon a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">message</xref> with its lock token. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message."
  syntax:
    content: "public Mono<Void> abandon(MessageLockToken lockToken)"
    parameters:
    - id: "lockToken"
      type: "com.azure.messaging.servicebus.MessageLockToken"
      description: "Lock token of the message."
    return:
      type: "reactor.core.publisher.Mono<java.lang.Void>"
      description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\">Mono</xref> that completes when the Service Bus operation finishes."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.MessageLockToken,java.util.Map<java.lang.String,java.lang.Object>)"
  id: "abandon(com.azure.messaging.servicebus.MessageLockToken,java.util.Map<java.lang.String,java.lang.Object>)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "abandon(MessageLockToken lockToken, Map<String,Object> propertiesToModify)"
  nameWithType: "ServiceBusReceiverAsyncClient.abandon(MessageLockToken lockToken, Map<String,Object> propertiesToModify)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(MessageLockToken lockToken, Map<String,Object> propertiesToModify)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Abandon a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">message</xref> with its lock token and updates the message's properties. This will make the message available again for processing. Abandoning a message will increase the delivery count on the message."
  syntax:
    content: "public Mono<Void> abandon(MessageLockToken lockToken, Map<String,Object> propertiesToModify)"
    parameters:
    - id: "lockToken"
      type: "com.azure.messaging.servicebus.MessageLockToken"
      description: "Lock token of the message."
    - id: "propertiesToModify"
      type: "java.util.Map<java.lang.String,java.lang.Object>"
      description: "Properties to modify on the message."
    return:
      type: "reactor.core.publisher.Mono<java.lang.Void>"
      description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\">Mono</xref> that completes when the Service Bus operation finishes."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.close()"
  id: "close()"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "close()"
  nameWithType: "ServiceBusReceiverAsyncClient.close()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.close()"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.close*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Disposes of the consumer by closing the underlying connection to the service."
  syntax:
    content: "public void close()"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(com.azure.messaging.servicebus.MessageLockToken)"
  id: "complete(com.azure.messaging.servicebus.MessageLockToken)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "complete(MessageLockToken lockToken)"
  nameWithType: "ServiceBusReceiverAsyncClient.complete(MessageLockToken lockToken)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(MessageLockToken lockToken)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Completes a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">message</xref> using its lock token. This will delete the message from the service."
  syntax:
    content: "public Mono<Void> complete(MessageLockToken lockToken)"
    parameters:
    - id: "lockToken"
      type: "com.azure.messaging.servicebus.MessageLockToken"
      description: "Lock token of the message."
    return:
      type: "reactor.core.publisher.Mono<java.lang.Void>"
      description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\">Mono</xref> that completes when the Service Bus operation finishes."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.MessageLockToken)"
  id: "deadLetter(com.azure.messaging.servicebus.MessageLockToken)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "deadLetter(MessageLockToken lockToken)"
  nameWithType: "ServiceBusReceiverAsyncClient.deadLetter(MessageLockToken lockToken)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(MessageLockToken lockToken)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Moves a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">message</xref> to the deadletter sub-queue."
  syntax:
    content: "public Mono<Void> deadLetter(MessageLockToken lockToken)"
    parameters:
    - id: "lockToken"
      type: "com.azure.messaging.servicebus.MessageLockToken"
      description: "Lock token of the message."
    return:
      type: "reactor.core.publisher.Mono<java.lang.Void>"
      description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\">Mono</xref> that completes when the Service Bus operation finishes."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(com.azure.messaging.servicebus.MessageLockToken,com.azure.messaging.servicebus.DeadLetterOptions)"
  id: "deadLetter(com.azure.messaging.servicebus.MessageLockToken,com.azure.messaging.servicebus.DeadLetterOptions)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "deadLetter(MessageLockToken lockToken, DeadLetterOptions deadLetterOptions)"
  nameWithType: "ServiceBusReceiverAsyncClient.deadLetter(MessageLockToken lockToken, DeadLetterOptions deadLetterOptions)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter(MessageLockToken lockToken, DeadLetterOptions deadLetterOptions)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Moves a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">message</xref> to the deadletter subqueue with deadletter reason, error description, and/or modified properties."
  syntax:
    content: "public Mono<Void> deadLetter(MessageLockToken lockToken, DeadLetterOptions deadLetterOptions)"
    parameters:
    - id: "lockToken"
      type: "com.azure.messaging.servicebus.MessageLockToken"
      description: "Lock token of the message."
    - id: "deadLetterOptions"
      type: "com.azure.messaging.servicebus.DeadLetterOptions"
      description: "The options to specify when moving message to the deadletter sub-queue."
    return:
      type: "reactor.core.publisher.Mono<java.lang.Void>"
      description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\">Mono</xref> that completes when the Service Bus operation finishes."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(com.azure.messaging.servicebus.MessageLockToken)"
  id: "defer(com.azure.messaging.servicebus.MessageLockToken)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "defer(MessageLockToken lockToken)"
  nameWithType: "ServiceBusReceiverAsyncClient.defer(MessageLockToken lockToken)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(MessageLockToken lockToken)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Defers a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">message</xref> using its lock token. This will move message into the deferred subqueue."
  syntax:
    content: "public Mono<Void> defer(MessageLockToken lockToken)"
    parameters:
    - id: "lockToken"
      type: "com.azure.messaging.servicebus.MessageLockToken"
      description: "Lock token of the message."
    return:
      type: "reactor.core.publisher.Mono<java.lang.Void>"
      description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\">Mono</xref> that completes when the Service Bus operation finishes."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(com.azure.messaging.servicebus.MessageLockToken,java.util.Map<java.lang.String,java.lang.Object>)"
  id: "defer(com.azure.messaging.servicebus.MessageLockToken,java.util.Map<java.lang.String,java.lang.Object>)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "defer(MessageLockToken lockToken, Map<String,Object> propertiesToModify)"
  nameWithType: "ServiceBusReceiverAsyncClient.defer(MessageLockToken lockToken, Map<String,Object> propertiesToModify)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer(MessageLockToken lockToken, Map<String,Object> propertiesToModify)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Defers a <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">message</xref> using its lock token with modified message property. This will move message into the deferred subqueue."
  syntax:
    content: "public Mono<Void> defer(MessageLockToken lockToken, Map<String,Object> propertiesToModify)"
    parameters:
    - id: "lockToken"
      type: "com.azure.messaging.servicebus.MessageLockToken"
      description: "Lock token of the message."
    - id: "propertiesToModify"
      type: "java.util.Map<java.lang.String,java.lang.Object>"
      description: "Message properties to modify."
    return:
      type: "reactor.core.publisher.Mono<java.lang.Void>"
      description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\">Mono</xref> that completes when the Service Bus operation finishes."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getEntityPath()"
  id: "getEntityPath()"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "getEntityPath()"
  nameWithType: "ServiceBusReceiverAsyncClient.getEntityPath()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getEntityPath()"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getEntityPath*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Gets the Service Bus resource this client interacts with."
  syntax:
    content: "public String getEntityPath()"
    return:
      type: "java.lang.String"
      description: "The Service Bus resource this client interacts with."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace()"
  id: "getFullyQualifiedNamespace()"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "getFullyQualifiedNamespace()"
  nameWithType: "ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace()"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Gets the fully qualified Service Bus namespace that the connection is associated with. This is likely similar to `{yournamespace}.servicebus.windows.net`."
  syntax:
    content: "public String getFullyQualifiedNamespace()"
    return:
      type: "java.lang.String"
      description: "The fully qualified Service Bus namespace that the connection is associated with."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peek()"
  id: "peek()"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "peek()"
  nameWithType: "ServiceBusReceiverAsyncClient.peek()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peek()"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peek*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Reads the next active message without changing the state of the receiver or the message source. The first call to `peek()` fetches the first active message for this receiver. Each subsequent call fetches the subsequent message in the entity."
  syntax:
    content: "public Mono<ServiceBusReceivedMessage> peek()"
    return:
      type: "reactor.core.publisher.Mono<com.azure.messaging.servicebus.ServiceBusReceivedMessage>"
      description: "A peeked <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">ServiceBusReceivedMessage</xref>."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekAt(long)"
  id: "peekAt(long)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "peekAt(long sequenceNumber)"
  nameWithType: "ServiceBusReceiverAsyncClient.peekAt(long sequenceNumber)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekAt(long sequenceNumber)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekAt*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Starting from the given sequence number, reads next the active message without changing the state of the receiver or the message source."
  syntax:
    content: "public Mono<ServiceBusReceivedMessage> peekAt(long sequenceNumber)"
    parameters:
    - id: "sequenceNumber"
      type: "long"
      description: "The sequence number from where to read the message."
    return:
      type: "reactor.core.publisher.Mono<com.azure.messaging.servicebus.ServiceBusReceivedMessage>"
      description: "A peeked <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">ServiceBusReceivedMessage</xref>."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatch(int)"
  id: "peekBatch(int)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "peekBatch(int maxMessages)"
  nameWithType: "ServiceBusReceiverAsyncClient.peekBatch(int maxMessages)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatch(int maxMessages)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatch*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Reads the next batch of active messages without changing the state of the receiver or the message source."
  syntax:
    content: "public Flux<ServiceBusReceivedMessage> peekBatch(int maxMessages)"
    parameters:
    - id: "maxMessages"
      type: "int"
      description: "The number of messages."
    return:
      type: "reactor.core.publisher.Flux<com.azure.messaging.servicebus.ServiceBusReceivedMessage>"
      description: "A <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\">Flux</xref> of <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">messages</xref> that are peeked."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatchAt(int,long)"
  id: "peekBatchAt(int,long)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "peekBatchAt(int maxMessages, long sequenceNumber)"
  nameWithType: "ServiceBusReceiverAsyncClient.peekBatchAt(int maxMessages, long sequenceNumber)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatchAt(int maxMessages, long sequenceNumber)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatchAt*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Starting from the given sequence number, reads the next batch of active messages without changing the state of the receiver or the message source."
  syntax:
    content: "public Flux<ServiceBusReceivedMessage> peekBatchAt(int maxMessages, long sequenceNumber)"
    parameters:
    - id: "maxMessages"
      type: "int"
      description: "The number of messages."
    - id: "sequenceNumber"
      type: "long"
      description: "The sequence number from where to start reading messages."
    return:
      type: "reactor.core.publisher.Flux<com.azure.messaging.servicebus.ServiceBusReceivedMessage>"
      description: "A <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\">Flux</xref> of <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">ServiceBusReceivedMessage</xref> peeked."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receive()"
  id: "receive()"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "receive()"
  nameWithType: "ServiceBusReceiverAsyncClient.receive()"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receive()"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receive*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Receives a stream of <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">messages</xref> from the Service Bus entity and completes them when they are finished processing.\n\nBy default, each successfully consumed message is <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete(com.azure.messaging.servicebus.MessageLockToken)\" data-throw-if-not-resolved=\"false\">auto-completed</xref> and <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(com.azure.messaging.servicebus.MessageLockToken)\" data-throw-if-not-resolved=\"false\">auto-renewed</xref>. When downstream consumers throw an exception, the auto-completion feature will <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon(com.azure.messaging.servicebus.MessageLockToken)\" data-throw-if-not-resolved=\"false\">abandon</xref> the message. <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(com.azure.messaging.servicebus.MessageLockToken)\" data-throw-if-not-resolved=\"false\">Auto-renewal</xref> occurs until the <xref uid=\"\" data-throw-if-not-resolved=\"false\">operation timeout</xref> has elapsed."
  syntax:
    content: "public Flux<ServiceBusReceivedMessage> receive()"
    return:
      type: "reactor.core.publisher.Flux<com.azure.messaging.servicebus.ServiceBusReceivedMessage>"
      description: "A stream of messages from the Service Bus entity."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receive(com.azure.messaging.servicebus.models.ReceiveAsyncOptions)"
  id: "receive(com.azure.messaging.servicebus.models.ReceiveAsyncOptions)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "receive(ReceiveAsyncOptions options)"
  nameWithType: "ServiceBusReceiverAsyncClient.receive(ReceiveAsyncOptions options)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receive(ReceiveAsyncOptions options)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receive*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Receives a stream of <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">messages</xref> from the Service Bus entity with a set of options. To disable lock auto-renewal, set <xref uid=\"com.azure.messaging.servicebus.models.ReceiveAsyncOptions.setMaxAutoRenewDuration(java.time.Duration)\" data-throw-if-not-resolved=\"false\">setMaxAutoRenewDuration</xref> to <xref uid=\"\" data-throw-if-not-resolved=\"false\">Duration#ZERO</xref> or `null`."
  syntax:
    content: "public Flux<ServiceBusReceivedMessage> receive(ReceiveAsyncOptions options)"
    parameters:
    - id: "options"
      type: "com.azure.messaging.servicebus.models.ReceiveAsyncOptions"
      description: "Set of options to set when receiving messages."
    return:
      type: "reactor.core.publisher.Flux<com.azure.messaging.servicebus.ServiceBusReceivedMessage>"
      description: "A stream of messages from the Service Bus entity."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessage(long)"
  id: "receiveDeferredMessage(long)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "receiveDeferredMessage(long sequenceNumber)"
  nameWithType: "ServiceBusReceiverAsyncClient.receiveDeferredMessage(long sequenceNumber)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessage(long sequenceNumber)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessage*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Receives a deferred <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">message</xref>. Deferred messages can only be received by using sequence number."
  syntax:
    content: "public Mono<ServiceBusReceivedMessage> receiveDeferredMessage(long sequenceNumber)"
    parameters:
    - id: "sequenceNumber"
      type: "long"
      description: "The <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage.getSequenceNumber()\" data-throw-if-not-resolved=\"false\">sequence number</xref> of the\n     message."
    return:
      type: "reactor.core.publisher.Mono<com.azure.messaging.servicebus.ServiceBusReceivedMessage>"
      description: "A deferred message with the matching <code>sequenceNumber</code>."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessageBatch(long...)"
  id: "receiveDeferredMessageBatch(long...)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "receiveDeferredMessageBatch(long[] sequenceNumbers)"
  nameWithType: "ServiceBusReceiverAsyncClient.receiveDeferredMessageBatch(long[] sequenceNumbers)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessageBatch(long[] sequenceNumbers)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessageBatch*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Receives a batch of deferred <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">messages</xref>. Deferred messages can only be received by using sequence number."
  syntax:
    content: "public Flux<ServiceBusReceivedMessage> receiveDeferredMessageBatch(long[] sequenceNumbers)"
    parameters:
    - id: "sequenceNumbers"
      type: "long[]"
      description: "The sequence numbers of the deferred messages."
    return:
      type: "reactor.core.publisher.Flux<com.azure.messaging.servicebus.ServiceBusReceivedMessage>"
      description: "A <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\">Flux</xref> of deferred <xref uid=\"com.azure.messaging.servicebus.ServiceBusReceivedMessage\" data-throw-if-not-resolved=\"false\">messages</xref>."
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(com.azure.messaging.servicebus.MessageLockToken)"
  id: "renewMessageLock(com.azure.messaging.servicebus.MessageLockToken)"
  parent: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient"
  langs:
  - "java"
  name: "renewMessageLock(MessageLockToken lockToken)"
  nameWithType: "ServiceBusReceiverAsyncClient.renewMessageLock(MessageLockToken lockToken)"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock(MessageLockToken lockToken)"
  overload: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock*"
  type: "Method"
  package: "com.azure.messaging.servicebus"
  summary: "Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified on the entity. When a message is received in <xref uid=\"com.azure.messaging.servicebus.models.ReceiveMode.PEEK_LOCK\" data-throw-if-not-resolved=\"false\">ReceiveMode#PEEK_LOCK</xref> mode, the message is locked on the server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to the entity's LockDuration value."
  syntax:
    content: "public Mono<Instant> renewMessageLock(MessageLockToken lockToken)"
    parameters:
    - id: "lockToken"
      type: "com.azure.messaging.servicebus.MessageLockToken"
      description: "Lock token of the message to renew."
    return:
      type: "reactor.core.publisher.Mono<java.time.Instant>"
      description: "The new expiration time for the message."
references:
- uid: "java.lang.String"
  spec.java:
  - uid: "java.lang.String"
    name: "String"
    fullName: "java.lang.String"
- uid: "com.azure.messaging.servicebus.implementation.MessagingEntityType"
  name: "MessagingEntityType"
  nameWithType: "MessagingEntityType"
  fullName: "com.azure.messaging.servicebus.implementation.MessagingEntityType"
- uid: "boolean"
  spec.java:
  - uid: "boolean"
    name: "boolean"
    fullName: "boolean"
- uid: "com.azure.messaging.servicebus.ReceiverOptions"
  name: "ReceiverOptions"
  nameWithType: "ReceiverOptions"
  fullName: "com.azure.messaging.servicebus.ReceiverOptions"
- uid: "com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor"
  name: "ServiceBusConnectionProcessor"
  nameWithType: "ServiceBusConnectionProcessor"
  fullName: "com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor"
- uid: "com.azure.core.amqp.implementation.TracerProvider"
  spec.java:
  - uid: "com.azure.core.amqp.implementation.TracerProvider"
    name: "TracerProvider"
    fullName: "com.azure.core.amqp.implementation.TracerProvider"
- uid: "com.azure.core.amqp.implementation.MessageSerializer"
  spec.java:
  - uid: "com.azure.core.amqp.implementation.MessageSerializer"
    name: "MessageSerializer"
    fullName: "com.azure.core.amqp.implementation.MessageSerializer"
- uid: "com.azure.messaging.servicebus.implementation.MessageLockContainer"
  name: "MessageLockContainer"
  nameWithType: "MessageLockContainer"
  fullName: "com.azure.messaging.servicebus.implementation.MessageLockContainer"
- uid: "java.lang.Runnable"
  spec.java:
  - uid: "java.lang.Runnable"
    name: "Runnable"
    fullName: "java.lang.Runnable"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.ServiceBusReceiverAsyncClient*"
  name: "ServiceBusReceiverAsyncClient"
  nameWithType: "ServiceBusReceiverAsyncClient.ServiceBusReceiverAsyncClient"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.ServiceBusReceiverAsyncClient"
  package: "com.azure.messaging.servicebus"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace*"
  name: "getFullyQualifiedNamespace"
  nameWithType: "ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getFullyQualifiedNamespace"
  package: "com.azure.messaging.servicebus"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getEntityPath*"
  name: "getEntityPath"
  nameWithType: "ServiceBusReceiverAsyncClient.getEntityPath"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.getEntityPath"
  package: "com.azure.messaging.servicebus"
- uid: "com.azure.messaging.servicebus.MessageLockToken"
  name: "MessageLockToken"
  nameWithType: "MessageLockToken"
  fullName: "com.azure.messaging.servicebus.MessageLockToken"
- uid: "reactor.core.publisher.Mono<java.lang.Void>"
  spec.java:
  - uid: "reactor.core.publisher.Mono"
    name: "Mono"
    fullName: "reactor.core.publisher.Mono"
  - name: "<"
    fullName: "<"
  - uid: "java.lang.Void"
    name: "Void"
    fullName: "java.lang.Void"
  - name: ">"
    fullName: ">"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon*"
  name: "abandon"
  nameWithType: "ServiceBusReceiverAsyncClient.abandon"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.abandon"
  package: "com.azure.messaging.servicebus"
- uid: "java.util.Map<java.lang.String,java.lang.Object>"
  spec.java:
  - uid: "java.util.Map"
    name: "Map"
    fullName: "java.util.Map"
  - name: "<"
    fullName: "<"
  - uid: "java.lang.String"
    name: "String"
    fullName: "java.lang.String"
  - name: ","
    fullName: ","
  - uid: "java.lang.Object"
    name: "Object"
    fullName: "java.lang.Object"
  - name: ">"
    fullName: ">"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete*"
  name: "complete"
  nameWithType: "ServiceBusReceiverAsyncClient.complete"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.complete"
  package: "com.azure.messaging.servicebus"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer*"
  name: "defer"
  nameWithType: "ServiceBusReceiverAsyncClient.defer"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.defer"
  package: "com.azure.messaging.servicebus"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter*"
  name: "deadLetter"
  nameWithType: "ServiceBusReceiverAsyncClient.deadLetter"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.deadLetter"
  package: "com.azure.messaging.servicebus"
- uid: "com.azure.messaging.servicebus.DeadLetterOptions"
  name: "DeadLetterOptions"
  nameWithType: "DeadLetterOptions"
  fullName: "com.azure.messaging.servicebus.DeadLetterOptions"
- uid: "reactor.core.publisher.Mono<com.azure.messaging.servicebus.ServiceBusReceivedMessage>"
  spec.java:
  - uid: "reactor.core.publisher.Mono"
    name: "Mono"
    fullName: "reactor.core.publisher.Mono"
  - name: "<"
    fullName: "<"
  - uid: "com.azure.messaging.servicebus.ServiceBusReceivedMessage"
    name: "ServiceBusReceivedMessage"
    fullName: "com.azure.messaging.servicebus.ServiceBusReceivedMessage"
  - name: ">"
    fullName: ">"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peek*"
  name: "peek"
  nameWithType: "ServiceBusReceiverAsyncClient.peek"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peek"
  package: "com.azure.messaging.servicebus"
- uid: "long"
  spec.java:
  - uid: "long"
    name: "long"
    fullName: "long"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekAt*"
  name: "peekAt"
  nameWithType: "ServiceBusReceiverAsyncClient.peekAt"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekAt"
  package: "com.azure.messaging.servicebus"
- uid: "int"
  spec.java:
  - uid: "int"
    name: "int"
    fullName: "int"
- uid: "reactor.core.publisher.Flux<com.azure.messaging.servicebus.ServiceBusReceivedMessage>"
  spec.java:
  - uid: "reactor.core.publisher.Flux"
    name: "Flux"
    fullName: "reactor.core.publisher.Flux"
  - name: "<"
    fullName: "<"
  - uid: "com.azure.messaging.servicebus.ServiceBusReceivedMessage"
    name: "ServiceBusReceivedMessage"
    fullName: "com.azure.messaging.servicebus.ServiceBusReceivedMessage"
  - name: ">"
    fullName: ">"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatch*"
  name: "peekBatch"
  nameWithType: "ServiceBusReceiverAsyncClient.peekBatch"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatch"
  package: "com.azure.messaging.servicebus"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatchAt*"
  name: "peekBatchAt"
  nameWithType: "ServiceBusReceiverAsyncClient.peekBatchAt"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.peekBatchAt"
  package: "com.azure.messaging.servicebus"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receive*"
  name: "receive"
  nameWithType: "ServiceBusReceiverAsyncClient.receive"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receive"
  package: "com.azure.messaging.servicebus"
- uid: "com.azure.messaging.servicebus.models.ReceiveAsyncOptions"
  name: "ReceiveAsyncOptions"
  nameWithType: "ReceiveAsyncOptions"
  fullName: "com.azure.messaging.servicebus.models.ReceiveAsyncOptions"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessage*"
  name: "receiveDeferredMessage"
  nameWithType: "ServiceBusReceiverAsyncClient.receiveDeferredMessage"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessage"
  package: "com.azure.messaging.servicebus"
- uid: "long[]"
  spec.java:
  - uid: "long"
    name: "long"
    fullName: "long"
  - name: "[]"
    fullName: "[]"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessageBatch*"
  name: "receiveDeferredMessageBatch"
  nameWithType: "ServiceBusReceiverAsyncClient.receiveDeferredMessageBatch"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.receiveDeferredMessageBatch"
  package: "com.azure.messaging.servicebus"
- uid: "reactor.core.publisher.Mono<java.time.Instant>"
  spec.java:
  - uid: "reactor.core.publisher.Mono"
    name: "Mono"
    fullName: "reactor.core.publisher.Mono"
  - name: "<"
    fullName: "<"
  - uid: "java.time.Instant"
    name: "Instant"
    fullName: "java.time.Instant"
  - name: ">"
    fullName: ">"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock*"
  name: "renewMessageLock"
  nameWithType: "ServiceBusReceiverAsyncClient.renewMessageLock"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.renewMessageLock"
  package: "com.azure.messaging.servicebus"
- uid: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.close*"
  name: "close"
  nameWithType: "ServiceBusReceiverAsyncClient.close"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceiverAsyncClient.close"
  package: "com.azure.messaging.servicebus"
- uid: "java.lang.AutoCloseable"
  name: "AutoCloseable"
  nameWithType: "AutoCloseable"
  fullName: "java.lang.AutoCloseable"
- uid: "java.lang.Object.notify()"
  name: "Object.notify()"
  nameWithType: "Object.notify()"
  fullName: "java.lang.Object.notify()"
- uid: "java.lang.Object.wait()"
  name: "Object.wait()"
  nameWithType: "Object.wait()"
  fullName: "java.lang.Object.wait()"
- uid: "java.lang.Object.finalize()"
  name: "Object.finalize()"
  nameWithType: "Object.finalize()"
  fullName: "java.lang.Object.finalize()"
- uid: "java.lang.Object.clone()"
  name: "Object.clone()"
  nameWithType: "Object.clone()"
  fullName: "java.lang.Object.clone()"
- uid: "java.lang.Object.notifyAll()"
  name: "Object.notifyAll()"
  nameWithType: "Object.notifyAll()"
  fullName: "java.lang.Object.notifyAll()"
- uid: "java.lang.Object.equals(java.lang.Object)"
  name: "Object.equals(Object)"
  nameWithType: "Object.equals(Object)"
  fullName: "java.lang.Object.equals(java.lang.Object)"
- uid: "java.lang.Object.getClass()"
  name: "Object.getClass()"
  nameWithType: "Object.getClass()"
  fullName: "java.lang.Object.getClass()"
- uid: "java.lang.Object.wait(long)"
  name: "Object.wait(long)"
  nameWithType: "Object.wait(long)"
  fullName: "java.lang.Object.wait(long)"
- uid: "java.lang.Object.hashCode()"
  name: "Object.hashCode()"
  nameWithType: "Object.hashCode()"
  fullName: "java.lang.Object.hashCode()"
- uid: "java.lang.Object.wait(long,int)"
  name: "Object.wait(long,int)"
  nameWithType: "Object.wait(long,int)"
  fullName: "java.lang.Object.wait(long,int)"
- uid: "java.lang.Object.toString()"
  name: "Object.toString()"
  nameWithType: "Object.toString()"
  fullName: "java.lang.Object.toString()"
- uid: "java.lang.Void"
  name: "Void"
  nameWithType: "Void"
  fullName: "java.lang.Void"
- uid: "reactor.core.publisher.Mono"
  name: "Mono"
  nameWithType: "Mono"
  fullName: "reactor.core.publisher.Mono"
- uid: "java.lang.String,java.lang.Object"
  name: "String,Object"
  nameWithType: "String,Object"
  fullName: "java.lang.String,java.lang.Object"
- uid: "java.util.Map"
  name: "Map"
  nameWithType: "Map"
  fullName: "java.util.Map"
- uid: "com.azure.messaging.servicebus.ServiceBusReceivedMessage"
  name: "ServiceBusReceivedMessage"
  nameWithType: "ServiceBusReceivedMessage"
  fullName: "com.azure.messaging.servicebus.ServiceBusReceivedMessage"
- uid: "reactor.core.publisher.Flux"
  name: "Flux"
  nameWithType: "Flux"
  fullName: "reactor.core.publisher.Flux"
- uid: "java.time.Instant"
  name: "Instant"
  nameWithType: "Instant"
  fullName: "java.time.Instant"
