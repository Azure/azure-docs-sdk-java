### YamlMime:JavaType
uid: "com.fasterxml.jackson.annotation.JsonTypeInfo"
fullName: "com.fasterxml.jackson.annotation.JsonTypeInfo"
name: "JsonTypeInfo"
nameWithType: "JsonTypeInfo"
summary: "Annotation used for configuring details of if and how type information is used with JSON serialization and deserialization, to preserve information about actual class of Object instances. This is necessarily for polymorphic types, and may also be needed to link abstract declared types and matching concrete implementation.\n\nSome examples of typical annotations:\n\n```java\n// Include Java class name (\"com.myempl.ImplClass\") as JSON property \"class\"\n  @JsonTypeInfo(use=Id.CLASS, include=As.PROPERTY, property=\"class\")\n  \n  // Include logical type name (defined in impl classes) as wrapper; 2 annotations\n  @JsonTypeInfo(use=Id.NAME, include=As.WRAPPER_OBJECT)\n  @JsonSubTypes({com.myemp.Impl1.class, com.myempl.Impl2.class})\n```\n\nAlternatively you can also define fully customized type handling by using `@JsonTypeResolver` annotation (from databind package).\n\nThis annotation can be used both for types (classes) and properties. If both exist, annotation on property has precedence, as it is considered more specific.\n\nWhen used for properties (fields, methods), this annotation applies to **values**: so when applied to structure types (like <xref uid=\"java.util.Collection\" data-throw-if-not-resolved=\"false\" data-raw-source=\"java.util.Collection\"></xref>, <xref uid=\"java.util.Map\" data-throw-if-not-resolved=\"false\" data-raw-source=\"java.util.Map\"></xref>, arrays), will apply to contained values, not the container; for non-structured types there is no difference. This is identical to how JAXB handles type information annotations; and is chosen since it is the dominant use case. There is no per-property way to force type information to be included for type of container (structured type); for container types one has to use annotation for type declaration.\n\nNote on visibility of type identifier: by default, deserialization (use during reading of JSON) of type identifier is completely handled by Jackson, and is **not passed to** deserializers. However, if so desired, it is possible to define property `visible = true` in which case property will be passed as-is to deserializers (and set via setter or field) on deserialization.\n\nOn serialization side, Jackson will generate type id by itself, except if there is a property with name that matches <xref uid=\"com.fasterxml.jackson.annotation.JsonTypeInfo.property()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#property()\"></xref>, in which case value of that property is used instead.\n\nNOTE: use of type id of \"class name\" with very general base type (such as <xref uid=\"java.lang.Object\" data-throw-if-not-resolved=\"false\" data-raw-source=\"java.lang.Object\"></xref> or <xref uid=\"java.io.Serializable\" data-throw-if-not-resolved=\"false\" data-raw-source=\"java.io.Serializable\"></xref>) can potentially open up security holes if deserializing content generated by untrusted sources. If content can not be trusted, it is necessary to either use \"type name\" as type id, or to limit possible types using other means."
syntax: "public interface JsonTypeInfo implements Annotation"
methods:
- "com.fasterxml.jackson.annotation.JsonTypeInfo.defaultImpl()"
- "com.fasterxml.jackson.annotation.JsonTypeInfo.include()"
- "com.fasterxml.jackson.annotation.JsonTypeInfo.property()"
- "com.fasterxml.jackson.annotation.JsonTypeInfo.use()"
- "com.fasterxml.jackson.annotation.JsonTypeInfo.visible()"
type: "interface"
implements:
- "<xref href=\"java.lang.annotation.Annotation?alt=java.lang.annotation.Annotation&text=Annotation\" data-throw-if-not-resolved=\"False\" />"
metadata: {}
package: "com.fasterxml.jackson.annotation"
artifact: com.azure:azure-security-keyvault-jca:1.0.0-beta.2
