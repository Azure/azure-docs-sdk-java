### YamlMime:ManagedReference
items:
- uid: com.azure.cosmos.implementation.guava25.collect.Sets
  id: Sets
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect
  children:
  - com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct(java.util.List<? extends java.util.Set<? extends B>>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct(java.util.Set<? extends B>...)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>combinations(java.util.Set<E>,int)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>complementOf(java.util.Collection<E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>complementOf(java.util.Collection<E>,java.lang.Class<E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>difference(java.util.Set<E>,java.util.Set<?>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>filter(java.util.NavigableSet<E>,com.azure.cosmos.implementation.guava25.base.Predicate<? super E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>filter(java.util.Set<E>,com.azure.cosmos.implementation.guava25.base.Predicate<? super E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>filter(java.util.SortedSet<E>,com.azure.cosmos.implementation.guava25.base.Predicate<? super E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>immutableEnumSet(E,E...)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>immutableEnumSet(java.lang.Iterable<E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>intersection(java.util.Set<E>,java.util.Set<?>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newConcurrentHashSet()
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newConcurrentHashSet(java.lang.Iterable<? extends E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newCopyOnWriteArraySet()
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newCopyOnWriteArraySet(java.lang.Iterable<? extends E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newEnumSet(java.lang.Iterable<E>,java.lang.Class<E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet()
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet(E...)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet(java.lang.Iterable<? extends E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet(java.util.Iterator<? extends E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSetWithExpectedSize(int)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newIdentityHashSet()
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newLinkedHashSet()
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newLinkedHashSet(java.lang.Iterable<? extends E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newLinkedHashSetWithExpectedSize(int)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newSetFromMap(java.util.Map<E,java.lang.Boolean>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newTreeSet()
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newTreeSet(java.lang.Iterable<? extends E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>newTreeSet(java.util.Comparator<? super E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>powerSet(java.util.Set<E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>symmetricDifference(java.util.Set<? extends E>,java.util.Set<? extends E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>synchronizedNavigableSet(java.util.NavigableSet<E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>toImmutableEnumSet()
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>union(java.util.Set<? extends E>,java.util.Set<? extends E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<E>unmodifiableNavigableSet(java.util.NavigableSet<E>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.<K>subSet(java.util.NavigableSet<K>,com.azure.cosmos.implementation.guava25.collect.Range<K>)
  - com.azure.cosmos.implementation.guava25.collect.Sets.SetView
  langs:
  - java
  name: Sets
  nameWithType: Sets
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets
  type: Class
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Static utility methods pertaining to <xref uid="java.util.Set" data-throw-if-not-resolved="false">Set</xref> instances. Also see this class's counterparts <xref uid="com.azure.cosmos.implementation.Lists" data-throw-if-not-resolved="false">Lists</xref>, <xref uid="com.azure.cosmos.implementation.guava25.collect.Maps" data-throw-if-not-resolved="false">Maps</xref> and <xref uid="" data-throw-if-not-resolved="false">Queues</xref>.


    See the Guava User Guide article on [ `Sets`][_Sets].



    [_Sets]: https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets
  syntax:
    content: public final class Sets
  inheritance:
  - java.lang.Object
  inheritedMembers:
  - java.lang.Object.clone()
  - java.lang.Object.equals(java.lang.Object)
  - java.lang.Object.finalize()
  - java.lang.Object.getClass()
  - java.lang.Object.hashCode()
  - java.lang.Object.notify()
  - java.lang.Object.notifyAll()
  - java.lang.Object.toString()
  - java.lang.Object.wait()
  - java.lang.Object.wait(long)
  - java.lang.Object.wait(long,int)
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct(java.util.List<? extends java.util.Set<? extends B>>)
  id: <B>cartesianProduct(java.util.List<? extends java.util.Set<? extends B>>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <B>cartesianProduct(List<? extends Set<? extends B>> sets)
  nameWithType: Sets.<B>cartesianProduct(List<? extends Set<? extends B>> sets)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct(List<? extends Set<? extends B>> sets)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.cartesianProduct*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns every possible list that can be formed by choosing one element from each of the given sets in order; the "n-ary [Cartesian product][]" of the sets. For example:


    ```java

    Sets.cartesianProduct(ImmutableList.of(
         ImmutableSet.of(1, 2),
         ImmutableSet.of("A", "B", "C")))
    ```


    returns a set containing six lists:

     *  `ImmutableList.of(1, "A")`
     *  `ImmutableList.of(1, "B")`
     *  `ImmutableList.of(1, "C")`
     *  `ImmutableList.of(2, "A")`
     *  `ImmutableList.of(2, "B")`
     *  `ImmutableList.of(2, "C")`

    The result is guaranteed to be in the "traditional", lexicographical order for Cartesian products that you would get from nesting for loops:


    ```java

    for (B b0 : sets.get(0)) {
       for (B b1 : sets.get(1)) {
         ...
         ImmutableList tuple = ImmutableList.of(b0, b1, ...);
         // operate on tuple
       }
     }
    ```


    Note that if any input set is empty, the Cartesian product will also be empty. If no sets at all are provided (an empty list), the resulting Cartesian product has one element, an empty list (counter-intuitive, but mathematically consistent).


    *Performance notes:* while the cartesian product of sets of size `m, n, p` is a set of size `m x n x p`, its actual memory consumption is much smaller. When the cartesian set is constructed, the input sets are merely copied. Only as the resulting set is iterated are the individual lists created, and these are not retained after iteration.



    [Cartesian product]: http://en.wikipedia.org/wiki/Cartesian_product
  syntax:
    content: public static Set<List<B>> <B>cartesianProduct(List<? extends Set<? extends B>> sets)
    parameters:
    - id: sets
      type: java.util.List<? extends java.util.Set<? extends B>>
      description: >-
        the sets to choose elements from, in the order that the elements chosen from those
             sets should appear in the resulting lists
    return:
      type: java.util.Set<java.util.List<B>>
      description: the Cartesian product, as an immutable set containing immutable lists
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct(java.util.Set<? extends B>...)
  id: <B>cartesianProduct(java.util.Set<? extends B>...)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <B>cartesianProduct(Set<? extends B>[] sets)
  nameWithType: Sets.<B>cartesianProduct(Set<? extends B>[] sets)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct(Set<? extends B>[] sets)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.cartesianProduct*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns every possible list that can be formed by choosing one element from each of the given sets in order; the "n-ary [Cartesian product][]" of the sets. For example:


    ```java

    Sets.cartesianProduct(
         ImmutableSet.of(1, 2),
         ImmutableSet.of("A", "B", "C"))
    ```


    returns a set containing six lists:

     *  `ImmutableList.of(1, "A")`
     *  `ImmutableList.of(1, "B")`
     *  `ImmutableList.of(1, "C")`
     *  `ImmutableList.of(2, "A")`
     *  `ImmutableList.of(2, "B")`
     *  `ImmutableList.of(2, "C")`

    The result is guaranteed to be in the "traditional", lexicographical order for Cartesian products that you would get from nesting for loops:


    ```java

    for (B b0 : sets.get(0)) {
       for (B b1 : sets.get(1)) {
         ...
         ImmutableList tuple = ImmutableList.of(b0, b1, ...);
         // operate on tuple
       }
     }
    ```


    Note that if any input set is empty, the Cartesian product will also be empty. If no sets at all are provided (an empty list), the resulting Cartesian product has one element, an empty list (counter-intuitive, but mathematically consistent).


    *Performance notes:* while the cartesian product of sets of size `m, n, p` is a set of size `m x n x p`, its actual memory consumption is much smaller. When the cartesian set is constructed, the input sets are merely copied. Only as the resulting set is iterated are the individual lists created, and these are not retained after iteration.



    [Cartesian product]: http://en.wikipedia.org/wiki/Cartesian_product
  syntax:
    content: public static Set<List<B>> <B>cartesianProduct(Set<? extends B>[] sets)
    parameters:
    - id: sets
      type: java.util.Set<? extends B>[]
      description: >-
        the sets to choose elements from, in the order that the elements chosen from those
             sets should appear in the resulting lists
    return:
      type: java.util.Set<java.util.List<B>>
      description: the Cartesian product, as an immutable set containing immutable lists
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>combinations(java.util.Set<E>,int)
  id: <E>combinations(java.util.Set<E>,int)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>combinations(Set<E> set, int size)
  nameWithType: Sets.<E>combinations(Set<E> set, int size)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>combinations(Set<E> set, int size)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.combinations*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns the set of all subsets of `set` of size `size`. For example, `combinations(ImmutableSet.of(1, 2, 3), 2)` returns the set `{{1, 2}, {1, 3}, {2, 3}}`.


    Elements appear in these subsets in the same iteration order as they appeared in the input set. The order in which these subsets appear in the outer set is undefined.


    The returned set and its constituent sets use `equals` to decide whether two elements are identical, even if the input set uses a different concept of equivalence.


    *Performance notes:* the memory usage of the returned set is only `O(n)`. When the result set is constructed, the input set is merely copied. Only as the result set is iterated are the individual subsets created. Each of these subsets occupies an additional O(n) memory but only for as long as the user retains a reference to it. That is, the set returned by `combinations` does not retain the individual subsets.
  syntax:
    content: public static Set<Set<E>> <E>combinations(Set<E> set, int size)
    parameters:
    - id: set
      type: java.util.Set<E>
      description: the set of elements to take combinations of
    - id: size
      type: int
      description: the number of elements per combination
    return:
      type: java.util.Set<java.util.Set<E>>
      description: the set of all combinations of <code>size</code> elements from <code>set</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>complementOf(java.util.Collection<E>)
  id: <E>complementOf(java.util.Collection<E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>complementOf(Collection<E> collection)
  nameWithType: Sets.<E>complementOf(Collection<E> collection)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>complementOf(Collection<E> collection)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.complementOf*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Creates an `EnumSet` consisting of all enum values that are not in the specified collection. If the collection is an <xref uid="java.util.EnumSet" data-throw-if-not-resolved="false">EnumSet</xref>, this method has the same behavior as <xref uid="java.util.EnumSet.complementOf" data-throw-if-not-resolved="false">EnumSet#complementOf</xref>. Otherwise, the specified collection must contain at least one element, in order to determine the element type. If the collection could be empty, use <xref uid="com.azure.cosmos.implementation.guava25.collect.Sets.&lt;E&gt;complementOf(java.util.Collection&lt;E&gt;,java.lang.Class&lt;E&gt;)" data-throw-if-not-resolved="false">#complementOf(Collection, Class)</xref> instead of this method.
  syntax:
    content: public static EnumSet<E> <E>complementOf(Collection<E> collection)
    parameters:
    - id: collection
      type: java.util.Collection<E>
      description: the collection whose complement should be stored in the enum set
    return:
      type: java.util.EnumSet<E>
      description: >-
        a new, modifiable <code>EnumSet</code> containing all values of the enum that aren't present
             in the given collection
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>complementOf(java.util.Collection<E>,java.lang.Class<E>)
  id: <E>complementOf(java.util.Collection<E>,java.lang.Class<E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>complementOf(Collection<E> collection, Class<E> type)
  nameWithType: Sets.<E>complementOf(Collection<E> collection, Class<E> type)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>complementOf(Collection<E> collection, Class<E> type)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.complementOf*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Creates an `EnumSet` consisting of all enum values that are not in the specified collection. This is equivalent to <xref uid="java.util.EnumSet.complementOf" data-throw-if-not-resolved="false">EnumSet#complementOf</xref>, but can act on any input collection, as long as the elements are of enum type.
  syntax:
    content: public static EnumSet<E> <E>complementOf(Collection<E> collection, Class<E> type)
    parameters:
    - id: collection
      type: java.util.Collection<E>
      description: the collection whose complement should be stored in the <code>EnumSet</code>
    - id: type
      type: java.lang.Class<E>
      description: the type of the elements in the set
    return:
      type: java.util.EnumSet<E>
      description: >-
        a new, modifiable <code>EnumSet</code> initially containing all the values of the enum not
             present in the given collection
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>difference(java.util.Set<E>,java.util.Set<?>)
  id: <E>difference(java.util.Set<E>,java.util.Set<?>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>difference(Set<E> set1, Set<?> set2)
  nameWithType: Sets.<E>difference(Set<E> set1, Set<?> set2)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>difference(Set<E> set1, Set<?> set2)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.difference*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an unmodifiable **view** of the difference of two sets. The returned set contains all elements that are contained by `set1` and not contained by `set2`. `set2` may also contain elements not present in `set1`; these are simply ignored. The iteration order of the returned set matches that of `set1`.


    Results are undefined if `set1` and `set2` are sets based on different equivalence relations (as `HashSet`, `TreeSet`, and the keySet of an `IdentityHashMap` all are).
  syntax:
    content: public static Sets.SetView<E> <E>difference(Set<E> set1, Set<?> set2)
    parameters:
    - id: set1
      type: java.util.Set<E>
    - id: set2
      type: java.util.Set<?>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Sets.SetView<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>filter(java.util.NavigableSet<E>,com.azure.cosmos.implementation.guava25.base.Predicate<? super E>)
  id: <E>filter(java.util.NavigableSet<E>,com.azure.cosmos.implementation.guava25.base.Predicate<? super E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>filter(NavigableSet<E> unfiltered, Predicate<? super E> predicate)
  nameWithType: Sets.<E>filter(NavigableSet<E> unfiltered, Predicate<? super E> predicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>filter(NavigableSet<E> unfiltered, Predicate<? super E> predicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.filter*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns the elements of a `NavigableSet`, `unfiltered`, that satisfy a predicate. The returned set is a live view of `unfiltered`; changes to one affect the other.


    The resulting set's iterator does not support `remove()`, but all other set methods are supported. When given an element that doesn't satisfy the predicate, the set's `add()` and `addAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>. When methods such as `removeAll()` and `clear()` are called on the filtered set, only elements that satisfy the filter will be removed from the underlying set.


    The returned set isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered set's methods, such as `size()`, iterate across every element in the underlying set and determine which elements satisfy the filter. When a live view is *not* needed, it may be faster to copy `Iterables.filter(unfiltered, predicate)` and use the copy.


    **Warning:** `predicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals. (See <xref uid="com.azure.cosmos.implementation.guava25.collect.Iterables.&lt;T&gt;filter(java.lang.Iterable&lt;?&gt;,java.lang.Class&lt;T&gt;)" data-throw-if-not-resolved="false">Iterables#filter(Iterable, Class)</xref> for related functionality.)
  syntax:
    content: public static NavigableSet<E> <E>filter(NavigableSet<E> unfiltered, Predicate<? super E> predicate)
    parameters:
    - id: unfiltered
      type: java.util.NavigableSet<E>
    - id: predicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super E>
    return:
      type: java.util.NavigableSet<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>filter(java.util.Set<E>,com.azure.cosmos.implementation.guava25.base.Predicate<? super E>)
  id: <E>filter(java.util.Set<E>,com.azure.cosmos.implementation.guava25.base.Predicate<? super E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>filter(Set<E> unfiltered, Predicate<? super E> predicate)
  nameWithType: Sets.<E>filter(Set<E> unfiltered, Predicate<? super E> predicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>filter(Set<E> unfiltered, Predicate<? super E> predicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.filter*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns the elements of `unfiltered` that satisfy a predicate. The returned set is a live view of `unfiltered`; changes to one affect the other.


    The resulting set's iterator does not support `remove()`, but all other set methods are supported. When given an element that doesn't satisfy the predicate, the set's `add()` and `addAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>. When methods such as `removeAll()` and `clear()` are called on the filtered set, only elements that satisfy the filter will be removed from the underlying set.


    The returned set isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered set's methods, such as `size()`, iterate across every element in the underlying set and determine which elements satisfy the filter. When a live view is *not* needed, it may be faster to copy `Iterables.filter(unfiltered, predicate)` and use the copy.


    **Warning:** `predicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals. (See <xref uid="com.azure.cosmos.implementation.guava25.collect.Iterables.&lt;T&gt;filter(java.lang.Iterable&lt;?&gt;,java.lang.Class&lt;T&gt;)" data-throw-if-not-resolved="false">Iterables#filter(Iterable, Class)</xref> for related functionality.)


    **Java 8 users:** many use cases for this method are better addressed by <xref uid="java.util.stream.Stream.filter" data-throw-if-not-resolved="false">java.util.stream.Stream#filter</xref>. This method is not being deprecated, but we gently encourage you to migrate to streams.
  syntax:
    content: public static Set<E> <E>filter(Set<E> unfiltered, Predicate<? super E> predicate)
    parameters:
    - id: unfiltered
      type: java.util.Set<E>
    - id: predicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super E>
    return:
      type: java.util.Set<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>filter(java.util.SortedSet<E>,com.azure.cosmos.implementation.guava25.base.Predicate<? super E>)
  id: <E>filter(java.util.SortedSet<E>,com.azure.cosmos.implementation.guava25.base.Predicate<? super E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>filter(SortedSet<E> unfiltered, Predicate<? super E> predicate)
  nameWithType: Sets.<E>filter(SortedSet<E> unfiltered, Predicate<? super E> predicate)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>filter(SortedSet<E> unfiltered, Predicate<? super E> predicate)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.filter*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns the elements of a `SortedSet`, `unfiltered`, that satisfy a predicate. The returned set is a live view of `unfiltered`; changes to one affect the other.


    The resulting set's iterator does not support `remove()`, but all other set methods are supported. When given an element that doesn't satisfy the predicate, the set's `add()` and `addAll()` methods throw an <xref uid="" data-throw-if-not-resolved="false">IllegalArgumentException</xref>. When methods such as `removeAll()` and `clear()` are called on the filtered set, only elements that satisfy the filter will be removed from the underlying set.


    The returned set isn't threadsafe or serializable, even if `unfiltered` is.


    Many of the filtered set's methods, such as `size()`, iterate across every element in the underlying set and determine which elements satisfy the filter. When a live view is *not* needed, it may be faster to copy `Iterables.filter(unfiltered, predicate)` and use the copy.


    **Warning:** `predicate` must be *consistent with equals*, as documented at <xref uid="com.azure.cosmos.implementation.guava25.base.Predicate.apply" data-throw-if-not-resolved="false">Predicate#apply</xref>. Do not provide a predicate such as `Predicates.instanceOf(ArrayList.class)`, which is inconsistent with equals. (See <xref uid="com.azure.cosmos.implementation.guava25.collect.Iterables.&lt;T&gt;filter(java.lang.Iterable&lt;?&gt;,java.lang.Class&lt;T&gt;)" data-throw-if-not-resolved="false">Iterables#filter(Iterable, Class)</xref> for related functionality.)
  syntax:
    content: public static SortedSet<E> <E>filter(SortedSet<E> unfiltered, Predicate<? super E> predicate)
    parameters:
    - id: unfiltered
      type: java.util.SortedSet<E>
    - id: predicate
      type: com.azure.cosmos.implementation.guava25.base.Predicate<? super E>
    return:
      type: java.util.SortedSet<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>immutableEnumSet(E,E...)
  id: <E>immutableEnumSet(E,E...)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>immutableEnumSet(E anElement, E[] otherElements)
  nameWithType: Sets.<E>immutableEnumSet(E anElement, E[] otherElements)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>immutableEnumSet(E anElement, E[] otherElements)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.immutableEnumSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an immutable set instance containing the given enum elements. Internally, the returned set will be backed by an <xref uid="java.util.EnumSet" data-throw-if-not-resolved="false">EnumSet</xref>.


    The iteration order of the returned set follows the enum's iteration order, not the order in which the elements are provided to the method.
  syntax:
    content: public static ImmutableSet<E> <E>immutableEnumSet(E anElement, E[] otherElements)
    parameters:
    - id: anElement
      type: E
      description: one of the elements the set should contain
    - id: otherElements
      type: E[]
      description: the rest of the elements the set should contain
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableSet<E>
      description: an immutable set containing those elements, minus duplicates
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>immutableEnumSet(java.lang.Iterable<E>)
  id: <E>immutableEnumSet(java.lang.Iterable<E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>immutableEnumSet(Iterable<E> elements)
  nameWithType: Sets.<E>immutableEnumSet(Iterable<E> elements)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>immutableEnumSet(Iterable<E> elements)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.immutableEnumSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an immutable set instance containing the given enum elements. Internally, the returned set will be backed by an <xref uid="java.util.EnumSet" data-throw-if-not-resolved="false">EnumSet</xref>.


    The iteration order of the returned set follows the enum's iteration order, not the order in which the elements appear in the given collection.
  syntax:
    content: public static ImmutableSet<E> <E>immutableEnumSet(Iterable<E> elements)
    parameters:
    - id: elements
      type: java.lang.Iterable<E>
      description: the elements, all of the same <code>enum</code> type, that the set should contain
    return:
      type: com.azure.cosmos.implementation.guava25.collect.ImmutableSet<E>
      description: an immutable set containing those elements, minus duplicates
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>intersection(java.util.Set<E>,java.util.Set<?>)
  id: <E>intersection(java.util.Set<E>,java.util.Set<?>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>intersection(Set<E> set1, Set<?> set2)
  nameWithType: Sets.<E>intersection(Set<E> set1, Set<?> set2)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>intersection(Set<E> set1, Set<?> set2)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.intersection*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: "Returns an unmodifiable **view** of the intersection of two sets. The returned set contains all elements that are contained by both backing sets. The iteration order of the returned set matches that of `set1`.\n\nResults are undefined if `set1` and `set2` are sets based on different equivalence relations (as `HashSet`, `TreeSet`, and the keySet of an `IdentityHashMap` all are).\n\n**Note:** The returned view performs slightly better when `set1` is the smaller of the two sets. If you have reason to believe one of your sets will generally be smaller than the other, pass it first. Unfortunately, since this method sets the generic type of the returned set based on the type of the first set passed, this could in rare cases force you to make a cast, for example:\n\n```java\nSet aFewBadObjects = ...\n Set manyBadStrings = ...\n\n // impossible for a non-String to be in the intersection\n SuppressWarnings(\"unchecked\")\n Set badStrings = (Set) Sets.intersection(\n     aFewBadObjects, manyBadStrings);\n \n\n This is unfortunate, but should come up only very rarely.\n```"
  syntax:
    content: public static Sets.SetView<E> <E>intersection(Set<E> set1, Set<?> set2)
    parameters:
    - id: set1
      type: java.util.Set<E>
    - id: set2
      type: java.util.Set<?>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Sets.SetView<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newConcurrentHashSet()
  id: <E>newConcurrentHashSet()
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newConcurrentHashSet()
  nameWithType: Sets.<E>newConcurrentHashSet()
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newConcurrentHashSet()
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newConcurrentHashSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a thread-safe set backed by a hash map. The set is backed by a <xref uid="" data-throw-if-not-resolved="false">ConcurrentHashMap</xref> instance, and thus carries the same concurrency guarantees.


    Unlike `HashSet`, this class does NOT allow `null` to be used as an element. The set is serializable.
  syntax:
    content: public static Set<E> <E>newConcurrentHashSet()
    return:
      type: java.util.Set<E>
      description: a new, empty thread-safe <code>Set</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newConcurrentHashSet(java.lang.Iterable<? extends E>)
  id: <E>newConcurrentHashSet(java.lang.Iterable<? extends E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newConcurrentHashSet(Iterable<? extends E> elements)
  nameWithType: Sets.<E>newConcurrentHashSet(Iterable<? extends E> elements)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newConcurrentHashSet(Iterable<? extends E> elements)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newConcurrentHashSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a thread-safe set backed by a hash map and containing the given elements. The set is backed by a <xref uid="" data-throw-if-not-resolved="false">ConcurrentHashMap</xref> instance, and thus carries the same concurrency guarantees.


    Unlike `HashSet`, this class does NOT allow `null` to be used as an element. The set is serializable.
  syntax:
    content: public static Set<E> <E>newConcurrentHashSet(Iterable<? extends E> elements)
    parameters:
    - id: elements
      type: java.lang.Iterable<? extends E>
      description: the elements that the set should contain
    return:
      type: java.util.Set<E>
      description: a new thread-safe set containing those elements (minus duplicates)
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newCopyOnWriteArraySet()
  id: <E>newCopyOnWriteArraySet()
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newCopyOnWriteArraySet()
  nameWithType: Sets.<E>newCopyOnWriteArraySet()
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newCopyOnWriteArraySet()
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newCopyOnWriteArraySet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates an empty `CopyOnWriteArraySet` instance.


    **Note:** if you need an immutable empty <xref uid="java.util.Set" data-throw-if-not-resolved="false">Set</xref>, use <xref uid="" data-throw-if-not-resolved="false">Collections#emptySet</xref> instead.
  syntax:
    content: public static CopyOnWriteArraySet<E> <E>newCopyOnWriteArraySet()
    return:
      type: java.util.concurrent.CopyOnWriteArraySet<E>
      description: a new, empty <code>CopyOnWriteArraySet</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newCopyOnWriteArraySet(java.lang.Iterable<? extends E>)
  id: <E>newCopyOnWriteArraySet(java.lang.Iterable<? extends E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newCopyOnWriteArraySet(Iterable<? extends E> elements)
  nameWithType: Sets.<E>newCopyOnWriteArraySet(Iterable<? extends E> elements)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newCopyOnWriteArraySet(Iterable<? extends E> elements)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newCopyOnWriteArraySet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Creates a `CopyOnWriteArraySet` instance containing the given elements.
  syntax:
    content: public static CopyOnWriteArraySet<E> <E>newCopyOnWriteArraySet(Iterable<? extends E> elements)
    parameters:
    - id: elements
      type: java.lang.Iterable<? extends E>
      description: the elements that the set should contain, in order
    return:
      type: java.util.concurrent.CopyOnWriteArraySet<E>
      description: a new <code>CopyOnWriteArraySet</code> containing those elements
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newEnumSet(java.lang.Iterable<E>,java.lang.Class<E>)
  id: <E>newEnumSet(java.lang.Iterable<E>,java.lang.Class<E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newEnumSet(Iterable<E> iterable, Class<E> elementType)
  nameWithType: Sets.<E>newEnumSet(Iterable<E> iterable, Class<E> elementType)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newEnumSet(Iterable<E> iterable, Class<E> elementType)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newEnumSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Returns a new, *mutable* `EnumSet` instance containing the given elements in their natural order. This method behaves identically to <xref uid="java.util.EnumSet.copyOf*" data-throw-if-not-resolved="false">EnumSet#copyOf(Collection)</xref>, but also accepts non-`Collection` iterables and empty iterables.
  syntax:
    content: public static EnumSet<E> <E>newEnumSet(Iterable<E> iterable, Class<E> elementType)
    parameters:
    - id: iterable
      type: java.lang.Iterable<E>
    - id: elementType
      type: java.lang.Class<E>
    return:
      type: java.util.EnumSet<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet()
  id: <E>newHashSet()
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newHashSet()
  nameWithType: Sets.<E>newHashSet()
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet()
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newHashSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable*, initially empty `HashSet` instance.


    **Note:** if mutability is not required, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSet.&lt;E&gt;of()" data-throw-if-not-resolved="false">ImmutableSet#of()</xref> instead. If `E` is an <xref uid="java.lang.Enum" data-throw-if-not-resolved="false">Enum</xref> type, use <xref uid="java.util.EnumSet.noneOf" data-throw-if-not-resolved="false">EnumSet#noneOf</xref> instead. Otherwise, strongly consider using a `LinkedHashSet` instead, at the cost of increased memory footprint, to get deterministic iteration behavior.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `HashSet` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static HashSet<E> <E>newHashSet()
    return:
      type: java.util.HashSet<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet(E...)
  id: <E>newHashSet(E...)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newHashSet(E[] elements)
  nameWithType: Sets.<E>newHashSet(E[] elements)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet(E[] elements)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newHashSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable* `HashSet` instance initially containing the given elements.


    **Note:** if elements are non-null and won't be added or removed after this point, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSet.&lt;E&gt;of()" data-throw-if-not-resolved="false">ImmutableSet#of()</xref> or <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSet.copyOf*" data-throw-if-not-resolved="false">ImmutableSet#copyOf(Object[])</xref> instead. If `E` is an <xref uid="java.lang.Enum" data-throw-if-not-resolved="false">Enum</xref> type, use <xref uid="java.util.EnumSet.of*" data-throw-if-not-resolved="false">EnumSet#of(Enum, Enum[])</xref> instead. Otherwise, strongly consider using a `LinkedHashSet` instead, at the cost of increased memory footprint, to get deterministic iteration behavior.


    This method is just a small convenience, either for `newHashSet(`<xref uid="" data-throw-if-not-resolved="false">asList</xref>`(...))`, or for creating an empty set then calling <xref uid="" data-throw-if-not-resolved="false">Collections#addAll</xref>. This method is not actually very useful and will likely be deprecated in the future.
  syntax:
    content: public static HashSet<E> <E>newHashSet(E[] elements)
    parameters:
    - id: elements
      type: E[]
    return:
      type: java.util.HashSet<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet(java.lang.Iterable<? extends E>)
  id: <E>newHashSet(java.lang.Iterable<? extends E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newHashSet(Iterable<? extends E> elements)
  nameWithType: Sets.<E>newHashSet(Iterable<? extends E> elements)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet(Iterable<? extends E> elements)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newHashSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable* `HashSet` instance containing the given elements. A very thin convenience for creating an empty set then calling <xref uid="java.util.Collection.addAll" data-throw-if-not-resolved="false">Collection#addAll</xref> or <xref uid="com.azure.cosmos.implementation.guava25.collect.Iterables.addAll" data-throw-if-not-resolved="false">Iterables#addAll</xref>.


    **Note:** if mutability is not required and the elements are non-null, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSet.&lt;E&gt;copyOf(java.lang.Iterable&lt;? extends E&gt;)" data-throw-if-not-resolved="false">ImmutableSet#copyOf(Iterable)</xref> instead. (Or, change `elements` to be a <xref uid="com.azure.cosmos.implementation.guava25.collect.FluentIterable" data-throw-if-not-resolved="false">FluentIterable</xref> and call `elements.toSet()`.)


    **Note:** if `E` is an <xref uid="java.lang.Enum" data-throw-if-not-resolved="false">Enum</xref> type, use <xref uid="com.azure.cosmos.implementation.guava25.collect.Sets.&lt;E&gt;newEnumSet(java.lang.Iterable&lt;E&gt;,java.lang.Class&lt;E&gt;)" data-throw-if-not-resolved="false">#newEnumSet(Iterable, Class)</xref> instead.


    **Note for Java 7 and later:** if `elements` is a <xref uid="java.util.Collection" data-throw-if-not-resolved="false">Collection</xref>, you don't need this method. Instead, use the `HashSet` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].


    Overall, this method is not very useful and will likely be deprecated in the future.



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static HashSet<E> <E>newHashSet(Iterable<? extends E> elements)
    parameters:
    - id: elements
      type: java.lang.Iterable<? extends E>
    return:
      type: java.util.HashSet<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet(java.util.Iterator<? extends E>)
  id: <E>newHashSet(java.util.Iterator<? extends E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newHashSet(Iterator<? extends E> elements)
  nameWithType: Sets.<E>newHashSet(Iterator<? extends E> elements)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet(Iterator<? extends E> elements)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newHashSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable* `HashSet` instance containing the given elements. A very thin convenience for creating an empty set and then calling <xref uid="com.azure.cosmos.implementation.guava25.collect.Iterators.addAll" data-throw-if-not-resolved="false">Iterators#addAll</xref>.


    **Note:** if mutability is not required and the elements are non-null, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSet.&lt;E&gt;copyOf(java.util.Iterator&lt;? extends E&gt;)" data-throw-if-not-resolved="false">ImmutableSet#copyOf(Iterator)</xref> instead.


    **Note:** if `E` is an <xref uid="java.lang.Enum" data-throw-if-not-resolved="false">Enum</xref> type, you should create an <xref uid="java.util.EnumSet" data-throw-if-not-resolved="false">EnumSet</xref> instead.


    Overall, this method is not very useful and will likely be deprecated in the future.
  syntax:
    content: public static HashSet<E> <E>newHashSet(Iterator<? extends E> elements)
    parameters:
    - id: elements
      type: java.util.Iterator<? extends E>
    return:
      type: java.util.HashSet<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSetWithExpectedSize(int)
  id: <E>newHashSetWithExpectedSize(int)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newHashSetWithExpectedSize(int expectedSize)
  nameWithType: Sets.<E>newHashSetWithExpectedSize(int expectedSize)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSetWithExpectedSize(int expectedSize)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newHashSetWithExpectedSize*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a new hash set using the smallest initial table size that can hold `expectedSize` elements without resizing. Note that this is not what <xref uid="java.util.HashSet.HashSet*" data-throw-if-not-resolved="false">HashSet#HashSet(int)</xref> does, but it is what most users want and expect it to do.


    This behavior can't be broadly guaranteed, but has been tested with OpenJDK 1.7 and 1.8.
  syntax:
    content: public static HashSet<E> <E>newHashSetWithExpectedSize(int expectedSize)
    parameters:
    - id: expectedSize
      type: int
      description: the number of elements you expect to add to the returned set
    return:
      type: java.util.HashSet<E>
      description: >-
        a new, empty hash set with enough capacity to hold <code>expectedSize</code> elements
             without resizing
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newIdentityHashSet()
  id: <E>newIdentityHashSet()
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newIdentityHashSet()
  nameWithType: Sets.<E>newIdentityHashSet()
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newIdentityHashSet()
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newIdentityHashSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Creates an empty `Set` that uses identity to determine equality. It compares object references, instead of calling `equals`, to determine whether a provided object matches an element in the set. For example, `contains` returns `false` when passed an object that equals a set member, but isn't the same instance. This behavior is similar to the way `IdentityHashMap` handles key lookups.
  syntax:
    content: public static Set<E> <E>newIdentityHashSet()
    return:
      type: java.util.Set<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newLinkedHashSet()
  id: <E>newLinkedHashSet()
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newLinkedHashSet()
  nameWithType: Sets.<E>newLinkedHashSet()
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newLinkedHashSet()
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newLinkedHashSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable*, empty `LinkedHashSet` instance.


    **Note:** if mutability is not required, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSet.&lt;E&gt;of()" data-throw-if-not-resolved="false">ImmutableSet#of()</xref> instead.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `LinkedHashSet` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static LinkedHashSet<E> <E>newLinkedHashSet()
    return:
      type: java.util.LinkedHashSet<E>
      description: a new, empty <code>LinkedHashSet</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newLinkedHashSet(java.lang.Iterable<? extends E>)
  id: <E>newLinkedHashSet(java.lang.Iterable<? extends E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newLinkedHashSet(Iterable<? extends E> elements)
  nameWithType: Sets.<E>newLinkedHashSet(Iterable<? extends E> elements)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newLinkedHashSet(Iterable<? extends E> elements)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newLinkedHashSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable* `LinkedHashSet` instance containing the given elements in order.


    **Note:** if mutability is not required and the elements are non-null, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSet.&lt;E&gt;copyOf(java.lang.Iterable&lt;? extends E&gt;)" data-throw-if-not-resolved="false">ImmutableSet#copyOf(Iterable)</xref> instead.


    **Note for Java 7 and later:** if `elements` is a <xref uid="java.util.Collection" data-throw-if-not-resolved="false">Collection</xref>, you don't need this method. Instead, use the `LinkedHashSet` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].


    Overall, this method is not very useful and will likely be deprecated in the future.



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static LinkedHashSet<E> <E>newLinkedHashSet(Iterable<? extends E> elements)
    parameters:
    - id: elements
      type: java.lang.Iterable<? extends E>
      description: the elements that the set should contain, in order
    return:
      type: java.util.LinkedHashSet<E>
      description: a new <code>LinkedHashSet</code> containing those elements (minus duplicates)
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newLinkedHashSetWithExpectedSize(int)
  id: <E>newLinkedHashSetWithExpectedSize(int)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newLinkedHashSetWithExpectedSize(int expectedSize)
  nameWithType: Sets.<E>newLinkedHashSetWithExpectedSize(int expectedSize)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newLinkedHashSetWithExpectedSize(int expectedSize)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newLinkedHashSetWithExpectedSize*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Creates a `LinkedHashSet` instance, with a high enough "initial capacity" that it *should* hold `expectedSize` elements without growth. This behavior cannot be broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the method isn't inadvertently *oversizing* the returned set.
  syntax:
    content: public static LinkedHashSet<E> <E>newLinkedHashSetWithExpectedSize(int expectedSize)
    parameters:
    - id: expectedSize
      type: int
      description: the number of elements you expect to add to the returned set
    return:
      type: java.util.LinkedHashSet<E>
      description: >-
        a new, empty <code>LinkedHashSet</code> with enough capacity to hold <code>expectedSize</code>
             elements without resizing
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newSetFromMap(java.util.Map<E,java.lang.Boolean>)
  id: <E>newSetFromMap(java.util.Map<E,java.lang.Boolean>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newSetFromMap(Map<E,Boolean> map)
  nameWithType: Sets.<E>newSetFromMap(Map<E,Boolean> map)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newSetFromMap(Map<E,Boolean> map)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newSetFromMap*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: "Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a <xref uid=\"java.util.Set\" data-throw-if-not-resolved=\"false\">Set</xref> implementation corresponding to any <xref uid=\"java.util.Map\" data-throw-if-not-resolved=\"false\">Map</xref> implementation. There is no need to use this method on a <xref uid=\"java.util.Map\" data-throw-if-not-resolved=\"false\">Map</xref> implementation that already has a corresponding <xref uid=\"java.util.Set\" data-throw-if-not-resolved=\"false\">Set</xref> implementation (such as <xref uid=\"java.util.HashMap\" data-throw-if-not-resolved=\"false\">java.util.HashMap</xref> or <xref uid=\"java.util.TreeMap\" data-throw-if-not-resolved=\"false\">java.util.TreeMap</xref>).\n\nEach method invocation on the set returned by this method results in exactly one method invocation on the backing map or its `keySet` view, with one exception. The `addAll` method is implemented as a sequence of `put` invocations on the backing map.\n\nThe specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:\n\n```java\nSet identityHashSet = Sets.newSetFromMap(\n     new IdentityHashMap());\n \n\n The returned set is serializable if the backing map is.\n```"
  syntax:
    content: public static Set<E> <E>newSetFromMap(Map<E,Boolean> map)
    parameters:
    - id: map
      type: java.util.Map<E,java.lang.Boolean>
      description: the backing map
    return:
      type: java.util.Set<E>
      description: the set backed by the map
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newTreeSet()
  id: <E>newTreeSet()
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newTreeSet()
  nameWithType: Sets.<E>newTreeSet()
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newTreeSet()
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newTreeSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable*, empty `TreeSet` instance sorted by the natural sort ordering of its elements.


    **Note:** if mutability is not required, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSortedSet.&lt;E&gt;of()" data-throw-if-not-resolved="false">ImmutableSortedSet#of()</xref> instead.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `TreeSet` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static TreeSet<E> <E>newTreeSet()
    return:
      type: java.util.TreeSet<E>
      description: a new, empty <code>TreeSet</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newTreeSet(java.lang.Iterable<? extends E>)
  id: <E>newTreeSet(java.lang.Iterable<? extends E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newTreeSet(Iterable<? extends E> elements)
  nameWithType: Sets.<E>newTreeSet(Iterable<? extends E> elements)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newTreeSet(Iterable<? extends E> elements)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newTreeSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable* `TreeSet` instance containing the given elements sorted by their natural ordering.


    **Note:** if mutability is not required, use <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSortedSet.&lt;E&gt;copyOf(java.lang.Iterable&lt;? extends E&gt;)" data-throw-if-not-resolved="false">ImmutableSortedSet#copyOf(Iterable)</xref> instead.


    **Note:** If `elements` is a `SortedSet` with an explicit comparator, this method has different behavior than <xref uid="java.util.TreeSet.TreeSet*" data-throw-if-not-resolved="false">TreeSet#TreeSet(SortedSet)</xref>, which returns a `TreeSet` with that comparator.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `TreeSet` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax].


    This method is just a small convenience for creating an empty set and then calling <xref uid="com.azure.cosmos.implementation.guava25.collect.Iterables.addAll" data-throw-if-not-resolved="false">Iterables#addAll</xref>. This method is not very useful and will likely be deprecated in the future.



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static TreeSet<E> <E>newTreeSet(Iterable<? extends E> elements)
    parameters:
    - id: elements
      type: java.lang.Iterable<? extends E>
      description: the elements that the set should contain
    return:
      type: java.util.TreeSet<E>
      description: a new <code>TreeSet</code> containing those elements (minus duplicates)
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newTreeSet(java.util.Comparator<? super E>)
  id: <E>newTreeSet(java.util.Comparator<? super E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>newTreeSet(Comparator<? super E> comparator)
  nameWithType: Sets.<E>newTreeSet(Comparator<? super E> comparator)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newTreeSet(Comparator<? super E> comparator)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.newTreeSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Creates a *mutable*, empty `TreeSet` instance with the given comparator.


    **Note:** if mutability is not required, use `ImmutableSortedSet.orderedBy(comparator).build()` instead.


    **Note for Java 7 and later:** this method is now unnecessary and should be treated as deprecated. Instead, use the `TreeSet` constructor directly, taking advantage of the new ["diamond" syntax][diamond_ syntax]. One caveat to this is that the `TreeSet` constructor uses a null `Comparator` to mean "natural ordering," whereas this factory rejects null. Clean your code accordingly.



    [diamond_ syntax]: http://goo.gl/iz2Wi
  syntax:
    content: public static TreeSet<E> <E>newTreeSet(Comparator<? super E> comparator)
    parameters:
    - id: comparator
      type: java.util.Comparator<? super E>
      description: the comparator to use to sort the set
    return:
      type: java.util.TreeSet<E>
      description: a new, empty <code>TreeSet</code>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>powerSet(java.util.Set<E>)
  id: <E>powerSet(java.util.Set<E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>powerSet(Set<E> set)
  nameWithType: Sets.<E>powerSet(Set<E> set)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>powerSet(Set<E> set)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.powerSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns the set of all possible subsets of `set`. For example, `powerSet(ImmutableSet.of(1, 2))` returns the set `{{}, {1}, {2}, {1, 2}}`.


    Elements appear in these subsets in the same iteration order as they appeared in the input set. The order in which these subsets appear in the outer set is undefined. Note that the power set of the empty set is not the empty set, but a one-element set containing the empty set.


    The returned set and its constituent sets use `equals` to decide whether two elements are identical, even if the input set uses a different concept of equivalence.


    *Performance notes:* while the power set of a set with size `n` is of size `2^n`, its memory usage is only `O(n)`. When the power set is constructed, the input set is merely copied. Only as the power set is iterated are the individual subsets created, and these subsets themselves occupy only a small constant amount of memory.
  syntax:
    content: public static Set<Set<E>> <E>powerSet(Set<E> set)
    parameters:
    - id: set
      type: java.util.Set<E>
      description: the set of elements to construct a power set from
    return:
      type: java.util.Set<java.util.Set<E>>
      description: the power set, as an immutable set of immutable sets
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>symmetricDifference(java.util.Set<? extends E>,java.util.Set<? extends E>)
  id: <E>symmetricDifference(java.util.Set<? extends E>,java.util.Set<? extends E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>symmetricDifference(Set<? extends E> set1, Set<? extends E> set2)
  nameWithType: Sets.<E>symmetricDifference(Set<? extends E> set1, Set<? extends E> set2)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>symmetricDifference(Set<? extends E> set1, Set<? extends E> set2)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.symmetricDifference*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an unmodifiable **view** of the symmetric difference of two sets. The returned set contains all elements that are contained in either `set1` or `set2` but not in both. The iteration order of the returned set is undefined.


    Results are undefined if `set1` and `set2` are sets based on different equivalence relations (as `HashSet`, `TreeSet`, and the keySet of an `IdentityHashMap` all are).
  syntax:
    content: public static Sets.SetView<E> <E>symmetricDifference(Set<? extends E> set1, Set<? extends E> set2)
    parameters:
    - id: set1
      type: java.util.Set<? extends E>
    - id: set2
      type: java.util.Set<? extends E>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Sets.SetView<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>synchronizedNavigableSet(java.util.NavigableSet<E>)
  id: <E>synchronizedNavigableSet(java.util.NavigableSet<E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>synchronizedNavigableSet(NavigableSet<E> navigableSet)
  nameWithType: Sets.<E>synchronizedNavigableSet(NavigableSet<E> navigableSet)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>synchronizedNavigableSet(NavigableSet<E> navigableSet)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.synchronizedNavigableSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: "Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In order to guarantee serial access, it is critical that **all** access to the backing navigable set is accomplished through the returned navigable set (or its views).\n\nIt is imperative that the user manually synchronize on the returned sorted set when iterating over it or any of its `descendingSet`, `subSet`, `headSet`, or `tailSet` views.\n\n```java\nNavigableSet set = synchronizedNavigableSet(new TreeSet());\n  ...\n synchronized (set) {\n   // Must be in the synchronized block\n   Iterator it = set.iterator();\n   while (it.hasNext()) {\n     foo(it.next());\n   }\n }\n```\n\nor:\n\n```java\nNavigableSet set = synchronizedNavigableSet(new TreeSet());\n NavigableSet set2 = set.descendingSet().headSet(foo);\n  ...\n synchronized (set) { // Note: set, not set2!!!\n   // Must be in the synchronized block\n   Iterator it = set2.descendingIterator();\n   while (it.hasNext())\n     foo(it.next());\n   }\n \n }\n```\n\nFailure to follow this advice may result in non-deterministic behavior.\n\nThe returned navigable set will be serializable if the specified navigable set is serializable."
  syntax:
    content: public static NavigableSet<E> <E>synchronizedNavigableSet(NavigableSet<E> navigableSet)
    parameters:
    - id: navigableSet
      type: java.util.NavigableSet<E>
      description: the navigable set to be "wrapped" in a synchronized navigable set.
    return:
      type: java.util.NavigableSet<E>
      description: a synchronized view of the specified navigable set.
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>toImmutableEnumSet()
  id: <E>toImmutableEnumSet()
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>toImmutableEnumSet()
  nameWithType: Sets.<E>toImmutableEnumSet()
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>toImmutableEnumSet()
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.toImmutableEnumSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: Returns a `Collector` that accumulates the input elements into a new `ImmutableSet` with an implementation specialized for enums. Unlike <xref uid="com.azure.cosmos.implementation.guava25.collect.ImmutableSet.toImmutableSet" data-throw-if-not-resolved="false">ImmutableSet#toImmutableSet</xref>, the resulting set will iterate over elements in their enum definition order, not encounter order.
  syntax:
    content: public static Collector<E,?,ImmutableSet<E>> <E>toImmutableEnumSet()
    return:
      type: java.util.stream.Collector<E,?,com.azure.cosmos.implementation.guava25.collect.ImmutableSet<E>>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>union(java.util.Set<? extends E>,java.util.Set<? extends E>)
  id: <E>union(java.util.Set<? extends E>,java.util.Set<? extends E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>union(Set<? extends E> set1, Set<? extends E> set2)
  nameWithType: Sets.<E>union(Set<? extends E> set1, Set<? extends E> set2)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>union(Set<? extends E> set1, Set<? extends E> set2)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.union*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an unmodifiable **view** of the union of two sets. The returned set contains all elements that are contained in either backing set. Iterating over the returned set iterates first over all the elements of `set1`, then over each element of `set2`, in order, that is not contained in `set1`.


    Results are undefined if `set1` and `set2` are sets based on different equivalence relations (as <xref uid="java.util.HashSet" data-throw-if-not-resolved="false">HashSet</xref>, <xref uid="java.util.TreeSet" data-throw-if-not-resolved="false">TreeSet</xref>, and the <xref uid="java.util.Map.keySet" data-throw-if-not-resolved="false">Map#keySet</xref> of an `IdentityHashMap` all are).
  syntax:
    content: public static Sets.SetView<E> <E>union(Set<? extends E> set1, Set<? extends E> set2)
    parameters:
    - id: set1
      type: java.util.Set<? extends E>
    - id: set2
      type: java.util.Set<? extends E>
    return:
      type: com.azure.cosmos.implementation.guava25.collect.Sets.SetView<E>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<E>unmodifiableNavigableSet(java.util.NavigableSet<E>)
  id: <E>unmodifiableNavigableSet(java.util.NavigableSet<E>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <E>unmodifiableNavigableSet(NavigableSet<E> set)
  nameWithType: Sets.<E>unmodifiableNavigableSet(NavigableSet<E> set)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>unmodifiableNavigableSet(NavigableSet<E> set)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.unmodifiableNavigableSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns an unmodifiable view of the specified navigable set. This method allows modules to provide users with "read-only" access to internal navigable sets. Query operations on the returned set "read through" to the specified set, and attempts to modify the returned set, whether direct or via its collection views, result in an `UnsupportedOperationException`.


    The returned navigable set will be serializable if the specified navigable set is serializable.
  syntax:
    content: public static NavigableSet<E> <E>unmodifiableNavigableSet(NavigableSet<E> set)
    parameters:
    - id: set
      type: java.util.NavigableSet<E>
      description: the navigable set for which an unmodifiable view is to be returned
    return:
      type: java.util.NavigableSet<E>
      description: an unmodifiable view of the specified navigable set
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.<K>subSet(java.util.NavigableSet<K>,com.azure.cosmos.implementation.guava25.collect.Range<K>)
  id: <K>subSet(java.util.NavigableSet<K>,com.azure.cosmos.implementation.guava25.collect.Range<K>)
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: <K>subSet(NavigableSet<K> set, Range<K> range)
  nameWithType: Sets.<K>subSet(NavigableSet<K> set, Range<K> range)
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<K>subSet(NavigableSet<K> set, Range<K> range)
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.subSet*
  type: Method
  package: com.azure.cosmos.implementation.guava25.collect
  summary: >-
    Returns a view of the portion of `set` whose elements are contained by `range`.


    This method delegates to the appropriate methods of <xref uid="java.util.NavigableSet" data-throw-if-not-resolved="false">NavigableSet</xref> (namely <xref uid="java.util.NavigableSet.subSet*" data-throw-if-not-resolved="false">subSet()</xref>, <xref uid="java.util.NavigableSet.tailSet*" data-throw-if-not-resolved="false">tailSet()</xref>, and <xref uid="NavigableSet#headSet(Object,
     boolean)" data-throw-if-not-resolved="false">headSet()</xref>) to actually construct the view. Consult these methods for a full description of the returned view's behavior.

    **Warning:** `Range`s always represent a range of values using the values' natural ordering. `NavigableSet` on the other hand can specify a custom ordering via a <xref uid="java.util.Comparator" data-throw-if-not-resolved="false">Comparator</xref>, which can violate the natural ordering. Using this method (or in general using `Range`) with unnaturally-ordered sets can lead to unexpected and undefined behavior.
  syntax:
    content: public static NavigableSet<K> <K>subSet(NavigableSet<K> set, Range<K> range)
    parameters:
    - id: set
      type: java.util.NavigableSet<K>
    - id: range
      type: com.azure.cosmos.implementation.guava25.collect.Range<K>
    return:
      type: java.util.NavigableSet<K>
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.Sets()
  id: Sets()
  artifact: com.azure:azure-cosmos:4.4.0-beta.1
  parent: com.azure.cosmos.implementation.guava25.collect.Sets
  langs:
  - java
  name: Sets()
  nameWithType: Sets.Sets()
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.Sets()
  overload: com.azure.cosmos.implementation.guava25.collect.Sets.Sets*
  type: Constructor
  package: com.azure.cosmos.implementation.guava25.collect
  syntax:
    content: private Sets()
references:
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.Sets*
  name: Sets
  nameWithType: Sets.Sets
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.Sets
  package: com.azure.cosmos.implementation.guava25.collect
- uid: E
  spec.java:
  - uid: E
    name: E
    fullName: E
- uid: E[]
  spec.java:
  - uid: E
    name: E
    fullName: E
  - name: '[]'
    fullName: '[]'
- uid: com.azure.cosmos.implementation.guava25.collect.ImmutableSet<E>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.ImmutableSet
    name: ImmutableSet
    fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableSet
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.immutableEnumSet*
  name: <E>immutableEnumSet
  nameWithType: Sets.<E>immutableEnumSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>immutableEnumSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.lang.Iterable<E>
  spec.java:
  - uid: java.lang.Iterable
    name: Iterable
    fullName: java.lang.Iterable
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: java.util.stream.Collector<E,?,com.azure.cosmos.implementation.guava25.collect.ImmutableSet<E>>
  spec.java:
  - uid: java.util.stream.Collector
    name: Collector
    fullName: java.util.stream.Collector
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: ','
    fullName: ','
  - uid: '?'
    name: '?'
    fullName: '?'
  - name: ','
    fullName: ','
  - uid: com.azure.cosmos.implementation.guava25.collect.ImmutableSet
    name: ImmutableSet
    fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableSet
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.toImmutableEnumSet*
  name: <E>toImmutableEnumSet
  nameWithType: Sets.<E>toImmutableEnumSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>toImmutableEnumSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.lang.Class<E>
  spec.java:
  - uid: java.lang.Class
    name: Class
    fullName: java.lang.Class
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: java.util.EnumSet<E>
  spec.java:
  - uid: java.util.EnumSet
    name: EnumSet
    fullName: java.util.EnumSet
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.newEnumSet*
  name: <E>newEnumSet
  nameWithType: Sets.<E>newEnumSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newEnumSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.HashSet<E>
  spec.java:
  - uid: java.util.HashSet
    name: HashSet
    fullName: java.util.HashSet
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.newHashSet*
  name: <E>newHashSet
  nameWithType: Sets.<E>newHashSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.lang.Iterable<? extends E>
  spec.java:
  - uid: java.lang.Iterable
    name: Iterable
    fullName: java.lang.Iterable
  - name: <
    fullName: <
  - uid: '? extends E'
    name: '? extends E'
    fullName: '? extends E'
  - name: '>'
    fullName: '>'
- uid: java.util.Iterator<? extends E>
  spec.java:
  - uid: java.util.Iterator
    name: Iterator
    fullName: java.util.Iterator
  - name: <
    fullName: <
  - uid: '? extends E'
    name: '? extends E'
    fullName: '? extends E'
  - name: '>'
    fullName: '>'
- uid: int
  spec.java:
  - uid: int
    name: int
    fullName: int
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.newHashSetWithExpectedSize*
  name: <E>newHashSetWithExpectedSize
  nameWithType: Sets.<E>newHashSetWithExpectedSize
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newHashSetWithExpectedSize
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Set<E>
  spec.java:
  - uid: java.util.Set
    name: Set
    fullName: java.util.Set
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.newConcurrentHashSet*
  name: <E>newConcurrentHashSet
  nameWithType: Sets.<E>newConcurrentHashSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newConcurrentHashSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.LinkedHashSet<E>
  spec.java:
  - uid: java.util.LinkedHashSet
    name: LinkedHashSet
    fullName: java.util.LinkedHashSet
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.newLinkedHashSet*
  name: <E>newLinkedHashSet
  nameWithType: Sets.<E>newLinkedHashSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newLinkedHashSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.newLinkedHashSetWithExpectedSize*
  name: <E>newLinkedHashSetWithExpectedSize
  nameWithType: Sets.<E>newLinkedHashSetWithExpectedSize
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newLinkedHashSetWithExpectedSize
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.TreeSet<E>
  spec.java:
  - uid: java.util.TreeSet
    name: TreeSet
    fullName: java.util.TreeSet
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.newTreeSet*
  name: <E>newTreeSet
  nameWithType: Sets.<E>newTreeSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newTreeSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Comparator<? super E>
  spec.java:
  - uid: java.util.Comparator
    name: Comparator
    fullName: java.util.Comparator
  - name: <
    fullName: <
  - uid: '? super E'
    name: '? super E'
    fullName: '? super E'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.newIdentityHashSet*
  name: <E>newIdentityHashSet
  nameWithType: Sets.<E>newIdentityHashSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newIdentityHashSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.concurrent.CopyOnWriteArraySet<E>
  spec.java:
  - uid: java.util.concurrent.CopyOnWriteArraySet
    name: CopyOnWriteArraySet
    fullName: java.util.concurrent.CopyOnWriteArraySet
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.newCopyOnWriteArraySet*
  name: <E>newCopyOnWriteArraySet
  nameWithType: Sets.<E>newCopyOnWriteArraySet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newCopyOnWriteArraySet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Collection<E>
  spec.java:
  - uid: java.util.Collection
    name: Collection
    fullName: java.util.Collection
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.complementOf*
  name: <E>complementOf
  nameWithType: Sets.<E>complementOf
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>complementOf
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Map<E,java.lang.Boolean>
  spec.java:
  - uid: java.util.Map
    name: Map
    fullName: java.util.Map
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: ','
    fullName: ','
  - uid: java.lang.Boolean
    name: Boolean
    fullName: java.lang.Boolean
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.newSetFromMap*
  name: <E>newSetFromMap
  nameWithType: Sets.<E>newSetFromMap
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>newSetFromMap
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Set<? extends E>
  spec.java:
  - uid: java.util.Set
    name: Set
    fullName: java.util.Set
  - name: <
    fullName: <
  - uid: '? extends E'
    name: '? extends E'
    fullName: '? extends E'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.SetView<E>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.Sets.SetView
    name: SetView
    fullName: com.azure.cosmos.implementation.guava25.collect.Sets.SetView
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.union*
  name: <E>union
  nameWithType: Sets.<E>union
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>union
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Set<?>
  spec.java:
  - uid: java.util.Set
    name: Set
    fullName: java.util.Set
  - name: <
    fullName: <
  - uid: '?'
    name: '?'
    fullName: '?'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.intersection*
  name: <E>intersection
  nameWithType: Sets.<E>intersection
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>intersection
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.difference*
  name: <E>difference
  nameWithType: Sets.<E>difference
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>difference
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.symmetricDifference*
  name: <E>symmetricDifference
  nameWithType: Sets.<E>symmetricDifference
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>symmetricDifference
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.base.Predicate<? super E>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.base.Predicate
    name: Predicate
    fullName: com.azure.cosmos.implementation.guava25.base.Predicate
  - name: <
    fullName: <
  - uid: '? super E'
    name: '? super E'
    fullName: '? super E'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.filter*
  name: <E>filter
  nameWithType: Sets.<E>filter
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>filter
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.SortedSet<E>
  spec.java:
  - uid: java.util.SortedSet
    name: SortedSet
    fullName: java.util.SortedSet
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: java.util.NavigableSet<E>
  spec.java:
  - uid: java.util.NavigableSet
    name: NavigableSet
    fullName: java.util.NavigableSet
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
- uid: java.util.List<? extends java.util.Set<? extends B>>
  spec.java:
  - uid: java.util.List
    name: List
    fullName: java.util.List
  - name: <
    fullName: <
  - uid: '? extends java.util.Set'
    name: Set
    fullName: '? extends java.util.Set'
  - name: <
    fullName: <
  - uid: '? extends B'
    name: '? extends B'
    fullName: '? extends B'
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: java.util.Set<java.util.List<B>>
  spec.java:
  - uid: java.util.Set
    name: Set
    fullName: java.util.Set
  - name: <
    fullName: <
  - uid: java.util.List
    name: List
    fullName: java.util.List
  - name: <
    fullName: <
  - uid: B
    name: B
    fullName: B
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.cartesianProduct*
  name: <B>cartesianProduct
  nameWithType: Sets.<B>cartesianProduct
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<B>cartesianProduct
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.Set<? extends B>[]
  spec.java:
  - uid: java.util.Set
    name: Set
    fullName: java.util.Set
  - name: <
    fullName: <
  - uid: '? extends B'
    name: '? extends B'
    fullName: '? extends B'
  - name: '>'
    fullName: '>'
  - name: '[]'
    fullName: '[]'
- uid: java.util.Set<java.util.Set<E>>
  spec.java:
  - uid: java.util.Set
    name: Set
    fullName: java.util.Set
  - name: <
    fullName: <
  - uid: java.util.Set
    name: Set
    fullName: java.util.Set
  - name: <
    fullName: <
  - uid: E
    name: E
    fullName: E
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.powerSet*
  name: <E>powerSet
  nameWithType: Sets.<E>powerSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>powerSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.combinations*
  name: <E>combinations
  nameWithType: Sets.<E>combinations
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>combinations
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.unmodifiableNavigableSet*
  name: <E>unmodifiableNavigableSet
  nameWithType: Sets.<E>unmodifiableNavigableSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>unmodifiableNavigableSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.synchronizedNavigableSet*
  name: <E>synchronizedNavigableSet
  nameWithType: Sets.<E>synchronizedNavigableSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<E>synchronizedNavigableSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.util.NavigableSet<K>
  spec.java:
  - uid: java.util.NavigableSet
    name: NavigableSet
    fullName: java.util.NavigableSet
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Range<K>
  spec.java:
  - uid: com.azure.cosmos.implementation.guava25.collect.Range
    name: Range
    fullName: com.azure.cosmos.implementation.guava25.collect.Range
  - name: <
    fullName: <
  - uid: K
    name: K
    fullName: K
  - name: '>'
    fullName: '>'
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.subSet*
  name: <K>subSet
  nameWithType: Sets.<K>subSet
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.<K>subSet
  package: com.azure.cosmos.implementation.guava25.collect
- uid: java.lang.Object.notify()
  name: Object.notify()
  nameWithType: Object.notify()
  fullName: java.lang.Object.notify()
- uid: java.lang.Object.wait()
  name: Object.wait()
  nameWithType: Object.wait()
  fullName: java.lang.Object.wait()
- uid: java.lang.Object.finalize()
  name: Object.finalize()
  nameWithType: Object.finalize()
  fullName: java.lang.Object.finalize()
- uid: java.lang.Object.clone()
  name: Object.clone()
  nameWithType: Object.clone()
  fullName: java.lang.Object.clone()
- uid: java.lang.Object.notifyAll()
  name: Object.notifyAll()
  nameWithType: Object.notifyAll()
  fullName: java.lang.Object.notifyAll()
- uid: java.lang.Object.equals(java.lang.Object)
  name: Object.equals(Object)
  nameWithType: Object.equals(Object)
  fullName: java.lang.Object.equals(java.lang.Object)
- uid: java.lang.Object.getClass()
  name: Object.getClass()
  nameWithType: Object.getClass()
  fullName: java.lang.Object.getClass()
- uid: java.lang.Object.wait(long)
  name: Object.wait(long)
  nameWithType: Object.wait(long)
  fullName: java.lang.Object.wait(long)
- uid: java.lang.Object.hashCode()
  name: Object.hashCode()
  nameWithType: Object.hashCode()
  fullName: java.lang.Object.hashCode()
- uid: java.lang.Object.wait(long,int)
  name: Object.wait(long,int)
  nameWithType: Object.wait(long,int)
  fullName: java.lang.Object.wait(long,int)
- uid: java.lang.Object.toString()
  name: Object.toString()
  nameWithType: Object.toString()
  fullName: java.lang.Object.toString()
- uid: com.azure.cosmos.implementation.guava25.collect.Sets.SetView
  name: Sets.SetView<E>
  nameWithType: Sets.SetView<E>
  fullName: com.azure.cosmos.implementation.guava25.collect.Sets.SetView<E>
- uid: com.azure.cosmos.implementation.guava25.collect.ImmutableSet
  name: ImmutableSet
  nameWithType: ImmutableSet
  fullName: com.azure.cosmos.implementation.guava25.collect.ImmutableSet
- uid: java.lang.Iterable
  name: Iterable
  nameWithType: Iterable
  fullName: java.lang.Iterable
- uid: java.util.stream.Collector
  name: Collector
  nameWithType: Collector
  fullName: java.util.stream.Collector
- uid: E,?,com.azure.cosmos.implementation.guava25.collect.ImmutableSet
  name: E,?,ImmutableSet
  nameWithType: E,?,ImmutableSet
  fullName: E,?,com.azure.cosmos.implementation.guava25.collect.ImmutableSet
- uid: java.lang.Class
  name: Class
  nameWithType: Class
  fullName: java.lang.Class
- uid: java.util.EnumSet
  name: EnumSet
  nameWithType: EnumSet
  fullName: java.util.EnumSet
- uid: java.util.HashSet
  name: HashSet
  nameWithType: HashSet
  fullName: java.util.HashSet
- uid: '? extends E'
  name: '? extends E'
  nameWithType: '? extends E'
  fullName: '? extends E'
- uid: java.util.Iterator
  name: Iterator
  nameWithType: Iterator
  fullName: java.util.Iterator
- uid: java.util.Set
  name: Set
  nameWithType: Set
  fullName: java.util.Set
- uid: java.util.LinkedHashSet
  name: LinkedHashSet
  nameWithType: LinkedHashSet
  fullName: java.util.LinkedHashSet
- uid: java.util.TreeSet
  name: TreeSet
  nameWithType: TreeSet
  fullName: java.util.TreeSet
- uid: '? super E'
  name: '? super E'
  nameWithType: '? super E'
  fullName: '? super E'
- uid: java.util.Comparator
  name: Comparator
  nameWithType: Comparator
  fullName: java.util.Comparator
- uid: java.util.concurrent.CopyOnWriteArraySet
  name: CopyOnWriteArraySet
  nameWithType: CopyOnWriteArraySet
  fullName: java.util.concurrent.CopyOnWriteArraySet
- uid: java.util.Collection
  name: Collection
  nameWithType: Collection
  fullName: java.util.Collection
- uid: E,java.lang.Boolean
  name: E,Boolean
  nameWithType: E,Boolean
  fullName: E,java.lang.Boolean
- uid: java.util.Map
  name: Map
  nameWithType: Map
  fullName: java.util.Map
- uid: '?'
  name: '?'
  nameWithType: '?'
  fullName: '?'
- uid: com.azure.cosmos.implementation.guava25.base.Predicate
  name: Predicate
  nameWithType: Predicate
  fullName: com.azure.cosmos.implementation.guava25.base.Predicate
- uid: java.util.SortedSet
  name: SortedSet
  nameWithType: SortedSet
  fullName: java.util.SortedSet
- uid: java.util.NavigableSet
  name: NavigableSet
  nameWithType: NavigableSet
  fullName: java.util.NavigableSet
- uid: java.util.List
  name: List
  nameWithType: List
  fullName: java.util.List
- uid: '? extends B'
  name: '? extends B'
  nameWithType: '? extends B'
  fullName: '? extends B'
- uid: '? extends java.util.Set'
  name: '? extends Set'
  nameWithType: '? extends Set'
  fullName: '? extends java.util.Set'
- uid: B
  name: B
  nameWithType: B
  fullName: B
- uid: '? extends B>[]'
  name: '? extends B>[]'
  nameWithType: '? extends B>[]'
  fullName: '? extends B>[]'
- uid: K
  name: K
  nameWithType: K
  fullName: K
- uid: com.azure.cosmos.implementation.guava25.collect.Range
  name: Range
  nameWithType: Range
  fullName: com.azure.cosmos.implementation.guava25.collect.Range
