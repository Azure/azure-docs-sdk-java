### YamlMime:JavaType
uid: "com.azure.search.documents.SearchAsyncClient"
fullName: "com.azure.search.documents.SearchAsyncClient"
name: "SearchAsyncClient"
nameWithType: "SearchAsyncClient"
summary: "This class provides a client that contains the operations for querying an index and uploading, merging, or deleting documents in an Azure AI Search service."
inheritances:
- "<xref href=\"java.lang.Object?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
inheritedClassMethods:
- classRef: "java.lang.<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html\">Object</a>"
  methodsRef:
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--\">clone</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-\">equals</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize--\">finalize</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--\">getClass</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--\">hashCode</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify--\">notify</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll--\">notifyAll</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--\">toString</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--\">wait</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait-long-\">wait</a>"
  - "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait-long-int-\">wait</a>"
syntax: "public final class **SearchAsyncClient**"
methods:
- uid: "com.azure.search.documents.SearchAsyncClient.<T>getDocument(java.lang.String,java.lang.Class<T>)"
  fullName: "com.azure.search.documents.SearchAsyncClient.getDocument(String key, Class<T> modelClass)"
  name: "getDocument(String key, Class<T> modelClass)"
  nameWithType: "SearchAsyncClient.getDocument(String key, Class<T> modelClass)"
  summary: "Retrieves a document from the Azure AI Search index."
  parameters:
  - description: "The key of the document to retrieve."
    name: "key"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "The model class converts to."
    name: "modelClass"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html\">Class</a>&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public Mono<T> <T>getDocument(String key, Class<T> modelClass)"
  desc: "Retrieves a document from the Azure AI Search index.\n\nView [naming rules][] for guidelines on constructing valid document keys.\n\n**Code Sample**\n\nGet dynamic SearchDocument.\n\n```java\nSEARCH_ASYNC_CLIENT.getDocument(\"hotelId\", SearchDocument.class)\n     .subscribe(result -> {\n         for (Map.Entry<String, Object> keyValuePair : result.entrySet()) {\n             System.out.printf(\"Document key %s, Document value %s\", keyValuePair.getKey(),\n                 keyValuePair.getValue());\n         }\n     });\n```\n\n\n[naming rules]: https://docs.microsoft.com/rest/api/searchservice/Naming-rules"
  returns:
    description: "the document object"
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.<T>getDocument(java.lang.String,java.lang.Class<T>,java.lang.String)"
  fullName: "com.azure.search.documents.SearchAsyncClient.getDocument(String key, Class<T> modelClass, String querySourceAuthorization)"
  name: "getDocument(String key, Class<T> modelClass, String querySourceAuthorization)"
  nameWithType: "SearchAsyncClient.getDocument(String key, Class<T> modelClass, String querySourceAuthorization)"
  summary: "Retrieves a document from the Azure AI Search index."
  parameters:
  - description: "The key of the document to retrieve."
    name: "key"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "The model class converts to."
    name: "modelClass"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html\">Class</a>&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "Token identifying the user for which the query is being executed.\n This token is used to enforce security restrictions on documents."
    name: "querySourceAuthorization"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  syntax: "public Mono<T> <T>getDocument(String key, Class<T> modelClass, String querySourceAuthorization)"
  desc: "Retrieves a document from the Azure AI Search index.\n\nView [naming rules][] for guidelines on constructing valid document keys.\n\n**Code Sample**\n\nGet dynamic SearchDocument.\n\n```java\nSEARCH_ASYNC_CLIENT.getDocument(\"hotelId\", SearchDocument.class)\n     .subscribe(result -> {\n         for (Map.Entry<String, Object> keyValuePair : result.entrySet()) {\n             System.out.printf(\"Document key %s, Document value %s\", keyValuePair.getKey(),\n                 keyValuePair.getValue());\n         }\n     });\n```\n\n\n[naming rules]: https://docs.microsoft.com/rest/api/searchservice/Naming-rules"
  returns:
    description: "the document object"
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.<T>getDocumentWithResponse(java.lang.String,java.lang.Class<T>,java.util.List<java.lang.String>)"
  fullName: "com.azure.search.documents.SearchAsyncClient.getDocumentWithResponse(String key, Class<T> modelClass, List<String> selectedFields)"
  name: "getDocumentWithResponse(String key, Class<T> modelClass, List<String> selectedFields)"
  nameWithType: "SearchAsyncClient.getDocumentWithResponse(String key, Class<T> modelClass, List<String> selectedFields)"
  summary: "Retrieves a document from the Azure AI Search index."
  parameters:
  - description: "The key of the document to retrieve."
    name: "key"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "The model class converts to."
    name: "modelClass"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html\">Class</a>&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "List of field names to retrieve for the document; Any field not retrieved will have null or\n default as its corresponding property value in the returned object."
    name: "selectedFields"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/List.html\">List</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>&gt;"
  syntax: "public Mono<Response<T>> <T>getDocumentWithResponse(String key, Class<T> modelClass, List<String> selectedFields)"
  desc: "Retrieves a document from the Azure AI Search index.\n\nView [naming rules][] for guidelines on constructing valid document keys.\n\n**Code Sample**\n\nGet dynamic SearchDocument.\n\n```java\nSEARCH_ASYNC_CLIENT.getDocumentWithResponse(\"hotelId\", SearchDocument.class, null)\n     .subscribe(resultResponse -> {\n         System.out.println(\"The status code of the response is \" + resultResponse.getStatusCode());\n         for (Map.Entry<String, Object> keyValuePair : resultResponse.getValue().entrySet()) {\n             System.out.printf(\"Document key %s, Document value %s\", keyValuePair.getKey(),\n                 keyValuePair.getValue());\n         }\n     });\n```\n\n\n[naming rules]: https://docs.microsoft.com/rest/api/searchservice/Naming-rules"
  returns:
    description: "a response containing the document object"
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.<T>getDocumentWithResponse(java.lang.String,java.lang.Class<T>,java.util.List<java.lang.String>,java.lang.String)"
  fullName: "com.azure.search.documents.SearchAsyncClient.getDocumentWithResponse(String key, Class<T> modelClass, List<String> selectedFields, String querySourceAuthorization)"
  name: "getDocumentWithResponse(String key, Class<T> modelClass, List<String> selectedFields, String querySourceAuthorization)"
  nameWithType: "SearchAsyncClient.getDocumentWithResponse(String key, Class<T> modelClass, List<String> selectedFields, String querySourceAuthorization)"
  summary: "Retrieves a document from the Azure AI Search index."
  parameters:
  - description: "The key of the document to retrieve."
    name: "key"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "The model class converts to."
    name: "modelClass"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html\">Class</a>&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "List of field names to retrieve for the document; Any field not retrieved will have null or\n default as its corresponding property value in the returned object."
    name: "selectedFields"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/List.html\">List</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>&gt;"
  - description: "Token identifying the user for which the query is being executed.\n This token is used to enforce security restrictions on documents."
    name: "querySourceAuthorization"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  syntax: "public Mono<Response<T>> <T>getDocumentWithResponse(String key, Class<T> modelClass, List<String> selectedFields, String querySourceAuthorization)"
  desc: "Retrieves a document from the Azure AI Search index.\n\nView [naming rules][] for guidelines on constructing valid document keys.\n\n**Code Sample**\n\nGet dynamic SearchDocument.\n\n```java\nSEARCH_ASYNC_CLIENT.getDocumentWithResponse(\"hotelId\", SearchDocument.class, null)\n     .subscribe(resultResponse -> {\n         System.out.println(\"The status code of the response is \" + resultResponse.getStatusCode());\n         for (Map.Entry<String, Object> keyValuePair : resultResponse.getValue().entrySet()) {\n             System.out.printf(\"Document key %s, Document value %s\", keyValuePair.getKey(),\n                 keyValuePair.getValue());\n         }\n     });\n```\n\n\n[naming rules]: https://docs.microsoft.com/rest/api/searchservice/Naming-rules"
  returns:
    description: "a response containing the document object"
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.autocomplete(java.lang.String,java.lang.String)"
  fullName: "com.azure.search.documents.SearchAsyncClient.autocomplete(String searchText, String suggesterName)"
  name: "autocomplete(String searchText, String suggesterName)"
  nameWithType: "SearchAsyncClient.autocomplete(String searchText, String suggesterName)"
  summary: "Autocompletes incomplete query terms based on input text and matching terms in the index."
  parameters:
  - description: "search text"
    name: "searchText"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "suggester name"
    name: "suggesterName"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  syntax: "public AutocompletePagedFlux autocomplete(String searchText, String suggesterName)"
  desc: "Autocompletes incomplete query terms based on input text and matching terms in the index.\n\n**Code Sample**\n\nAutocomplete text from documents in service.\n\n```java\nSEARCH_ASYNC_CLIENT.autocomplete(\"searchText\", \"sg\")\n     .subscribe(result -> System.out.printf(\"The complete term is %s\", result.getText()));\n```"
  returns:
    description: "auto complete result."
    type: "<xref href=\"com.azure.search.documents.util.AutocompletePagedFlux?alt=com.azure.search.documents.util.AutocompletePagedFlux&text=AutocompletePagedFlux\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.search.documents.SearchAsyncClient.autocomplete(java.lang.String,java.lang.String,com.azure.search.documents.models.AutocompleteOptions)"
  fullName: "com.azure.search.documents.SearchAsyncClient.autocomplete(String searchText, String suggesterName, AutocompleteOptions autocompleteOptions)"
  name: "autocomplete(String searchText, String suggesterName, AutocompleteOptions autocompleteOptions)"
  nameWithType: "SearchAsyncClient.autocomplete(String searchText, String suggesterName, AutocompleteOptions autocompleteOptions)"
  summary: "Autocompletes incomplete query terms based on input text and matching terms in the index."
  parameters:
  - description: "search text"
    name: "searchText"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "suggester name"
    name: "suggesterName"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "autocomplete options"
    name: "autocompleteOptions"
    type: "<xref href=\"com.azure.search.documents.models.AutocompleteOptions?alt=com.azure.search.documents.models.AutocompleteOptions&text=AutocompleteOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public AutocompletePagedFlux autocomplete(String searchText, String suggesterName, AutocompleteOptions autocompleteOptions)"
  desc: "Autocompletes incomplete query terms based on input text and matching terms in the index.\n\n**Code Sample**\n\nAutocomplete text from documents in service with option.\n\n```java\nSEARCH_ASYNC_CLIENT.autocomplete(\"searchText\", \"sg\",\n     new AutocompleteOptions().setAutocompleteMode(AutocompleteMode.ONE_TERM_WITH_CONTEXT))\n     .subscribe(result ->\n         System.out.printf(\"The complete term is %s\", result.getText())\n     );\n```"
  returns:
    description: "auto complete result."
    type: "<xref href=\"com.azure.search.documents.util.AutocompletePagedFlux?alt=com.azure.search.documents.util.AutocompletePagedFlux&text=AutocompletePagedFlux\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.search.documents.SearchAsyncClient.deleteDocuments(java.lang.Iterable<?>)"
  fullName: "com.azure.search.documents.SearchAsyncClient.deleteDocuments(Iterable<?> documents)"
  name: "deleteDocuments(Iterable<?> documents)"
  nameWithType: "SearchAsyncClient.deleteDocuments(Iterable<?> documents)"
  summary: "Deletes a collection of documents from the target index."
  parameters:
  - description: "collection of documents to delete from the target Index. Fields other than the key are ignored."
    name: "documents"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html\">Iterable</a>&lt;?&gt;"
  syntax: "public Mono<IndexDocumentsResult> deleteDocuments(Iterable<?> documents)"
  desc: "Deletes a collection of documents from the target index.\n\n**Code Sample**\n\nDelete dynamic SearchDocument.\n\n```java\nSearchDocument searchDocument = new SearchDocument();\n searchDocument.put(\"hotelId\", \"1\");\n searchDocument.put(\"hotelName\", \"test\");\n SEARCH_ASYNC_CLIENT.deleteDocuments(Collections.singletonList(searchDocument))\n     .subscribe(result -> {\n         for (IndexingResult indexingResult : result.getResults()) {\n             System.out.printf(\"Does document with key %s delete successfully? %b%n\", indexingResult.getKey(),\n                 indexingResult.isSucceeded());\n         }\n     });\n```"
  returns:
    description: "document index result."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.search.documents.models.IndexDocumentsResult?alt=com.azure.search.documents.models.IndexDocumentsResult&text=IndexDocumentsResult\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.deleteDocumentsWithResponse(java.lang.Iterable<?>,com.azure.search.documents.models.IndexDocumentsOptions)"
  fullName: "com.azure.search.documents.SearchAsyncClient.deleteDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  name: "deleteDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  nameWithType: "SearchAsyncClient.deleteDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  summary: "Deletes a collection of documents from the target index."
  parameters:
  - description: "collection of documents to delete from the target Index. Fields other than the key are ignored."
    name: "documents"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html\">Iterable</a>&lt;?&gt;"
  - description: "Options that allow specifying document indexing behavior."
    name: "options"
    type: "<xref href=\"com.azure.search.documents.models.IndexDocumentsOptions?alt=com.azure.search.documents.models.IndexDocumentsOptions&text=IndexDocumentsOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<IndexDocumentsResult>> deleteDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  desc: "Deletes a collection of documents from the target index.\n\n**Code Sample**\n\nDelete dynamic SearchDocument.\n\n```java\nSearchDocument searchDocument = new SearchDocument();\n searchDocument.put(\"hotelId\", \"1\");\n searchDocument.put(\"hotelName\", \"test\");\n searchAsyncClient.deleteDocumentsWithResponse(Collections.singletonList(searchDocument), null)\n     .subscribe(resultResponse -> {\n         System.out.println(\"The status code of the response is \" + resultResponse.getStatusCode());\n         for (IndexingResult indexingResult : resultResponse.getValue().getResults()) {\n             System.out.printf(\"Does document with key %s delete successfully? %b%n\", indexingResult.getKey(),\n                 indexingResult.isSucceeded());\n         }\n     });\n```"
  returns:
    description: "response containing the document index result."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.search.documents.models.IndexDocumentsResult?alt=com.azure.search.documents.models.IndexDocumentsResult&text=IndexDocumentsResult\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.getDocumentCount()"
  fullName: "com.azure.search.documents.SearchAsyncClient.getDocumentCount()"
  name: "getDocumentCount()"
  nameWithType: "SearchAsyncClient.getDocumentCount()"
  summary: "Queries the number of documents in the search index."
  syntax: "public Mono<Long> getDocumentCount()"
  desc: "Queries the number of documents in the search index.\n\n**Code Sample**\n\nGet document count.\n\n```java\nSEARCH_ASYNC_CLIENT.getDocumentCount()\n     .subscribe(count -> System.out.printf(\"There are %d documents in service.\", count));\n```"
  returns:
    description: "the number of documents."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html\">Long</a>&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.getDocumentCountWithResponse()"
  fullName: "com.azure.search.documents.SearchAsyncClient.getDocumentCountWithResponse()"
  name: "getDocumentCountWithResponse()"
  nameWithType: "SearchAsyncClient.getDocumentCountWithResponse()"
  summary: "Queries the number of documents in the search index."
  syntax: "public Mono<Response<Long>> getDocumentCountWithResponse()"
  desc: "Queries the number of documents in the search index.\n\n**Code Sample**\n\nGet document count.\n\n```java\nSEARCH_ASYNC_CLIENT.getDocumentCountWithResponse()\n     .subscribe(countResponse -> {\n         System.out.println(\"The status code of the response is \" + countResponse.getStatusCode());\n         System.out.printf(\"There are %d documents in service.\", countResponse.getValue());\n     });\n```"
  returns:
    description: "response containing the number of documents."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html\">Long</a>&gt;&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.getEndpoint()"
  fullName: "com.azure.search.documents.SearchAsyncClient.getEndpoint()"
  name: "getEndpoint()"
  nameWithType: "SearchAsyncClient.getEndpoint()"
  summary: "Gets the endpoint for the Azure AI Search service."
  syntax: "public String getEndpoint()"
  desc: "Gets the endpoint for the Azure AI Search service."
  returns:
    description: "the endpoint value."
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
- uid: "com.azure.search.documents.SearchAsyncClient.getIndexName()"
  fullName: "com.azure.search.documents.SearchAsyncClient.getIndexName()"
  name: "getIndexName()"
  nameWithType: "SearchAsyncClient.getIndexName()"
  summary: "Gets the name of the Azure AI Search index."
  syntax: "public String getIndexName()"
  desc: "Gets the name of the Azure AI Search index."
  returns:
    description: "the indexName value."
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
- uid: "com.azure.search.documents.SearchAsyncClient.indexDocuments(com.azure.search.documents.indexes.models.IndexDocumentsBatch<?>)"
  fullName: "com.azure.search.documents.SearchAsyncClient.indexDocuments(IndexDocumentsBatch<?> batch)"
  name: "indexDocuments(IndexDocumentsBatch<?> batch)"
  nameWithType: "SearchAsyncClient.indexDocuments(IndexDocumentsBatch<?> batch)"
  summary: "Sends a batch of upload, merge, and/or delete actions to the search index."
  parameters:
  - description: "The batch of index actions"
    name: "batch"
    type: "<xref href=\"com.azure.search.documents.indexes.models.IndexDocumentsBatch?alt=com.azure.search.documents.indexes.models.IndexDocumentsBatch&text=IndexDocumentsBatch\" data-throw-if-not-resolved=\"False\" />&lt;?&gt;"
  syntax: "public Mono<IndexDocumentsResult> indexDocuments(IndexDocumentsBatch<?> batch)"
  desc: "Sends a batch of upload, merge, and/or delete actions to the search index.\n\n**Code Sample**\n\nIndex batch operation on dynamic SearchDocument.\n\n```java\nSearchDocument searchDocument1 = new SearchDocument();\n searchDocument1.put(\"hotelId\", \"1\");\n searchDocument1.put(\"hotelName\", \"test1\");\n SearchDocument searchDocument2 = new SearchDocument();\n searchDocument2.put(\"hotelId\", \"2\");\n searchDocument2.put(\"hotelName\", \"test2\");\n IndexDocumentsBatch<SearchDocument> indexDocumentsBatch = new IndexDocumentsBatch<>();\n indexDocumentsBatch.addUploadActions(Collections.singletonList(searchDocument1));\n indexDocumentsBatch.addDeleteActions(Collections.singletonList(searchDocument2));\n SEARCH_ASYNC_CLIENT.indexDocuments(indexDocumentsBatch)\n     .subscribe(result -> {\n         for (IndexingResult indexingResult : result.getResults()) {\n             System.out.printf(\"Does document with key %s finish successfully? %b%n\", indexingResult.getKey(),\n                 indexingResult.isSucceeded());\n         }\n     });\n```"
  returns:
    description: "Response containing the status of operations for all actions in the batch."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.search.documents.models.IndexDocumentsResult?alt=com.azure.search.documents.models.IndexDocumentsResult&text=IndexDocumentsResult\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.indexDocumentsWithResponse(com.azure.search.documents.indexes.models.IndexDocumentsBatch<?>,com.azure.search.documents.models.IndexDocumentsOptions)"
  fullName: "com.azure.search.documents.SearchAsyncClient.indexDocumentsWithResponse(IndexDocumentsBatch<?> batch, IndexDocumentsOptions options)"
  name: "indexDocumentsWithResponse(IndexDocumentsBatch<?> batch, IndexDocumentsOptions options)"
  nameWithType: "SearchAsyncClient.indexDocumentsWithResponse(IndexDocumentsBatch<?> batch, IndexDocumentsOptions options)"
  summary: "Sends a batch of upload, merge, and/or delete actions to the search index."
  parameters:
  - description: "The batch of index actions"
    name: "batch"
    type: "<xref href=\"com.azure.search.documents.indexes.models.IndexDocumentsBatch?alt=com.azure.search.documents.indexes.models.IndexDocumentsBatch&text=IndexDocumentsBatch\" data-throw-if-not-resolved=\"False\" />&lt;?&gt;"
  - description: "Options that allow specifying document indexing behavior."
    name: "options"
    type: "<xref href=\"com.azure.search.documents.models.IndexDocumentsOptions?alt=com.azure.search.documents.models.IndexDocumentsOptions&text=IndexDocumentsOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<IndexDocumentsResult>> indexDocumentsWithResponse(IndexDocumentsBatch<?> batch, IndexDocumentsOptions options)"
  desc: "Sends a batch of upload, merge, and/or delete actions to the search index.\n\n**Code Sample**\n\nIndex batch operation on dynamic SearchDocument.\n\n```java\nSearchDocument searchDocument1 = new SearchDocument();\n searchDocument1.put(\"hotelId\", \"1\");\n searchDocument1.put(\"hotelName\", \"test1\");\n SearchDocument searchDocument2 = new SearchDocument();\n searchDocument2.put(\"hotelId\", \"2\");\n searchDocument2.put(\"hotelName\", \"test2\");\n IndexDocumentsBatch<SearchDocument> indexDocumentsBatch = new IndexDocumentsBatch<>();\n indexDocumentsBatch.addUploadActions(Collections.singletonList(searchDocument1));\n indexDocumentsBatch.addDeleteActions(Collections.singletonList(searchDocument2));\n searchAsyncClient.indexDocumentsWithResponse(indexDocumentsBatch, null)\n     .subscribe(resultResponse -> {\n         System.out.println(\"The status code of the response is \" + resultResponse.getStatusCode());\n         for (IndexingResult indexingResult : resultResponse.getValue().getResults()) {\n             System.out.printf(\"Does document with key %s finish successfully? %b%n\", indexingResult.getKey(),\n                 indexingResult.isSucceeded());\n         }\n     });\n```"
  returns:
    description: "Response containing the status of operations for all actions in the batch"
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.search.documents.models.IndexDocumentsResult?alt=com.azure.search.documents.models.IndexDocumentsResult&text=IndexDocumentsResult\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.mergeDocuments(java.lang.Iterable<?>)"
  fullName: "com.azure.search.documents.SearchAsyncClient.mergeDocuments(Iterable<?> documents)"
  name: "mergeDocuments(Iterable<?> documents)"
  nameWithType: "SearchAsyncClient.mergeDocuments(Iterable<?> documents)"
  summary: "Merges a collection of documents with existing documents in the target index."
  parameters:
  - description: "collection of documents to be merged"
    name: "documents"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html\">Iterable</a>&lt;?&gt;"
  syntax: "public Mono<IndexDocumentsResult> mergeDocuments(Iterable<?> documents)"
  desc: "Merges a collection of documents with existing documents in the target index.\n\nIf the type of the document contains non-nullable primitive-typed properties, these properties may not merge correctly. If you do not set such a property, it will automatically take its default value (for example, `0` for `int` or false for `boolean`), which will override the value of the property currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you always declare primitive-typed properties with their class equivalents (for example, an integer property should be of type `Integer` instead of `int`).\n\n**Code Sample**\n\nMerge dynamic SearchDocument.\n\n```java\nSearchDocument searchDocument = new SearchDocument();\n searchDocument.put(\"hotelName\", \"merge\");\n SEARCH_ASYNC_CLIENT.mergeDocuments(Collections.singletonList(searchDocument))\n     .subscribe(result -> {\n         for (IndexingResult indexingResult : result.getResults()) {\n             System.out.printf(\"Does document with key %s merge successfully? %b%n\", indexingResult.getKey(),\n                 indexingResult.isSucceeded());\n         }\n     });\n```"
  returns:
    description: "document index result"
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.search.documents.models.IndexDocumentsResult?alt=com.azure.search.documents.models.IndexDocumentsResult&text=IndexDocumentsResult\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.mergeDocumentsWithResponse(java.lang.Iterable<?>,com.azure.search.documents.models.IndexDocumentsOptions)"
  fullName: "com.azure.search.documents.SearchAsyncClient.mergeDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  name: "mergeDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  nameWithType: "SearchAsyncClient.mergeDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  summary: "Merges a collection of documents with existing documents in the target index."
  parameters:
  - description: "collection of documents to be merged"
    name: "documents"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html\">Iterable</a>&lt;?&gt;"
  - description: "Options that allow specifying document indexing behavior."
    name: "options"
    type: "<xref href=\"com.azure.search.documents.models.IndexDocumentsOptions?alt=com.azure.search.documents.models.IndexDocumentsOptions&text=IndexDocumentsOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  desc: "Merges a collection of documents with existing documents in the target index.\n\nIf the type of the document contains non-nullable primitive-typed properties, these properties may not merge correctly. If you do not set such a property, it will automatically take its default value (for example, `0` for `int` or false for `boolean`), which will override the value of the property currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you always declare primitive-typed properties with their class equivalents (for example, an integer property should be of type `Integer` instead of `int`).\n\n**Code Sample**\n\nMerge dynamic SearchDocument.\n\n```java\nSearchDocument searchDocument = new SearchDocument();\n searchDocument.put(\"hotelName\", \"test\");\n searchAsyncClient.mergeDocumentsWithResponse(Collections.singletonList(searchDocument), null)\n     .subscribe(resultResponse -> {\n         System.out.println(\"The status code of the response is \" + resultResponse.getStatusCode());\n         for (IndexingResult indexingResult : resultResponse.getValue().getResults()) {\n             System.out.printf(\"Does document with key %s merge successfully? %b%n\", indexingResult.getKey(),\n                 indexingResult.isSucceeded());\n         }\n     });\n```"
  returns:
    description: "response containing the document index result."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.search.documents.models.IndexDocumentsResult?alt=com.azure.search.documents.models.IndexDocumentsResult&text=IndexDocumentsResult\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.mergeOrUploadDocuments(java.lang.Iterable<?>)"
  fullName: "com.azure.search.documents.SearchAsyncClient.mergeOrUploadDocuments(Iterable<?> documents)"
  name: "mergeOrUploadDocuments(Iterable<?> documents)"
  nameWithType: "SearchAsyncClient.mergeOrUploadDocuments(Iterable<?> documents)"
  summary: "This action behaves like merge if a document with the given key already exists in the index."
  parameters:
  - description: "collection of documents to be merged, if exists, otherwise uploaded"
    name: "documents"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html\">Iterable</a>&lt;?&gt;"
  syntax: "public Mono<IndexDocumentsResult> mergeOrUploadDocuments(Iterable<?> documents)"
  desc: "This action behaves like merge if a document with the given key already exists in the index. If the document does not exist, it behaves like upload with a new document.\n\nIf the type of the document contains non-nullable primitive-typed properties, these properties may not merge correctly. If you do not set such a property, it will automatically take its default value (for example, `0` for `int` or false for `boolean`), which will override the value of the property currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you always declare primitive-typed properties with their class equivalents (for example, an integer property should be of type `Integer` instead of `int`).\n\n**Code Sample**\n\nMerge or upload dynamic SearchDocument.\n\n```java\nSearchDocument searchDocument = new SearchDocument();\n searchDocument.put(\"hotelId\", \"1\");\n searchDocument.put(\"hotelName\", \"test\");\n SEARCH_ASYNC_CLIENT.mergeOrUploadDocuments(Collections.singletonList(searchDocument))\n     .subscribe(result -> {\n         for (IndexingResult indexingResult : result.getResults()) {\n             System.out.printf(\"Does document with key %s mergeOrUpload successfully? %b%n\",\n                 indexingResult.getKey(), indexingResult.isSucceeded());\n         }\n     });\n```"
  returns:
    description: "document index result"
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.search.documents.models.IndexDocumentsResult?alt=com.azure.search.documents.models.IndexDocumentsResult&text=IndexDocumentsResult\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.mergeOrUploadDocumentsWithResponse(java.lang.Iterable<?>,com.azure.search.documents.models.IndexDocumentsOptions)"
  fullName: "com.azure.search.documents.SearchAsyncClient.mergeOrUploadDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  name: "mergeOrUploadDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  nameWithType: "SearchAsyncClient.mergeOrUploadDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  summary: "This action behaves like merge if a document with the given key already exists in the index."
  parameters:
  - description: "collection of documents to be merged, if exists, otherwise uploaded"
    name: "documents"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html\">Iterable</a>&lt;?&gt;"
  - description: "Options that allow specifying document indexing behavior."
    name: "options"
    type: "<xref href=\"com.azure.search.documents.models.IndexDocumentsOptions?alt=com.azure.search.documents.models.IndexDocumentsOptions&text=IndexDocumentsOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  desc: "This action behaves like merge if a document with the given key already exists in the index. If the document does not exist, it behaves like upload with a new document.\n\nIf the type of the document contains non-nullable primitive-typed properties, these properties may not merge correctly. If you do not set such a property, it will automatically take its default value (for example, `0` for `int` or false for `boolean`), which will override the value of the property currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you always declare primitive-typed properties with their class equivalents (for example, an integer property should be of type `Integer` instead of `int`).\n\n**Code Sample**\n\nMerge or upload dynamic SearchDocument.\n\n```java\nSearchDocument searchDocument = new SearchDocument();\n searchDocument.put(\"hotelId\", \"1\");\n searchDocument.put(\"hotelName\", \"test\");\n searchAsyncClient.mergeOrUploadDocumentsWithResponse(Collections.singletonList(searchDocument), null)\n     .subscribe(resultResponse -> {\n         System.out.println(\"The status code of the response is \" + resultResponse.getStatusCode());\n         for (IndexingResult indexingResult : resultResponse.getValue().getResults()) {\n             System.out.printf(\"Does document with key %s mergeOrUpload successfully? %b%n\",\n                 indexingResult.getKey(), indexingResult.isSucceeded());\n         }\n     });\n```"
  returns:
    description: "document index result"
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.search.documents.models.IndexDocumentsResult?alt=com.azure.search.documents.models.IndexDocumentsResult&text=IndexDocumentsResult\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.search(java.lang.String)"
  fullName: "com.azure.search.documents.SearchAsyncClient.search(String searchText)"
  name: "search(String searchText)"
  nameWithType: "SearchAsyncClient.search(String searchText)"
  summary: "Searches for documents in the Azure AI Search index."
  parameters:
  - description: "A full-text search query expression."
    name: "searchText"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  syntax: "public SearchPagedFlux search(String searchText)"
  desc: "Searches for documents in the Azure AI Search index.\n\nIf `searchText` is set to null or `\"*\"` all documents will be matched, see [simple query syntax in Azure AI Search][] for more information about search query syntax.\n\nThe <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> will iterate through search result pages until all search results are returned. Each page is determined by the `$skip` and `$top` values and the Search service has a limit on the number of documents that can be skipped, more information about the `$skip` limit can be found at [Search Documents REST API][] and reading the `$skip` description. If the total number of results exceeds the `$skip` limit the <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> won't prevent you from exceeding the `$skip` limit. To prevent exceeding the limit you can track the number of documents returned and stop requesting new pages when the limit is reached.\n\n**Code Sample**\n\nSearch text from documents in service.\n\n```java\nSearchPagedFlux searchPagedFlux = SEARCH_ASYNC_CLIENT.search(\"searchText\");\n searchPagedFlux.getTotalCount().subscribe(\n     count -> System.out.printf(\"There are around %d results.\", count));\n\n AtomicLong numberOfDocumentsReturned = new AtomicLong();\n searchPagedFlux.byPage()\n     .takeUntil(page -> {\n         if (numberOfDocumentsReturned.addAndGet(page.getValue().size()) >= SEARCH_SKIP_LIMIT) {\n             // Reached the $skip limit, stop requesting more documents.\n             return true;\n         }\n\n         return false;\n     })\n     .subscribe(resultResponse -> {\n         for (SearchResult result: resultResponse.getValue()) {\n             SearchDocument searchDocument = result.getDocument(SearchDocument.class);\n             for (Map.Entry<String, Object> keyValuePair: searchDocument.entrySet()) {\n                 System.out.printf(\"Document key %s, document value %s\", keyValuePair.getKey(), keyValuePair.getValue());\n             }\n         }\n     });\n```\n\n\n[simple query syntax in Azure AI Search]: https://docs.microsoft.com/rest/api/searchservice/Simple-query-syntax-in-Azure-Search\n[Search Documents REST API]: https://learn.microsoft.com/rest/api/searchservice/search-documents"
  returns:
    description: "A <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> that iterates over <xref uid=\"com.azure.search.documents.models.SearchResult\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchResult\"></xref> objects and provides access to the\n <xref uid=\"com.azure.search.documents.util.SearchPagedResponse\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedResponse\"></xref> object for each page containing HTTP response and count, facet, and coverage\n information."
    type: "<xref href=\"com.azure.search.documents.util.SearchPagedFlux?alt=com.azure.search.documents.util.SearchPagedFlux&text=SearchPagedFlux\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.search.documents.SearchAsyncClient.search(java.lang.String,com.azure.search.documents.models.SearchOptions)"
  fullName: "com.azure.search.documents.SearchAsyncClient.search(String searchText, SearchOptions searchOptions)"
  name: "search(String searchText, SearchOptions searchOptions)"
  nameWithType: "SearchAsyncClient.search(String searchText, SearchOptions searchOptions)"
  summary: "Searches for documents in the Azure AI Search index."
  parameters:
  - description: "A full-text search query expression."
    name: "searchText"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "Parameters to further refine the search query"
    name: "searchOptions"
    type: "<xref href=\"com.azure.search.documents.models.SearchOptions?alt=com.azure.search.documents.models.SearchOptions&text=SearchOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public SearchPagedFlux search(String searchText, SearchOptions searchOptions)"
  desc: "Searches for documents in the Azure AI Search index.\n\nIf `searchText` is set to null or `\"*\"` all documents will be matched, see [simple query syntax in Azure AI Search][] for more information about search query syntax.\n\nThe <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> will iterate through search result pages until all search results are returned. Each page is determined by the `$skip` and `$top` values and the Search service has a limit on the number of documents that can be skipped, more information about the `$skip` limit can be found at [Search Documents REST API][] and reading the `$skip` description. If the total number of results exceeds the `$skip` limit the <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> won't prevent you from exceeding the `$skip` limit. To prevent exceeding the limit you can track the number of documents returned and stop requesting new pages when the limit is reached.\n\n**Code Sample**\n\nSearch text from documents in service with option.\n\n```java\nSearchPagedFlux pagedFlux = SEARCH_ASYNC_CLIENT.search(\"searchText\",\n     new SearchOptions().setOrderBy(\"hotelId desc\"));\n\n pagedFlux.getTotalCount().subscribe(count -> System.out.printf(\"There are around %d results.\", count));\n\n AtomicLong numberOfDocumentsReturned = new AtomicLong();\n pagedFlux.byPage()\n     .takeUntil(page -> {\n         if (numberOfDocumentsReturned.addAndGet(page.getValue().size()) >= SEARCH_SKIP_LIMIT) {\n             // Reached the $skip limit, stop requesting more documents.\n             return true;\n         }\n\n         return false;\n     })\n     .subscribe(searchResultResponse -> searchResultResponse.getValue().forEach(searchDocument -> {\n         for (Map.Entry<String, Object> keyValuePair\n             : searchDocument.getDocument(SearchDocument.class).entrySet()) {\n             System.out.printf(\"Document key %s, document value %s\", keyValuePair.getKey(),\n                 keyValuePair.getValue());\n         }\n     }));\n```\n\n\n[simple query syntax in Azure AI Search]: https://docs.microsoft.com/rest/api/searchservice/Simple-query-syntax-in-Azure-Search\n[Search Documents REST API]: https://learn.microsoft.com/rest/api/searchservice/search-documents"
  returns:
    description: "A <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> that iterates over <xref uid=\"com.azure.search.documents.models.SearchResult\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchResult\"></xref> objects and provides access to the\n <xref uid=\"com.azure.search.documents.util.SearchPagedResponse\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedResponse\"></xref> object for each page containing HTTP response and count, facet, and coverage\n information."
    type: "<xref href=\"com.azure.search.documents.util.SearchPagedFlux?alt=com.azure.search.documents.util.SearchPagedFlux&text=SearchPagedFlux\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.search.documents.SearchAsyncClient.search(java.lang.String,com.azure.search.documents.models.SearchOptions,java.lang.String)"
  fullName: "com.azure.search.documents.SearchAsyncClient.search(String searchText, SearchOptions searchOptions, String querySourceAuthorization)"
  name: "search(String searchText, SearchOptions searchOptions, String querySourceAuthorization)"
  nameWithType: "SearchAsyncClient.search(String searchText, SearchOptions searchOptions, String querySourceAuthorization)"
  summary: "Searches for documents in the Azure AI Search index."
  parameters:
  - description: "A full-text search query expression."
    name: "searchText"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "Parameters to further refine the search query"
    name: "searchOptions"
    type: "<xref href=\"com.azure.search.documents.models.SearchOptions?alt=com.azure.search.documents.models.SearchOptions&text=SearchOptions\" data-throw-if-not-resolved=\"False\" />"
  - description: "Token identifying the user for which the query is being executed."
    name: "querySourceAuthorization"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  syntax: "public SearchPagedFlux search(String searchText, SearchOptions searchOptions, String querySourceAuthorization)"
  desc: "Searches for documents in the Azure AI Search index.\n\nIf `searchText` is set to null or `\"*\"` all documents will be matched, see [simple query syntax in Azure AI Search][] for more information about search query syntax.\n\nThe <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> will iterate through search result pages until all search results are returned. Each page is determined by the `$skip` and `$top` values and the Search service has a limit on the number of documents that can be skipped, more information about the `$skip` limit can be found at [Search Documents REST API][] and reading the `$skip` description. If the total number of results exceeds the `$skip` limit the <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> won't prevent you from exceeding the `$skip` limit. To prevent exceeding the limit you can track the number of documents returned and stop requesting new pages when the limit is reached.\n\n**Code Sample**\n\nSearch text from documents in service with option.\n\n```java\nSearchPagedFlux pagedFlux = SEARCH_ASYNC_CLIENT.search(\"searchText\",\n     new SearchOptions().setOrderBy(\"hotelId desc\"));\n\n pagedFlux.getTotalCount().subscribe(count -> System.out.printf(\"There are around %d results.\", count));\n\n AtomicLong numberOfDocumentsReturned = new AtomicLong();\n pagedFlux.byPage()\n     .takeUntil(page -> {\n         if (numberOfDocumentsReturned.addAndGet(page.getValue().size()) >= SEARCH_SKIP_LIMIT) {\n             // Reached the $skip limit, stop requesting more documents.\n             return true;\n         }\n\n         return false;\n     })\n     .subscribe(searchResultResponse -> searchResultResponse.getValue().forEach(searchDocument -> {\n         for (Map.Entry<String, Object> keyValuePair\n             : searchDocument.getDocument(SearchDocument.class).entrySet()) {\n             System.out.printf(\"Document key %s, document value %s\", keyValuePair.getKey(),\n                 keyValuePair.getValue());\n         }\n     }));\n```\n\n\n[simple query syntax in Azure AI Search]: https://docs.microsoft.com/rest/api/searchservice/Simple-query-syntax-in-Azure-Search\n[Search Documents REST API]: https://learn.microsoft.com/rest/api/searchservice/search-documents"
  returns:
    description: "A <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> that iterates over <xref uid=\"com.azure.search.documents.models.SearchResult\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchResult\"></xref> objects and provides access to the\n <xref uid=\"com.azure.search.documents.util.SearchPagedResponse\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedResponse\"></xref> object for each page containing HTTP response and count, facet, and coverage\n information."
    type: "<xref href=\"com.azure.search.documents.util.SearchPagedFlux?alt=com.azure.search.documents.util.SearchPagedFlux&text=SearchPagedFlux\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.search.documents.SearchAsyncClient.search(java.lang.String,java.lang.String)"
  fullName: "com.azure.search.documents.SearchAsyncClient.search(String searchText, String querySourceAuthorization)"
  name: "search(String searchText, String querySourceAuthorization)"
  nameWithType: "SearchAsyncClient.search(String searchText, String querySourceAuthorization)"
  summary: "Searches for documents in the Azure AI Search index."
  parameters:
  - description: "A full-text search query expression."
    name: "searchText"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "Token identifying the user for which the query is being executed.\n This token is used to enforce security restrictions on documents."
    name: "querySourceAuthorization"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  syntax: "public SearchPagedFlux search(String searchText, String querySourceAuthorization)"
  desc: "Searches for documents in the Azure AI Search index.\n\nIf `searchText` is set to null or `\"*\"` all documents will be matched, see [simple query syntax in Azure AI Search][] for more information about search query syntax.\n\nThe <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> will iterate through search result pages until all search results are returned. Each page is determined by the `$skip` and `$top` values and the Search service has a limit on the number of documents that can be skipped, more information about the `$skip` limit can be found at [Search Documents REST API][] and reading the `$skip` description. If the total number of results exceeds the `$skip` limit the <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> won't prevent you from exceeding the `$skip` limit. To prevent exceeding the limit you can track the number of documents returned and stop requesting new pages when the limit is reached.\n\n**Code Sample**\n\nSearch text from documents in service.\n\n```java\nSearchPagedFlux searchPagedFlux = SEARCH_ASYNC_CLIENT.search(\"searchText\");\n searchPagedFlux.getTotalCount().subscribe(\n     count -> System.out.printf(\"There are around %d results.\", count));\n\n AtomicLong numberOfDocumentsReturned = new AtomicLong();\n searchPagedFlux.byPage()\n     .takeUntil(page -> {\n         if (numberOfDocumentsReturned.addAndGet(page.getValue().size()) >= SEARCH_SKIP_LIMIT) {\n             // Reached the $skip limit, stop requesting more documents.\n             return true;\n         }\n\n         return false;\n     })\n     .subscribe(resultResponse -> {\n         for (SearchResult result: resultResponse.getValue()) {\n             SearchDocument searchDocument = result.getDocument(SearchDocument.class);\n             for (Map.Entry<String, Object> keyValuePair: searchDocument.entrySet()) {\n                 System.out.printf(\"Document key %s, document value %s\", keyValuePair.getKey(), keyValuePair.getValue());\n             }\n         }\n     });\n```\n\n\n[simple query syntax in Azure AI Search]: https://docs.microsoft.com/rest/api/searchservice/Simple-query-syntax-in-Azure-Search\n[Search Documents REST API]: https://learn.microsoft.com/rest/api/searchservice/search-documents"
  returns:
    description: "A <xref uid=\"com.azure.search.documents.util.SearchPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedFlux\"></xref> that iterates over <xref uid=\"com.azure.search.documents.models.SearchResult\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchResult\"></xref> objects and provides access to the\n <xref uid=\"com.azure.search.documents.util.SearchPagedResponse\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchPagedResponse\"></xref> object for each page containing HTTP response and count, facet, and coverage\n information."
    type: "<xref href=\"com.azure.search.documents.util.SearchPagedFlux?alt=com.azure.search.documents.util.SearchPagedFlux&text=SearchPagedFlux\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.search.documents.SearchAsyncClient.suggest(java.lang.String,java.lang.String)"
  fullName: "com.azure.search.documents.SearchAsyncClient.suggest(String searchText, String suggesterName)"
  name: "suggest(String searchText, String suggesterName)"
  nameWithType: "SearchAsyncClient.suggest(String searchText, String suggesterName)"
  summary: "Suggests documents in the index that match the given partial query."
  parameters:
  - description: "The search text."
    name: "searchText"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "The name of the suggester."
    name: "suggesterName"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  syntax: "public SuggestPagedFlux suggest(String searchText, String suggesterName)"
  desc: "Suggests documents in the index that match the given partial query.\n\n**Code Sample**\n\nSuggest text from documents in service.\n\n```java\nSEARCH_ASYNC_CLIENT.suggest(\"searchText\", \"sg\")\n     .subscribe(results -> {\n         for (Map.Entry<String, Object> keyValuePair: results.getDocument(SearchDocument.class).entrySet()) {\n             System.out.printf(\"Document key %s, document value %s\", keyValuePair.getKey(),\n                 keyValuePair.getValue());\n         }\n     });\n```"
  returns:
    description: "A <xref uid=\"com.azure.search.documents.util.SuggestPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SuggestPagedFlux\"></xref> that iterates over <xref uid=\"com.azure.search.documents.models.SuggestResult\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SuggestResult\"></xref> objects and provides access to the\n <xref uid=\"com.azure.search.documents.util.SuggestPagedResponse\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SuggestPagedResponse\"></xref> object for each page containing HTTP response and coverage information."
    type: "<xref href=\"com.azure.search.documents.util.SuggestPagedFlux?alt=com.azure.search.documents.util.SuggestPagedFlux&text=SuggestPagedFlux\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.search.documents.SearchAsyncClient.suggest(java.lang.String,java.lang.String,com.azure.search.documents.models.SuggestOptions)"
  fullName: "com.azure.search.documents.SearchAsyncClient.suggest(String searchText, String suggesterName, SuggestOptions suggestOptions)"
  name: "suggest(String searchText, String suggesterName, SuggestOptions suggestOptions)"
  nameWithType: "SearchAsyncClient.suggest(String searchText, String suggesterName, SuggestOptions suggestOptions)"
  summary: "Suggests documents in the index that match the given partial query."
  parameters:
  - description: "The search text."
    name: "searchText"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "The name of the suggester."
    name: "suggesterName"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\">String</a>"
  - description: "Parameters to further refine the suggestion query."
    name: "suggestOptions"
    type: "<xref href=\"com.azure.search.documents.models.SuggestOptions?alt=com.azure.search.documents.models.SuggestOptions&text=SuggestOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public SuggestPagedFlux suggest(String searchText, String suggesterName, SuggestOptions suggestOptions)"
  desc: "Suggests documents in the index that match the given partial query.\n\n**Code Sample**\n\nSuggest text from documents in service with option.\n\n```java\nSEARCH_ASYNC_CLIENT.suggest(\"searchText\", \"sg\",\n     new SuggestOptions().setOrderBy(\"hotelId desc\"))\n     .subscribe(results -> {\n         for (Map.Entry<String, Object> keyValuePair: results.getDocument(SearchDocument.class).entrySet()) {\n             System.out.printf(\"Document key %s, document value %s\", keyValuePair.getKey(),\n                 keyValuePair.getValue());\n         }\n     });\n```"
  returns:
    description: "A <xref uid=\"com.azure.search.documents.util.SuggestPagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SuggestPagedFlux\"></xref> that iterates over <xref uid=\"com.azure.search.documents.models.SuggestResult\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SuggestResult\"></xref> objects and provides access to the\n <xref uid=\"com.azure.search.documents.util.SuggestPagedResponse\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SuggestPagedResponse\"></xref> object for each page containing HTTP response and coverage information."
    type: "<xref href=\"com.azure.search.documents.util.SuggestPagedFlux?alt=com.azure.search.documents.util.SuggestPagedFlux&text=SuggestPagedFlux\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.search.documents.SearchAsyncClient.uploadDocuments(java.lang.Iterable<?>)"
  fullName: "com.azure.search.documents.SearchAsyncClient.uploadDocuments(Iterable<?> documents)"
  name: "uploadDocuments(Iterable<?> documents)"
  nameWithType: "SearchAsyncClient.uploadDocuments(Iterable<?> documents)"
  summary: "Uploads a collection of documents to the target index."
  parameters:
  - description: "collection of documents to upload to the target Index."
    name: "documents"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html\">Iterable</a>&lt;?&gt;"
  syntax: "public Mono<IndexDocumentsResult> uploadDocuments(Iterable<?> documents)"
  desc: "Uploads a collection of documents to the target index.\n\n**Code Sample**\n\nUpload dynamic SearchDocument.\n\n```java\nSearchDocument searchDocument = new SearchDocument();\n searchDocument.put(\"hotelId\", \"1\");\n searchDocument.put(\"hotelName\", \"test\");\n SEARCH_ASYNC_CLIENT.uploadDocuments(Collections.singletonList(searchDocument))\n     .subscribe(result -> {\n         for (IndexingResult indexingResult : result.getResults()) {\n             System.out.printf(\"Does document with key %s upload successfully? %b%n\",\n                 indexingResult.getKey(), indexingResult.isSucceeded());\n         }\n     });\n```"
  returns:
    description: "The result of the document indexing actions."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.search.documents.models.IndexDocumentsResult?alt=com.azure.search.documents.models.IndexDocumentsResult&text=IndexDocumentsResult\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.search.documents.SearchAsyncClient.uploadDocumentsWithResponse(java.lang.Iterable<?>,com.azure.search.documents.models.IndexDocumentsOptions)"
  fullName: "com.azure.search.documents.SearchAsyncClient.uploadDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  name: "uploadDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  nameWithType: "SearchAsyncClient.uploadDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  summary: "Uploads a collection of documents to the target index."
  parameters:
  - description: "collection of documents to upload to the target Index."
    name: "documents"
    type: "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html\">Iterable</a>&lt;?&gt;"
  - description: "Options that allow specifying document indexing behavior."
    name: "options"
    type: "<xref href=\"com.azure.search.documents.models.IndexDocumentsOptions?alt=com.azure.search.documents.models.IndexDocumentsOptions&text=IndexDocumentsOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, IndexDocumentsOptions options)"
  desc: "Uploads a collection of documents to the target index.\n\n**Code Sample**\n\nUpload dynamic SearchDocument.\n\n```java\nSearchDocument searchDocument = new SearchDocument();\n searchDocument.put(\"hotelId\", \"1\");\n searchDocument.put(\"hotelName\", \"test\");\n searchAsyncClient.uploadDocumentsWithResponse(Collections.singletonList(searchDocument), null)\n     .subscribe(resultResponse -> {\n         System.out.println(\"The status code of the response is \" + resultResponse.getStatusCode());\n         for (IndexingResult indexingResult : resultResponse.getValue().getResults()) {\n             System.out.printf(\"Does document with key %s upload successfully? %b%n\", indexingResult.getKey(),\n                 indexingResult.isSucceeded());\n         }\n     });\n```"
  returns:
    description: "A response containing the result of the document indexing actions."
    type: "<a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\">Mono</a>&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.search.documents.models.IndexDocumentsResult?alt=com.azure.search.documents.models.IndexDocumentsResult&text=IndexDocumentsResult\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
type: "class"
desc: "This class provides a client that contains the operations for querying an index and uploading, merging, or deleting documents in an Azure AI Search service.\n\n## Overview ##\n\nConceptually, a document is an entity in your index. Mapping this concept to more familiar database equivalents: a search index equates to a table, and documents are roughly equivalent to rows in a table. Documents exist only in an index, and are retrieved only through queries that target the documents collection (/docs) of an index. All operations performed on the collection such as uploading, merging, deleting, or querying documents take place in the context of a single index, so the URL format document operations will always include /indexes/\\[index name\\]/docs for a given index name.\n\nThis client provides an asynchronous API for accessing and performing operations on indexed documents. This client assists with searching your indexed documents, autocompleting partially typed search terms based on documents within the index, suggesting the most likely matching text in documents as a user types. The client provides operations for adding, updating, and deleting documents from an index.\n\n## Getting Started ##\n\nAuthenticating and building instances of this client are handled by <xref uid=\"com.azure.search.documents.SearchClientBuilder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchClientBuilder\"></xref>. This sample shows you how to authenticate and create an instance of the client:\n\n```java\nSearchAsyncClient searchAsyncClient = new SearchClientBuilder()\n     .credential(new AzureKeyCredential(\"{key}\"))\n     .endpoint(\"{endpoint}\")\n     .indexName(\"{indexName}\")\n     .buildAsyncClient();\n```\n\nFor more information on authentication and building, see the <xref uid=\"com.azure.search.documents.SearchClientBuilder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchClientBuilder\"></xref> documentation.\n\n--------------------\n\n## Examples ##\n\nThe following examples all use [a simple Hotel data set][] that you can [ import into your own index from the Azure portal.][import into your own index from the Azure portal.] These are just a few of the basics - please check out [our Samples ][our Samples]for much more.\n\n### Upload a Document ###\n\nThe following sample uploads a new document to an index.\n\n```java\nList<Hotel> hotels = new ArrayList<>();\n hotels.add(new Hotel().setHotelId(\"100\"));\n hotels.add(new Hotel().setHotelId(\"200\"));\n hotels.add(new Hotel().setHotelId(\"300\"));\n searchAsyncClient.uploadDocuments(hotels).block();\n```\n\n *For a synchronous sample see <xref uid=\"com.azure.search.documents.SearchClient.uploadDocuments(java.lang.Iterable<?>)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchClient#uploadDocuments(Iterable)\"></xref>.* \n\n### Merge a Document ###\n\nThe following sample merges documents in an index.\n\n```java\nList<Hotel> hotels = new ArrayList<>();\n hotels.add(new Hotel().setHotelId(\"100\"));\n hotels.add(new Hotel().setHotelId(\"200\"));\n searchAsyncClient.mergeDocuments(hotels).block();\n```\n\n *For a synchronous sample see <xref uid=\"com.azure.search.documents.SearchClient.mergeDocuments(java.lang.Iterable<?>)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchClient#mergeDocuments(Iterable)\"></xref>.* \n\n### Delete a Document ###\n\nThe following sample deletes a document from an index.\n\n```java\nSearchDocument documentId = new SearchDocument();\n documentId.put(\"hotelId\", \"100\");\n searchAsyncClient.deleteDocuments(Collections.singletonList(documentId));\n```\n\n *For a synchronous sample see <xref uid=\"com.azure.search.documents.SearchClient.deleteDocuments(java.lang.Iterable<?>)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchClient#deleteDocuments(Iterable)\"></xref>.* \n\n### Get a Document ###\n\nThe following sample gets a document from an index.\n\n```java\nHotel hotel = searchAsyncClient.getDocument(\"100\", Hotel.class).block();\n if (hotel != null) {\n     System.out.printf(\"Retrieved Hotel %s%n\", hotel.getHotelId());\n }\n```\n\n *For a synchronous sample see <xref uid=\"com.azure.search.documents.SearchClient.<T>getDocument(java.lang.String,java.lang.Class<T>)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchClient#getDocument(String, Class)\"></xref>.* \n\n### Search Documents ###\n\nThe following sample searches for documents within an index.\n\n```java\nSearchDocument searchDocument = new SearchDocument();\n searchDocument.put(\"hotelId\", \"8\");\n searchDocument.put(\"description\", \"budget\");\n searchDocument.put(\"descriptionFr\", \"motel\");\n\n SearchDocument searchDocument1 = new SearchDocument();\n searchDocument1.put(\"hotelId\", \"9\");\n searchDocument1.put(\"description\", \"budget\");\n searchDocument1.put(\"descriptionFr\", \"motel\");\n\n List<SearchDocument> searchDocuments = new ArrayList<>();\n searchDocuments.add(searchDocument);\n searchDocuments.add(searchDocument1);\n searchAsyncClient.uploadDocuments(searchDocuments);\n\n SearchPagedFlux results = searchAsyncClient.search(\"SearchText\");\n results.getTotalCount().subscribe(total -> System.out.printf(\"There are %s results\", total));\n```\n\n *For a synchronous sample see <xref uid=\"com.azure.search.documents.SearchClient.search(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchClient#search(String)\"></xref>.* \n\n### Make a Suggestion ###\n\nThe following sample suggests the most likely matching text in documents.\n\n```java\nSuggestPagedFlux results = searchAsyncClient.suggest(\"searchText\", \"sg\");\n results.subscribe(item -> {\n     System.out.printf(\"The text '%s' was found.%n\", item.getText());\n });\n```\n\n *For a synchronous sample see <xref uid=\"com.azure.search.documents.SearchClient.suggest(java.lang.String,java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchClient#suggest(String, String)\"></xref>.* \n\n### Provide an Autocompletion ###\n\nThe following sample provides autocompletion for a partially typed query.\n\n```java\nAutocompletePagedFlux results = searchAsyncClient.autocomplete(\"searchText\", \"sg\");\n results.subscribe(item -> {\n     System.out.printf(\"The text '%s' was found.%n\", item.getText());\n });\n```\n\n *For a synchronous sample see <xref uid=\"com.azure.search.documents.SearchClient.autocomplete(java.lang.String,java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"SearchClient#autocomplete(String, String)\"></xref>.* \n\n\n[a simple Hotel data set]: https://github.com/Azure-Samples/azure-search-sample-data\n[import into your own index from the Azure portal.]: https://learn.microsoft.com/azure/search/search-get-started-portal#step-1---start-the-import-data-wizard-and-create-a-data-source\n[our Samples]: https://github.com/Azure/azure-sdk-for-java/blob/main/sdk/search/azure-search-documents/src/samples/README.md"
metadata: {}
package: "com.azure.search.documents"
artifact: com.azure:azure-search-documents:11.8.0-beta.7
