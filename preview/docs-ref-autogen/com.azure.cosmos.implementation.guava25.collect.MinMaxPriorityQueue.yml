### YamlMime:JavaType
uid: "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue"
fullName: "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue<E>"
name: "MinMaxPriorityQueue<E>"
nameWithType: "MinMaxPriorityQueue<E>"
summary: "A double-ended priority queue, which provides constant-time access to both its least element and its greatest element, as determined by the queue's specified comparator. If no comparator is given at creation time, the natural order of elements is used. If no maximum size is given at creation time, the queue is unbounded.\n\nUsage example:\n\n```java\nMinMaxPriorityQueue users = MinMaxPriorityQueue.orderedBy(userComparator)\n     .maximumSize(1000)\n     .create();\n```\n\nAs a <xref uid=\"java.util.Queue\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Queue\"></xref> it functions exactly as a <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PriorityQueue\"></xref>: its head element -- the implicit target of the methods <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.peek()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#peek()\"></xref>, <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.poll()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#poll()\"></xref> and <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.remove*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#remove()\"></xref> \\-- is defined as the *least* element in the queue according to the queue's comparator. But unlike a regular priority queue, the methods <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.peekLast\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#peekLast\"></xref>, <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.pollLast\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#pollLast\"></xref> and <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.removeLast\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#removeLast\"></xref> are also provided, to act on the *greatest* element in the queue instead.\n\nA min-max priority queue can be configured with a maximum size. If so, each time the size of the queue exceeds that value, the queue automatically removes its greatest element according to its comparator (which might be the element that was just added). This is different from conventional bounded queues, which either block or reject new elements when full.\n\nThis implementation is based on the [min-max heap][] developed by Atkinson, et al. Unlike many other double-ended priority queues, it stores elements in a single array, as compact as the traditional heap data structure used in <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PriorityQueue\"></xref>.\n\nThis class is not thread-safe, and does not accept null elements.\n\n*Performance notes:*\n\n *  If you only access one end of the queue, and do use a maximum size, this class will perform significantly worse than a `PriorityQueue` with manual eviction above the maximum size. In many cases <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Ordering.leastOf\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Ordering#leastOf\"></xref> may work for your use case with significantly improved (and asymptotically superior) performance.\n *  The retrieval operations <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.peek\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#peek\"></xref>, <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.peekFirst\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#peekFirst\"></xref>, <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.peekLast\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#peekLast\"></xref>, <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.element\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#element\"></xref>, and <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.size\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#size\"></xref> are constant-time.\n *  The enqueuing and dequeuing operations (<xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.offer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#offer\"></xref>, <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.add\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#add\"></xref>, and all the forms of <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.poll\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#poll\"></xref> and <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.remove*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#remove()\"></xref>) run in `O(log n) time`.\n *  The <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.remove*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#remove(Object)\"></xref> and <xref uid=\"com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.contains\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#contains\"></xref> operations require linear (`O(n)`) time.\n *  If you only access one end of the queue, and don't use a maximum size, this class is functionally equivalent to <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PriorityQueue\"></xref>, but significantly slower.\n\n\n[min-max heap]: http://portal.acm.org/citation.cfm?id=6621"
inheritances:
- "<xref href=\"java.lang.Object\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"java.util.AbstractCollection\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"java.util.AbstractQueue\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
- "java.util.AbstractCollection.<T>toArray(T[])"
- "java.util.AbstractCollection.contains(java.lang.Object)"
- "java.util.AbstractCollection.containsAll(java.util.Collection<?>)"
- "java.util.AbstractCollection.isEmpty()"
- "java.util.AbstractCollection.iterator()"
- "java.util.AbstractCollection.remove(java.lang.Object)"
- "java.util.AbstractCollection.removeAll(java.util.Collection<?>)"
- "java.util.AbstractCollection.retainAll(java.util.Collection<?>)"
- "java.util.AbstractCollection.size()"
- "java.util.AbstractCollection.toArray()"
- "java.util.AbstractCollection.toString()"
- "java.util.AbstractQueue.add(E)"
- "java.util.AbstractQueue.addAll(java.util.Collection<? extends E>)"
- "java.util.AbstractQueue.clear()"
- "java.util.AbstractQueue.element()"
- "java.util.AbstractQueue.remove()"
syntax: "public final class MinMaxPriorityQueue<E> extends AbstractQueue<E>"
methods:
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.<B>orderedBy(java.util.Comparator<B>)"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.<E>create()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.<E>create(java.lang.Iterable<? extends E>)"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.add(E)"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.addAll(java.util.Collection<? extends E>)"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.clear()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.comparator()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.expectedSize(int)"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.iterator()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.maximumSize(int)"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.offer(E)"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.peek()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.peekFirst()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.peekLast()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.poll()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.pollFirst()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.pollLast()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.removeFirst()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.removeLast()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.size()"
- "com.azure.cosmos.implementation.guava25.collect.MinMaxPriorityQueue.toArray()"
type: "class"
typeParameters:
- name: "E"
metadata: {}
package: "com.azure.cosmos.implementation.guava25.collect"
artifact: com.azure:azure-cosmos:4.4.0-beta.1
