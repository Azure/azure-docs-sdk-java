### YamlMime:JavaType
uid: "com.azure.storage.blob.BlobAsyncClient"
fullName: "com.azure.storage.blob.BlobAsyncClient"
name: "BlobAsyncClient"
nameWithType: "BlobAsyncClient"
summary: "This class provides a client that contains generic blob operations for Azure Storage Blobs."
inheritances:
- "<xref href=\"java.lang.Object?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
- "<xref href=\"com.azure.storage.blob.specialized.BlobAsyncClientBase?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.abortCopyFromUrl(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.abortCopyFromUrlWithResponse(java.lang.String,java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.beginCopy(com.azure.storage.blob.options.BlobBeginCopyOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.beginCopy(java.lang.String,java.time.Duration)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.beginCopy(java.lang.String,java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.AccessTier,com.azure.storage.blob.models.RehydratePriority,com.azure.core.http.RequestConditions,com.azure.storage.blob.models.BlobRequestConditions,java.time.Duration)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.copyFromUrl(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.copyFromUrlWithResponse(com.azure.storage.blob.options.BlobCopyFromUrlOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.copyFromUrlWithResponse(java.lang.String,java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.AccessTier,com.azure.core.http.RequestConditions,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.createSnapshot()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.createSnapshotWithResponse(java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.delete()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteIfExists()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteIfExistsWithResponse(com.azure.storage.blob.models.DeleteSnapshotsOptionType,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteImmutabilityPolicy()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteImmutabilityPolicyWithResponse()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.deleteWithResponse(com.azure.storage.blob.models.DeleteSnapshotsOptionType,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.download()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadContent()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadContentWithResponse(com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadStream()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadStreamWithResponse(com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFile(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFile(java.lang.String,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFileWithResponse(com.azure.storage.blob.options.BlobDownloadToFileOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFileWithResponse(java.lang.String,com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.ParallelTransferOptions,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadToFileWithResponse(java.lang.String,com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.ParallelTransferOptions,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean,java.util.Set<java.nio.file.OpenOption>)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.downloadWithResponse(com.azure.storage.blob.models.BlobRange,com.azure.storage.blob.models.DownloadRetryOptions,com.azure.storage.blob.models.BlobRequestConditions,boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.exists()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.existsWithResponse()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues,com.azure.core.util.Context)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateUserDelegationSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues,com.azure.storage.blob.models.UserDelegationKey)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.generateUserDelegationSas(com.azure.storage.blob.sas.BlobServiceSasSignatureValues,com.azure.storage.blob.models.UserDelegationKey,java.lang.String,com.azure.core.util.Context)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountInfo()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountInfoWithResponse()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountName()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getAccountUrl()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getBlobName()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getBlobUrl()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getContainerAsyncClient()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getContainerName()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getCustomerProvidedKey()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getCustomerProvidedKeyAsyncClient(com.azure.storage.blob.models.CustomerProvidedKey)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getEncryptionScope()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getEncryptionScopeAsyncClient(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getHttpPipeline()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getProperties()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getPropertiesWithResponse(com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getServiceVersion()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getSnapshotClient(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getSnapshotId()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getTags()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getTagsWithResponse(com.azure.storage.blob.options.BlobGetTagsOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getVersionClient(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.getVersionId()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.isSnapshot()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.query(java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.queryWithResponse(com.azure.storage.blob.options.BlobQueryOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setAccessTier(com.azure.storage.blob.models.AccessTier)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setAccessTierWithResponse(com.azure.storage.blob.models.AccessTier,com.azure.storage.blob.models.RehydratePriority,java.lang.String)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setAccessTierWithResponse(com.azure.storage.blob.options.BlobSetAccessTierOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setHttpHeaders(com.azure.storage.blob.models.BlobHttpHeaders)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setHttpHeadersWithResponse(com.azure.storage.blob.models.BlobHttpHeaders,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setImmutabilityPolicy(com.azure.storage.blob.models.BlobImmutabilityPolicy)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setImmutabilityPolicyWithResponse(com.azure.storage.blob.models.BlobImmutabilityPolicy,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setLegalHold(boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setLegalHoldWithResponse(boolean)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setMetadata(java.util.Map<java.lang.String,java.lang.String>)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setMetadataWithResponse(java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.BlobRequestConditions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setTags(java.util.Map<java.lang.String,java.lang.String>)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.setTagsWithResponse(com.azure.storage.blob.options.BlobSetTagsOptions)"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.undelete()"
- "com.azure.storage.blob.specialized.BlobAsyncClientBase.undeleteWithResponse()"
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
syntax: "public class BlobAsyncClient extends BlobAsyncClientBase"
constructors:
- uid: "com.azure.storage.blob.BlobAsyncClient.BlobAsyncClient(com.azure.core.http.HttpPipeline,java.lang.String,com.azure.storage.blob.BlobServiceVersion,java.lang.String,java.lang.String,java.lang.String,java.lang.String,com.azure.storage.blob.models.CpkInfo)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey)"
  name: "BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey)"
  nameWithType: "BlobAsyncClient.BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey)"
  summary: "Protected constructor for use by <xref uid=\"com.azure.storage.blob.BlobClientBuilder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobClientBuilder\"></xref>."
  modifiers:
  - "protected"
  parameters:
  - description: "The pipeline used to send and receive service requests."
    name: "pipeline"
    type: "<xref href=\"com.azure.core.http.HttpPipeline?alt=com.azure.core.http.HttpPipeline&text=HttpPipeline\" data-throw-if-not-resolved=\"False\" />"
  - description: "The endpoint where to send service requests."
    name: "url"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The version of the service to receive requests."
    name: "serviceVersion"
    type: "<xref href=\"com.azure.storage.blob.BlobServiceVersion?alt=com.azure.storage.blob.BlobServiceVersion&text=BlobServiceVersion\" data-throw-if-not-resolved=\"False\" />"
  - description: "The storage account name."
    name: "accountName"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The container name."
    name: "containerName"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The blob name."
    name: "blobName"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The snapshot identifier for the blob, pass <code>null</code> to interact with the blob directly."
    name: "snapshot"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "Customer provided key used during encryption of the blob's data on the server, pass\n <code>null</code> to allow the service to use its own encryption."
    name: "customerProvidedKey"
    type: "<xref href=\"com.azure.storage.blob.models.CpkInfo?alt=com.azure.storage.blob.models.CpkInfo&text=CpkInfo\" data-throw-if-not-resolved=\"False\" />"
  syntax: "protected BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey)"
  desc: "Protected constructor for use by <xref uid=\"com.azure.storage.blob.BlobClientBuilder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobClientBuilder\"></xref>."
- uid: "com.azure.storage.blob.BlobAsyncClient.BlobAsyncClient(com.azure.core.http.HttpPipeline,java.lang.String,com.azure.storage.blob.BlobServiceVersion,java.lang.String,java.lang.String,java.lang.String,java.lang.String,com.azure.storage.blob.models.CpkInfo,com.azure.storage.blob.implementation.models.EncryptionScope)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey, EncryptionScope encryptionScope)"
  name: "BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey, EncryptionScope encryptionScope)"
  nameWithType: "BlobAsyncClient.BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey, EncryptionScope encryptionScope)"
  summary: "Protected constructor for use by <xref uid=\"com.azure.storage.blob.BlobClientBuilder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobClientBuilder\"></xref>."
  modifiers:
  - "protected"
  parameters:
  - description: "The pipeline used to send and receive service requests."
    name: "pipeline"
    type: "<xref href=\"com.azure.core.http.HttpPipeline?alt=com.azure.core.http.HttpPipeline&text=HttpPipeline\" data-throw-if-not-resolved=\"False\" />"
  - description: "The endpoint where to send service requests."
    name: "url"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The version of the service to receive requests."
    name: "serviceVersion"
    type: "<xref href=\"com.azure.storage.blob.BlobServiceVersion?alt=com.azure.storage.blob.BlobServiceVersion&text=BlobServiceVersion\" data-throw-if-not-resolved=\"False\" />"
  - description: "The storage account name."
    name: "accountName"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The container name."
    name: "containerName"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The blob name."
    name: "blobName"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The snapshot identifier for the blob, pass <code>null</code> to interact with the blob directly."
    name: "snapshot"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "Customer provided key used during encryption of the blob's data on the server, pass\n <code>null</code> to allow the service to use its own encryption."
    name: "customerProvidedKey"
    type: "<xref href=\"com.azure.storage.blob.models.CpkInfo?alt=com.azure.storage.blob.models.CpkInfo&text=CpkInfo\" data-throw-if-not-resolved=\"False\" />"
  - description: "Encryption scope used during encryption of the blob's data on the server, pass\n <code>null</code> to allow the service to use its own encryption."
    name: "encryptionScope"
    type: "<xref href=\"com.azure.storage.blob.implementation.models.EncryptionScope?alt=com.azure.storage.blob.implementation.models.EncryptionScope&text=EncryptionScope\" data-throw-if-not-resolved=\"False\" />"
  syntax: "protected BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey, EncryptionScope encryptionScope)"
  desc: "Protected constructor for use by <xref uid=\"com.azure.storage.blob.BlobClientBuilder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobClientBuilder\"></xref>."
- uid: "com.azure.storage.blob.BlobAsyncClient.BlobAsyncClient(com.azure.core.http.HttpPipeline,java.lang.String,com.azure.storage.blob.BlobServiceVersion,java.lang.String,java.lang.String,java.lang.String,java.lang.String,com.azure.storage.blob.models.CpkInfo,com.azure.storage.blob.implementation.models.EncryptionScope,java.lang.String)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey, EncryptionScope encryptionScope, String versionId)"
  name: "BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey, EncryptionScope encryptionScope, String versionId)"
  nameWithType: "BlobAsyncClient.BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey, EncryptionScope encryptionScope, String versionId)"
  summary: "Protected constructor for use by <xref uid=\"com.azure.storage.blob.BlobClientBuilder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobClientBuilder\"></xref>."
  modifiers:
  - "protected"
  parameters:
  - description: "The pipeline used to send and receive service requests."
    name: "pipeline"
    type: "<xref href=\"com.azure.core.http.HttpPipeline?alt=com.azure.core.http.HttpPipeline&text=HttpPipeline\" data-throw-if-not-resolved=\"False\" />"
  - description: "The endpoint where to send service requests."
    name: "url"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The version of the service to receive requests."
    name: "serviceVersion"
    type: "<xref href=\"com.azure.storage.blob.BlobServiceVersion?alt=com.azure.storage.blob.BlobServiceVersion&text=BlobServiceVersion\" data-throw-if-not-resolved=\"False\" />"
  - description: "The storage account name."
    name: "accountName"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The container name."
    name: "containerName"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The blob name."
    name: "blobName"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "The snapshot identifier for the blob, pass <code>null</code> to interact with the blob directly."
    name: "snapshot"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "Customer provided key used during encryption of the blob's data on the server, pass\n <code>null</code> to allow the service to use its own encryption."
    name: "customerProvidedKey"
    type: "<xref href=\"com.azure.storage.blob.models.CpkInfo?alt=com.azure.storage.blob.models.CpkInfo&text=CpkInfo\" data-throw-if-not-resolved=\"False\" />"
  - description: "Encryption scope used during encryption of the blob's data on the server, pass\n <code>null</code> to allow the service to use its own encryption."
    name: "encryptionScope"
    type: "<xref href=\"com.azure.storage.blob.implementation.models.EncryptionScope?alt=com.azure.storage.blob.implementation.models.EncryptionScope&text=EncryptionScope\" data-throw-if-not-resolved=\"False\" />"
  - description: "The version identifier for the blob, pass <code>null</code> to interact with the latest blob version."
    name: "versionId"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "protected BlobAsyncClient(HttpPipeline pipeline, String url, BlobServiceVersion serviceVersion, String accountName, String containerName, String blobName, String snapshot, CpkInfo customerProvidedKey, EncryptionScope encryptionScope, String versionId)"
  desc: "Protected constructor for use by <xref uid=\"com.azure.storage.blob.BlobClientBuilder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobClientBuilder\"></xref>."
fields:
- uid: "com.azure.storage.blob.BlobAsyncClient.BLOB_DEFAULT_HTBB_UPLOAD_BLOCK_SIZE"
  fullName: "com.azure.storage.blob.BlobAsyncClient.BLOB_DEFAULT_HTBB_UPLOAD_BLOCK_SIZE"
  name: "BLOB_DEFAULT_HTBB_UPLOAD_BLOCK_SIZE"
  nameWithType: "BlobAsyncClient.BLOB_DEFAULT_HTBB_UPLOAD_BLOCK_SIZE"
  summary: "If a blob is known to be greater than 100MB, using a larger block size will trigger some server-side optimizations."
  modifiers:
  - "static"
  - "final"
  field:
    value: "8388608"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final int BLOB_DEFAULT_HTBB_UPLOAD_BLOCK_SIZE"
  desc: "If a blob is known to be greater than 100MB, using a larger block size will trigger some server-side optimizations. If the block size is not set and the size of the blob is known to be greater than 100MB, this value will be used."
- uid: "com.azure.storage.blob.BlobAsyncClient.BLOB_DEFAULT_NUMBER_OF_BUFFERS"
  fullName: "com.azure.storage.blob.BlobAsyncClient.BLOB_DEFAULT_NUMBER_OF_BUFFERS"
  name: "BLOB_DEFAULT_NUMBER_OF_BUFFERS"
  nameWithType: "BlobAsyncClient.BLOB_DEFAULT_NUMBER_OF_BUFFERS"
  summary: "The number of buffers to use if none is specified on the buffered upload method."
  modifiers:
  - "static"
  - "final"
  field:
    value: "8"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final int BLOB_DEFAULT_NUMBER_OF_BUFFERS"
  desc: "The number of buffers to use if none is specified on the buffered upload method."
- uid: "com.azure.storage.blob.BlobAsyncClient.BLOB_DEFAULT_UPLOAD_BLOCK_SIZE"
  fullName: "com.azure.storage.blob.BlobAsyncClient.BLOB_DEFAULT_UPLOAD_BLOCK_SIZE"
  name: "BLOB_DEFAULT_UPLOAD_BLOCK_SIZE"
  nameWithType: "BlobAsyncClient.BLOB_DEFAULT_UPLOAD_BLOCK_SIZE"
  summary: "The block size to use if none is specified in parallel operations."
  modifiers:
  - "static"
  - "final"
  field:
    value: "4194304"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static final int BLOB_DEFAULT_UPLOAD_BLOCK_SIZE"
  desc: "The block size to use if none is specified in parallel operations."
methods:
- uid: "com.azure.storage.blob.BlobAsyncClient.getAppendBlobAsyncClient()"
  fullName: "com.azure.storage.blob.BlobAsyncClient.getAppendBlobAsyncClient()"
  name: "getAppendBlobAsyncClient()"
  nameWithType: "BlobAsyncClient.getAppendBlobAsyncClient()"
  summary: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobAsyncClient\"></xref> associated with this blob."
  syntax: "public AppendBlobAsyncClient getAppendBlobAsyncClient()"
  desc: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobAsyncClient\"></xref> associated with this blob."
  returns:
    description: "A <xref uid=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AppendBlobAsyncClient\"></xref> associated with this blob."
    type: "<xref href=\"com.azure.storage.blob.specialized.AppendBlobAsyncClient?alt=com.azure.storage.blob.specialized.AppendBlobAsyncClient&text=AppendBlobAsyncClient\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.BlobAsyncClient.getBlockBlobAsyncClient()"
  fullName: "com.azure.storage.blob.BlobAsyncClient.getBlockBlobAsyncClient()"
  name: "getBlockBlobAsyncClient()"
  nameWithType: "BlobAsyncClient.getBlockBlobAsyncClient()"
  summary: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobAsyncClient\"></xref> associated with this blob."
  syntax: "public BlockBlobAsyncClient getBlockBlobAsyncClient()"
  desc: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobAsyncClient\"></xref> associated with this blob."
  returns:
    description: "A <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlockBlobAsyncClient\"></xref> associated with this blob."
    type: "<xref href=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient?alt=com.azure.storage.blob.specialized.BlockBlobAsyncClient&text=BlockBlobAsyncClient\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.BlobAsyncClient.getCustomerProvidedKeyAsyncClient(com.azure.storage.blob.models.CustomerProvidedKey)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  name: "getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  nameWithType: "BlobAsyncClient.getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  summary: "Creates a new <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> with the specified `customerProvidedKey`."
  overridden: "com.azure.storage.blob.specialized.BlobAsyncClientBase.getCustomerProvidedKeyAsyncClient(com.azure.storage.blob.models.CustomerProvidedKey)"
  parameters:
  - description: "the <xref uid=\"com.azure.storage.blob.models.CustomerProvidedKey\" data-throw-if-not-resolved=\"false\" data-raw-source=\"CustomerProvidedKey\"></xref> for the blob,\n pass <code>null</code> to use no customer provided key."
    name: "customerProvidedKey"
    type: "<xref href=\"com.azure.storage.blob.models.CustomerProvidedKey?alt=com.azure.storage.blob.models.CustomerProvidedKey&text=CustomerProvidedKey\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public BlobAsyncClient getCustomerProvidedKeyAsyncClient(CustomerProvidedKey customerProvidedKey)"
  desc: "Creates a new <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> with the specified `customerProvidedKey`."
  returns:
    description: "a <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> with the specified <code>customerProvidedKey</code>."
    type: "<xref href=\"com.azure.storage.blob.BlobAsyncClient?alt=com.azure.storage.blob.BlobAsyncClient&text=BlobAsyncClient\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.BlobAsyncClient.getEncryptionScopeAsyncClient(java.lang.String)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.getEncryptionScopeAsyncClient(String encryptionScope)"
  name: "getEncryptionScopeAsyncClient(String encryptionScope)"
  nameWithType: "BlobAsyncClient.getEncryptionScopeAsyncClient(String encryptionScope)"
  summary: "Creates a new <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> with the specified `encryptionScope`."
  overridden: "com.azure.storage.blob.specialized.BlobAsyncClientBase.getEncryptionScopeAsyncClient(java.lang.String)"
  parameters:
  - description: "the encryption scope for the blob, pass <code>null</code> to use no encryption scope."
    name: "encryptionScope"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public BlobAsyncClient getEncryptionScopeAsyncClient(String encryptionScope)"
  desc: "Creates a new <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> with the specified `encryptionScope`."
  returns:
    description: "a <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> with the specified <code>encryptionScope</code>."
    type: "<xref href=\"com.azure.storage.blob.BlobAsyncClient?alt=com.azure.storage.blob.BlobAsyncClient&text=BlobAsyncClient\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.BlobAsyncClient.getPageBlobAsyncClient()"
  fullName: "com.azure.storage.blob.BlobAsyncClient.getPageBlobAsyncClient()"
  name: "getPageBlobAsyncClient()"
  nameWithType: "BlobAsyncClient.getPageBlobAsyncClient()"
  summary: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.PageBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PageBlobAsyncClient\"></xref> associated with this blob."
  syntax: "public PageBlobAsyncClient getPageBlobAsyncClient()"
  desc: "Creates a new <xref uid=\"com.azure.storage.blob.specialized.PageBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PageBlobAsyncClient\"></xref> associated with this blob."
  returns:
    description: "A <xref uid=\"com.azure.storage.blob.specialized.PageBlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PageBlobAsyncClient\"></xref> associated with this blob."
    type: "<xref href=\"com.azure.storage.blob.specialized.PageBlobAsyncClient?alt=com.azure.storage.blob.specialized.PageBlobAsyncClient&text=PageBlobAsyncClient\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.BlobAsyncClient.getSnapshotClient(java.lang.String)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.getSnapshotClient(String snapshot)"
  name: "getSnapshotClient(String snapshot)"
  nameWithType: "BlobAsyncClient.getSnapshotClient(String snapshot)"
  summary: "Creates a new <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> linked to the `snapshot` of this blob resource."
  overridden: "com.azure.storage.blob.specialized.BlobAsyncClientBase.getSnapshotClient(java.lang.String)"
  parameters:
  - description: "the identifier for a specific snapshot of this blob"
    name: "snapshot"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public BlobAsyncClient getSnapshotClient(String snapshot)"
  desc: "Creates a new <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> linked to the `snapshot` of this blob resource."
  returns:
    description: "A <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> used to interact with the specific snapshot."
    type: "<xref href=\"com.azure.storage.blob.BlobAsyncClient?alt=com.azure.storage.blob.BlobAsyncClient&text=BlobAsyncClient\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.BlobAsyncClient.getVersionClient(java.lang.String)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.getVersionClient(String versionId)"
  name: "getVersionClient(String versionId)"
  nameWithType: "BlobAsyncClient.getVersionClient(String versionId)"
  summary: "Creates a new <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> linked to the `versionId` of this blob resource."
  overridden: "com.azure.storage.blob.specialized.BlobAsyncClientBase.getVersionClient(java.lang.String)"
  parameters:
  - description: "the identifier for a specific version of this blob,\n pass <code>null</code> to interact with the latest blob version."
    name: "versionId"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public BlobAsyncClient getVersionClient(String versionId)"
  desc: "Creates a new <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> linked to the `versionId` of this blob resource."
  returns:
    description: "A <xref uid=\"com.azure.storage.blob.BlobAsyncClient\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobAsyncClient\"></xref> used to interact with the specific version."
    type: "<xref href=\"com.azure.storage.blob.BlobAsyncClient?alt=com.azure.storage.blob.BlobAsyncClient&text=BlobAsyncClient\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.BlobAsyncClient.upload(com.azure.core.util.BinaryData)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.upload(BinaryData data)"
  name: "upload(BinaryData data)"
  nameWithType: "BlobAsyncClient.upload(BinaryData data)"
  summary: "Creates a new block blob."
  parameters:
  - description: "The data to write to the blob."
    name: "data"
    type: "<xref href=\"com.azure.core.util.BinaryData?alt=com.azure.core.util.BinaryData&text=BinaryData\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<BlockBlobItem> upload(BinaryData data)"
  desc: "Creates a new block blob. By default, this method will not overwrite an existing blob.\n\n**Code Samples**\n\n```java\nclient.upload(BinaryData.fromString(\"Data!\")).subscribe(response ->\n     System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getContentMd5())));\n```"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.BlobAsyncClient.upload(com.azure.core.util.BinaryData,boolean)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.upload(BinaryData data, boolean overwrite)"
  name: "upload(BinaryData data, boolean overwrite)"
  nameWithType: "BlobAsyncClient.upload(BinaryData data, boolean overwrite)"
  summary: "Creates a new block blob, or updates the content of an existing block blob."
  parameters:
  - description: "The data to write to the blob."
    name: "data"
    type: "<xref href=\"com.azure.core.util.BinaryData?alt=com.azure.core.util.BinaryData&text=BinaryData\" data-throw-if-not-resolved=\"False\" />"
  - description: "Whether to overwrite, should the blob already exist."
    name: "overwrite"
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<BlockBlobItem> upload(BinaryData data, boolean overwrite)"
  desc: "Creates a new block blob, or updates the content of an existing block blob.\n\n**Code Samples**\n\n```java\nboolean overwrite = false; // Default behavior\n client.upload(BinaryData.fromString(\"Data!\"), overwrite).subscribe(response ->\n     System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getContentMd5())));\n```"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.BlobAsyncClient.upload(reactor.core.publisher.Flux<java.nio.ByteBuffer>,com.azure.storage.blob.models.ParallelTransferOptions)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.upload(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions)"
  name: "upload(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions)"
  nameWithType: "BlobAsyncClient.upload(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions)"
  summary: "Creates a new block blob."
  parameters:
  - description: "The data to write to the blob. Unlike other upload methods, this method does not require that the\n <code>Flux</code> be replayable. In other words, it does not have to support multiple subscribers and is not expected\n to produce the same values across subscriptions."
    name: "data"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "<xref uid=\"com.azure.storage.blob.models.ParallelTransferOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ParallelTransferOptions\"></xref> used to configure buffered uploading."
    name: "parallelTransferOptions"
    type: "<xref href=\"com.azure.storage.blob.models.ParallelTransferOptions?alt=com.azure.storage.blob.models.ParallelTransferOptions&text=ParallelTransferOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<BlockBlobItem> upload(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions)"
  desc: "Creates a new block blob. By default, this method will not overwrite an existing blob.\n\nUpdating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with this method; the content of the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlock(java.lang.String,reactor.core.publisher.Flux<java.nio.ByteBuffer>,long)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"stageBlock\"></xref> and <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockList(java.util.List<java.lang.String>)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"commitBlockList\"></xref>. For more information, see the [Azure Docs for Put Block][] and the [Azure Docs for Put Block List][].\n\nThe data passed need not support multiple subscriptions/be replayable as is required in other upload methods when retries are enabled, and the length of the data need not be known in advance. Therefore, this method does support uploading any arbitrary data source, including network streams. This behavior is possible because this method will perform some internal buffering as configured by the blockSize and numBuffers parameters, so while this method may offer additional convenience, it will not be as performant as other options, which should be preferred when possible.\n\nTypically, the greater the number of buffers used, the greater the possible parallelism when transferring the data. Larger buffers means we will have to stage fewer blocks and therefore require fewer IO operations. The trade-offs between these values are context-dependent, so some experimentation may be required to optimize inputs for a given scenario.\n\n**Code Samples**\n\n```java\nParallelTransferOptions parallelTransferOptions = new ParallelTransferOptions()\n     .setBlockSizeLong(blockSize)\n     .setMaxConcurrency(maxConcurrency);\n client.upload(data, parallelTransferOptions).subscribe(response ->\n     System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getContentMd5())));\n```\n\n\n[Azure Docs for Put Block]: https://docs.microsoft.com/rest/api/storageservices/put-block\n[Azure Docs for Put Block List]: https://docs.microsoft.com/rest/api/storageservices/put-block-list"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.BlobAsyncClient.upload(reactor.core.publisher.Flux<java.nio.ByteBuffer>,com.azure.storage.blob.models.ParallelTransferOptions,boolean)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.upload(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, boolean overwrite)"
  name: "upload(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, boolean overwrite)"
  nameWithType: "BlobAsyncClient.upload(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, boolean overwrite)"
  summary: "Creates a new block blob, or updates the content of an existing block blob."
  parameters:
  - description: "The data to write to the blob. Unlike other upload methods, this method does not require that the\n <code>Flux</code> be replayable. In other words, it does not have to support multiple subscribers and is not expected\n to produce the same values across subscriptions."
    name: "data"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "<xref uid=\"com.azure.storage.blob.models.ParallelTransferOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ParallelTransferOptions\"></xref> used to configure buffered uploading."
    name: "parallelTransferOptions"
    type: "<xref href=\"com.azure.storage.blob.models.ParallelTransferOptions?alt=com.azure.storage.blob.models.ParallelTransferOptions&text=ParallelTransferOptions\" data-throw-if-not-resolved=\"False\" />"
  - description: "Whether to overwrite, should the blob already exist."
    name: "overwrite"
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<BlockBlobItem> upload(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, boolean overwrite)"
  desc: "Creates a new block blob, or updates the content of an existing block blob.\n\nUpdating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with this method; the content of the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlock(java.lang.String,reactor.core.publisher.Flux<java.nio.ByteBuffer>,long)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"stageBlock\"></xref> and <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockList(java.util.List<java.lang.String>)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"commitBlockList\"></xref>. For more information, see the [Azure Docs for Put Block][] and the [Azure Docs for Put Block List][].\n\nThe data passed need not support multiple subscriptions/be replayable as is required in other upload methods when retries are enabled, and the length of the data need not be known in advance. Therefore, this method does support uploading any arbitrary data source, including network streams. This behavior is possible because this method will perform some internal buffering as configured by the blockSize and numBuffers parameters, so while this method may offer additional convenience, it will not be as performant as other options, which should be preferred when possible.\n\nTypically, the greater the number of buffers used, the greater the possible parallelism when transferring the data. Larger buffers means we will have to stage fewer blocks and therefore require fewer IO operations. The trade-offs between these values are context-dependent, so some experimentation may be required to optimize inputs for a given scenario.\n\n**Code Samples**\n\n```java\nParallelTransferOptions parallelTransferOptions = new ParallelTransferOptions()\n     .setBlockSizeLong(blockSize)\n     .setMaxConcurrency(maxConcurrency);\n boolean overwrite = false; // Default behavior\n client.upload(data, parallelTransferOptions, overwrite).subscribe(response ->\n     System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getContentMd5())));\n```\n\n\n[Azure Docs for Put Block]: https://docs.microsoft.com/rest/api/storageservices/put-block\n[Azure Docs for Put Block List]: https://docs.microsoft.com/rest/api/storageservices/put-block-list"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.BlobAsyncClient.uploadFileResourceSupplier(java.lang.String)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.uploadFileResourceSupplier(String filePath)"
  name: "uploadFileResourceSupplier(String filePath)"
  nameWithType: "BlobAsyncClient.uploadFileResourceSupplier(String filePath)"
  summary: "RESERVED FOR INTERNAL USE."
  deprecatedTag: "due to refactoring code to be in the common storage library."
  modifiers:
  - "protected"
  parameters:
  - description: "The path for the file"
    name: "filePath"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "@Deprecated\nprotected AsynchronousFileChannel uploadFileResourceSupplier(String filePath)"
  desc: "RESERVED FOR INTERNAL USE. Resource Supplier for UploadFile."
  hasDeprecatedTag: true
  returns:
    description: "<code>AsynchronousFileChannel</code>"
    type: "<xref href=\"java.nio.channels.AsynchronousFileChannel?alt=java.nio.channels.AsynchronousFileChannel&text=AsynchronousFileChannel\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.storage.blob.BlobAsyncClient.uploadFromFile(java.lang.String)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.uploadFromFile(String filePath)"
  name: "uploadFromFile(String filePath)"
  nameWithType: "BlobAsyncClient.uploadFromFile(String filePath)"
  summary: "Creates a new block blob with the content of the specified file."
  parameters:
  - description: "Path to the upload file"
    name: "filePath"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> uploadFromFile(String filePath)"
  desc: "Creates a new block blob with the content of the specified file. By default, this method will not overwrite an existing blob.\n\n**Code Samples**\n\n```java\nclient.uploadFromFile(filePath)\n     .doOnError(throwable -> System.err.printf(\"Failed to upload from file %s%n\", throwable.getMessage()))\n     .subscribe(completion -> System.out.println(\"Upload from file succeeded\"));\n```"
  returns:
    description: "An empty response"
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.BlobAsyncClient.uploadFromFile(java.lang.String,boolean)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.uploadFromFile(String filePath, boolean overwrite)"
  name: "uploadFromFile(String filePath, boolean overwrite)"
  nameWithType: "BlobAsyncClient.uploadFromFile(String filePath, boolean overwrite)"
  summary: "Creates a new block blob, or updates the content of an existing block blob, with the content of the specified file."
  parameters:
  - description: "Path to the upload file"
    name: "filePath"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "Whether to overwrite, should the blob already exist."
    name: "overwrite"
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> uploadFromFile(String filePath, boolean overwrite)"
  desc: "Creates a new block blob, or updates the content of an existing block blob, with the content of the specified file.\n\n**Code Samples**\n\n```java\nboolean overwrite = false; // Default behavior\n client.uploadFromFile(filePath, overwrite)\n     .doOnError(throwable -> System.err.printf(\"Failed to upload from file %s%n\", throwable.getMessage()))\n     .subscribe(completion -> System.out.println(\"Upload from file succeeded\"));\n```"
  returns:
    description: "An empty response"
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.BlobAsyncClient.uploadFromFile(java.lang.String,com.azure.storage.blob.models.ParallelTransferOptions,com.azure.storage.blob.models.BlobHttpHeaders,java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.AccessTier,com.azure.storage.blob.models.BlobRequestConditions)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.uploadFromFile(String filePath, ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  name: "uploadFromFile(String filePath, ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  nameWithType: "BlobAsyncClient.uploadFromFile(String filePath, ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  summary: "Creates a new block blob, or updates the content of an existing block blob, with the content of the specified file."
  parameters:
  - description: "Path to the upload file"
    name: "filePath"
    type: "<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.ParallelTransferOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ParallelTransferOptions\"></xref> to use to upload from file. Number of parallel\n transfers parameter is ignored."
    name: "parallelTransferOptions"
    type: "<xref href=\"com.azure.storage.blob.models.ParallelTransferOptions?alt=com.azure.storage.blob.models.ParallelTransferOptions&text=ParallelTransferOptions\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobHttpHeaders\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobHttpHeaders\"></xref>"
    name: "headers"
    type: "<xref href=\"com.azure.storage.blob.models.BlobHttpHeaders?alt=com.azure.storage.blob.models.BlobHttpHeaders&text=BlobHttpHeaders\" data-throw-if-not-resolved=\"False\" />"
  - description: "Metadata to associate with the blob. If there is leading or trailing whitespace in any\n metadata key or value, it must be removed or encoded."
    name: "metadata"
    type: "<xref href=\"java.util.Map?alt=java.util.Map&text=Map\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />,<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "<xref uid=\"com.azure.storage.blob.models.AccessTier\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AccessTier\"></xref> for the destination blob."
    name: "tier"
    type: "<xref href=\"com.azure.storage.blob.models.AccessTier?alt=com.azure.storage.blob.models.AccessTier&text=AccessTier\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobRequestConditions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions\"></xref>"
    name: "requestConditions"
    type: "<xref href=\"com.azure.storage.blob.models.BlobRequestConditions?alt=com.azure.storage.blob.models.BlobRequestConditions&text=BlobRequestConditions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Void> uploadFromFile(String filePath, ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  desc: "Creates a new block blob, or updates the content of an existing block blob, with the content of the specified file.\n\nTo avoid overwriting, pass \"\\*\" to <xref uid=\"com.azure.storage.blob.models.BlobRequestConditions.setIfNoneMatch(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions#setIfNoneMatch(String)\"></xref>.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n     .setContentLanguage(\"en-US\")\n     .setContentType(\"binary\");\n\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n BlobRequestConditions requestConditions = new BlobRequestConditions()\n     .setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.uploadFromFile(filePath,\n     new ParallelTransferOptions().setBlockSizeLong(BlockBlobClient.MAX_STAGE_BLOCK_BYTES_LONG),\n     headers, metadata, AccessTier.HOT, requestConditions)\n     .doOnError(throwable -> System.err.printf(\"Failed to upload from file %s%n\", throwable.getMessage()))\n     .subscribe(completion -> System.out.println(\"Upload from file succeeded\"));\n```"
  returns:
    description: "An empty response"
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.storage.blob.BlobAsyncClient.uploadFromFileWithResponse(com.azure.storage.blob.options.BlobUploadFromFileOptions)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.uploadFromFileWithResponse(BlobUploadFromFileOptions options)"
  name: "uploadFromFileWithResponse(BlobUploadFromFileOptions options)"
  nameWithType: "BlobAsyncClient.uploadFromFileWithResponse(BlobUploadFromFileOptions options)"
  summary: "Creates a new block blob, or updates the content of an existing block blob, with the content of the specified file."
  parameters:
  - description: "<xref uid=\"com.azure.storage.blob.options.BlobUploadFromFileOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobUploadFromFileOptions\"></xref>"
    name: "options"
    type: "<xref href=\"com.azure.storage.blob.options.BlobUploadFromFileOptions?alt=com.azure.storage.blob.options.BlobUploadFromFileOptions&text=BlobUploadFromFileOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<BlockBlobItem>> uploadFromFileWithResponse(BlobUploadFromFileOptions options)"
  desc: "Creates a new block blob, or updates the content of an existing block blob, with the content of the specified file.\n\nTo avoid overwriting, pass \"\\*\" to <xref uid=\"com.azure.storage.blob.models.BlobRequestConditions.setIfNoneMatch(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions#setIfNoneMatch(String)\"></xref>.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n     .setContentLanguage(\"en-US\")\n     .setContentType(\"binary\");\n\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n Map<String, String> tags = Collections.singletonMap(\"tag\", \"value\");\n BlobRequestConditions requestConditions = new BlobRequestConditions()\n     .setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n client.uploadFromFileWithResponse(new BlobUploadFromFileOptions(filePath)\n     .setParallelTransferOptions(\n         new ParallelTransferOptions().setBlockSizeLong(BlobAsyncClient.BLOB_MAX_UPLOAD_BLOCK_SIZE))\n     .setHeaders(headers).setMetadata(metadata).setTags(tags).setTier(AccessTier.HOT)\n     .setRequestConditions(requestConditions))\n     .doOnError(throwable -> System.err.printf(\"Failed to upload from file %s%n\", throwable.getMessage()))\n     .subscribe(completion -> System.out.println(\"Upload from file succeeded\"));\n```"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.BlobAsyncClient.uploadWithResponse(com.azure.storage.blob.options.BlobParallelUploadOptions)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.uploadWithResponse(BlobParallelUploadOptions options)"
  name: "uploadWithResponse(BlobParallelUploadOptions options)"
  nameWithType: "BlobAsyncClient.uploadWithResponse(BlobParallelUploadOptions options)"
  summary: "Creates a new block blob, or updates the content of an existing block blob."
  parameters:
  - description: "<xref uid=\"com.azure.storage.blob.options.BlobParallelUploadOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobParallelUploadOptions\"></xref>. Unlike other upload methods, this method does not require that\n the <code>Flux</code> be replayable. In other words, it does not have to support multiple subscribers and is not\n expected to produce the same values across subscriptions."
    name: "options"
    type: "<xref href=\"com.azure.storage.blob.options.BlobParallelUploadOptions?alt=com.azure.storage.blob.options.BlobParallelUploadOptions&text=BlobParallelUploadOptions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<BlockBlobItem>> uploadWithResponse(BlobParallelUploadOptions options)"
  desc: "Creates a new block blob, or updates the content of an existing block blob.\n\nUpdating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with this method; the content of the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlock(java.lang.String,reactor.core.publisher.Flux<java.nio.ByteBuffer>,long)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"stageBlock\"></xref> and <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockList(java.util.List<java.lang.String>)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"commitBlockList\"></xref>. For more information, see the [Azure Docs for Put Block][] and the [Azure Docs for Put Block List][].\n\nThe data passed need not support multiple subscriptions/be replayable as is required in other upload methods when retries are enabled, and the length of the data need not be known in advance. Therefore, this method does support uploading any arbitrary data source, including network streams. This behavior is possible because this method will perform some internal buffering as configured by the blockSize and numBuffers parameters, so while this method may offer additional convenience, it will not be as performant as other options, which should be preferred when possible.\n\nTypically, the greater the number of buffers used, the greater the possible parallelism when transferring the data. Larger buffers means we will have to stage fewer blocks and therefore require fewer IO operations. The trade-offs between these values are context-dependent, so some experimentation may be required to optimize inputs for a given scenario.\n\nTo avoid overwriting, pass \"\\*\" to <xref uid=\"com.azure.storage.blob.models.BlobRequestConditions.setIfNoneMatch(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions#setIfNoneMatch(String)\"></xref>.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n     .setContentLanguage(\"en-US\")\n     .setContentType(\"binary\");\n\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n Map<String, String> tags = Collections.singletonMap(\"tag\", \"value\");\n BlobRequestConditions requestConditions = new BlobRequestConditions()\n     .setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n ParallelTransferOptions parallelTransferOptions = new ParallelTransferOptions().setBlockSizeLong(blockSize)\n     .setMaxConcurrency(maxConcurrency).setProgressReceiver(bytesTransferred ->\n         System.out.printf(\"Upload progress: %s bytes sent\", bytesTransferred));\n\n client.uploadWithResponse(new BlobParallelUploadOptions(data)\n     .setParallelTransferOptions(parallelTransferOptions).setHeaders(headers).setMetadata(metadata).setTags(tags)\n     .setTier(AccessTier.HOT).setRequestConditions(requestConditions))\n     .subscribe(response -> System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getValue().getContentMd5())));\n```\n\n**Using Progress Reporting**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n     .setContentLanguage(\"en-US\")\n     .setContentType(\"binary\");\n\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n Map<String, String> tags = Collections.singletonMap(\"tag\", \"value\");\n BlobRequestConditions requestConditions = new BlobRequestConditions()\n     .setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n ParallelTransferOptions parallelTransferOptions = new ParallelTransferOptions().setBlockSizeLong(blockSize)\n     .setMaxConcurrency(maxConcurrency).setProgressReceiver(bytesTransferred ->\n         System.out.printf(\"Upload progress: %s bytes sent\", bytesTransferred));\n\n client.uploadWithResponse(new BlobParallelUploadOptions(data)\n     .setParallelTransferOptions(parallelTransferOptions).setHeaders(headers).setMetadata(metadata).setTags(tags)\n     .setTier(AccessTier.HOT).setRequestConditions(requestConditions))\n     .subscribe(response -> System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getValue().getContentMd5())));\n```\n\n\n[Azure Docs for Put Block]: https://docs.microsoft.com/rest/api/storageservices/put-block\n[Azure Docs for Put Block List]: https://docs.microsoft.com/rest/api/storageservices/put-block-list"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
- uid: "com.azure.storage.blob.BlobAsyncClient.uploadWithResponse(reactor.core.publisher.Flux<java.nio.ByteBuffer>,com.azure.storage.blob.models.ParallelTransferOptions,com.azure.storage.blob.models.BlobHttpHeaders,java.util.Map<java.lang.String,java.lang.String>,com.azure.storage.blob.models.AccessTier,com.azure.storage.blob.models.BlobRequestConditions)"
  fullName: "com.azure.storage.blob.BlobAsyncClient.uploadWithResponse(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  name: "uploadWithResponse(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  nameWithType: "BlobAsyncClient.uploadWithResponse(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  summary: "Creates a new block blob, or updates the content of an existing block blob."
  parameters:
  - description: "The data to write to the blob. Unlike other upload methods, this method does not require that the\n <code>Flux</code> be replayable. In other words, it does not have to support multiple subscribers and is not expected\n to produce the same values across subscriptions."
    name: "data"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "<xref uid=\"com.azure.storage.blob.models.ParallelTransferOptions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ParallelTransferOptions\"></xref> used to configure buffered uploading."
    name: "parallelTransferOptions"
    type: "<xref href=\"com.azure.storage.blob.models.ParallelTransferOptions?alt=com.azure.storage.blob.models.ParallelTransferOptions&text=ParallelTransferOptions\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobHttpHeaders\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobHttpHeaders\"></xref>"
    name: "headers"
    type: "<xref href=\"com.azure.storage.blob.models.BlobHttpHeaders?alt=com.azure.storage.blob.models.BlobHttpHeaders&text=BlobHttpHeaders\" data-throw-if-not-resolved=\"False\" />"
  - description: "Metadata to associate with the blob. If there is leading or trailing whitespace in any\n metadata key or value, it must be removed or encoded."
    name: "metadata"
    type: "<xref href=\"java.util.Map?alt=java.util.Map&text=Map\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />,<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "<xref uid=\"com.azure.storage.blob.models.AccessTier\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AccessTier\"></xref> for the destination blob."
    name: "tier"
    type: "<xref href=\"com.azure.storage.blob.models.AccessTier?alt=com.azure.storage.blob.models.AccessTier&text=AccessTier\" data-throw-if-not-resolved=\"False\" />"
  - description: "<xref uid=\"com.azure.storage.blob.models.BlobRequestConditions\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions\"></xref>"
    name: "requestConditions"
    type: "<xref href=\"com.azure.storage.blob.models.BlobRequestConditions?alt=com.azure.storage.blob.models.BlobRequestConditions&text=BlobRequestConditions\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public Mono<Response<BlockBlobItem>> uploadWithResponse(Flux<ByteBuffer> data, ParallelTransferOptions parallelTransferOptions, BlobHttpHeaders headers, Map<String,String> metadata, AccessTier tier, BlobRequestConditions requestConditions)"
  desc: "Creates a new block blob, or updates the content of an existing block blob.\n\nUpdating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with this method; the content of the existing blob is overwritten with the new content. To perform a partial update of a block blob's, use <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient.stageBlock(java.lang.String,reactor.core.publisher.Flux<java.nio.ByteBuffer>,long)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"stageBlock\"></xref> and <xref uid=\"com.azure.storage.blob.specialized.BlockBlobAsyncClient.commitBlockList(java.util.List<java.lang.String>)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"commitBlockList\"></xref>. For more information, see the [Azure Docs for Put Block][] and the [Azure Docs for Put Block List][].\n\nThe data passed need not support multiple subscriptions/be replayable as is required in other upload methods when retries are enabled, and the length of the data need not be known in advance. Therefore, this method does support uploading any arbitrary data source, including network streams. This behavior is possible because this method will perform some internal buffering as configured by the blockSize and numBuffers parameters, so while this method may offer additional convenience, it will not be as performant as other options, which should be preferred when possible.\n\nTypically, the greater the number of buffers used, the greater the possible parallelism when transferring the data. Larger buffers means we will have to stage fewer blocks and therefore require fewer IO operations. The trade-offs between these values are context-dependent, so some experimentation may be required to optimize inputs for a given scenario.\n\nTo avoid overwriting, pass \"\\*\" to <xref uid=\"com.azure.storage.blob.models.BlobRequestConditions.setIfNoneMatch(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobRequestConditions#setIfNoneMatch(String)\"></xref>.\n\n**Code Samples**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n     .setContentLanguage(\"en-US\")\n     .setContentType(\"binary\");\n\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n BlobRequestConditions requestConditions = new BlobRequestConditions()\n     .setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n ParallelTransferOptions parallelTransferOptions = new ParallelTransferOptions()\n     .setBlockSizeLong(blockSize)\n     .setMaxConcurrency(maxConcurrency);\n\n client.uploadWithResponse(data, parallelTransferOptions, headers, metadata, AccessTier.HOT, requestConditions)\n     .subscribe(response -> System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getValue().getContentMd5())));\n```\n\n**Using Progress Reporting**\n\n```java\nBlobHttpHeaders headers = new BlobHttpHeaders()\n     .setContentMd5(\"data\".getBytes(StandardCharsets.UTF_8))\n     .setContentLanguage(\"en-US\")\n     .setContentType(\"binary\");\n\n Map<String, String> metadata = Collections.singletonMap(\"metadata\", \"value\");\n BlobRequestConditions requestConditions = new BlobRequestConditions()\n     .setLeaseId(leaseId)\n     .setIfUnmodifiedSince(OffsetDateTime.now().minusDays(3));\n\n ParallelTransferOptions parallelTransferOptions = new ParallelTransferOptions()\n     .setBlockSizeLong(blockSize)\n     .setMaxConcurrency(maxConcurrency)\n     .setProgressReceiver(bytesTransferred -> System.out.printf(\"Upload progress: %s bytes sent\", bytesTransferred));\n\n client.uploadWithResponse(data, parallelTransferOptions, headers, metadata, AccessTier.HOT, requestConditions)\n     .subscribe(response -> System.out.printf(\"Uploaded BlockBlob MD5 is %s%n\",\n         Base64.getEncoder().encodeToString(response.getValue().getContentMd5())));\n```\n\n\n[Azure Docs for Put Block]: https://docs.microsoft.com/rest/api/storageservices/put-block\n[Azure Docs for Put Block List]: https://docs.microsoft.com/rest/api/storageservices/put-block-list"
  returns:
    description: "A reactive response containing the information of the uploaded block blob."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.storage.blob.models.BlockBlobItem?alt=com.azure.storage.blob.models.BlockBlobItem&text=BlockBlobItem\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
type: "class"
desc: "This class provides a client that contains generic blob operations for Azure Storage Blobs. Operations allowed by the client are uploading and downloading, copying a blob, retrieving and setting metadata, retrieving and setting HTTP headers, and deleting and un-deleting a blob.\n\nThis client is instantiated through <xref uid=\"com.azure.storage.blob.BlobClientBuilder\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BlobClientBuilder\"></xref> or retrieved via <xref uid=\"com.azure.storage.blob.BlobContainerAsyncClient.getBlobAsyncClient(java.lang.String)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"getBlobAsyncClient\"></xref>.\n\nFor operations on a specific blob type (i.e. append, block, or page) use <xref uid=\"com.azure.storage.blob.BlobAsyncClient.getAppendBlobAsyncClient()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"getAppendBlobAsyncClient\"></xref>, <xref uid=\"com.azure.storage.blob.BlobAsyncClient.getBlockBlobAsyncClient()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"getBlockBlobAsyncClient\"></xref>, or <xref uid=\"com.azure.storage.blob.BlobAsyncClient.getPageBlobAsyncClient()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"getPageBlobAsyncClient\"></xref> to construct a client that allows blob specific operations.\n\nPlease refer to the [Azure Docs][] for more information.\n\n\n[Azure Docs]: https://docs.microsoft.com/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs"
metadata: {}
package: "com.azure.storage.blob"
artifact: com.azure:azure-storage-blob:12.18.0-beta.1
