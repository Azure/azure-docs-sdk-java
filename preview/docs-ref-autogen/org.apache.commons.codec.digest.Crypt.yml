### YamlMime:ManagedReference
items:
- uid: org.apache.commons.codec.digest.Crypt
  id: Crypt
  artifact: com.azure:azure-security-keyvault-jca:1.0.0-beta.2
  parent: org.apache.commons.codec.digest
  children:
  - org.apache.commons.codec.digest.Crypt.Crypt()
  - org.apache.commons.codec.digest.Crypt.crypt(byte[])
  - org.apache.commons.codec.digest.Crypt.crypt(byte[],java.lang.String)
  - org.apache.commons.codec.digest.Crypt.crypt(java.lang.String)
  - org.apache.commons.codec.digest.Crypt.crypt(java.lang.String,java.lang.String)
  langs:
  - java
  name: Crypt
  nameWithType: Crypt
  fullName: org.apache.commons.codec.digest.Crypt
  type: Class
  package: org.apache.commons.codec.digest
  summary: >-
    GNU libc crypt(3) compatible hash method.


    See <xref uid="org.apache.commons.codec.digest.Crypt.crypt(java.lang.String,java.lang.String)" data-throw-if-not-resolved="false">#crypt(String, String)</xref> for further details.


    This class is immutable and thread-safe.
  syntax:
    content: public class Crypt
  inheritance:
  - java.lang.Object
  inheritedMembers:
  - java.lang.Object.clone()
  - java.lang.Object.equals(java.lang.Object)
  - java.lang.Object.finalize()
  - java.lang.Object.getClass()
  - java.lang.Object.hashCode()
  - java.lang.Object.notify()
  - java.lang.Object.notifyAll()
  - java.lang.Object.toString()
  - java.lang.Object.wait()
  - java.lang.Object.wait(long)
  - java.lang.Object.wait(long,int)
- uid: org.apache.commons.codec.digest.Crypt.Crypt()
  id: Crypt()
  artifact: com.azure:azure-security-keyvault-jca:1.0.0-beta.2
  parent: org.apache.commons.codec.digest.Crypt
  langs:
  - java
  name: Crypt()
  nameWithType: Crypt.Crypt()
  fullName: org.apache.commons.codec.digest.Crypt.Crypt()
  overload: org.apache.commons.codec.digest.Crypt.Crypt*
  type: Constructor
  package: org.apache.commons.codec.digest
  syntax:
    content: public Crypt()
- uid: org.apache.commons.codec.digest.Crypt.crypt(byte[])
  id: crypt(byte[])
  artifact: com.azure:azure-security-keyvault-jca:1.0.0-beta.2
  parent: org.apache.commons.codec.digest.Crypt
  langs:
  - java
  name: crypt(byte[] keyBytes)
  nameWithType: Crypt.crypt(byte[] keyBytes)
  fullName: org.apache.commons.codec.digest.Crypt.crypt(byte[] keyBytes)
  overload: org.apache.commons.codec.digest.Crypt.crypt*
  type: Method
  package: org.apache.commons.codec.digest
  summary: >-
    Encrypts a password in a crypt(3) compatible way.


    A random salt and the default algorithm (currently SHA-512) are used. See <xref uid="org.apache.commons.codec.digest.Crypt.crypt(java.lang.String,java.lang.String)" data-throw-if-not-resolved="false">#crypt(String, String)</xref> for details.


    A salt is generated for you using <xref uid="" data-throw-if-not-resolved="false">ThreadLocalRandom</xref>; for more secure salts consider using <xref uid="" data-throw-if-not-resolved="false">SecureRandom</xref> to generate your own salts and calling <xref uid="org.apache.commons.codec.digest.Crypt.crypt(byte[],java.lang.String)" data-throw-if-not-resolved="false">#crypt(byte[], String)</xref>.
  syntax:
    content: public static String crypt(byte[] keyBytes)
    parameters:
    - id: keyBytes
      type: byte[]
      description: plaintext password
    return:
      type: java.lang.String
      description: hash value
- uid: org.apache.commons.codec.digest.Crypt.crypt(byte[],java.lang.String)
  id: crypt(byte[],java.lang.String)
  artifact: com.azure:azure-security-keyvault-jca:1.0.0-beta.2
  parent: org.apache.commons.codec.digest.Crypt
  langs:
  - java
  name: crypt(byte[] keyBytes, String salt)
  nameWithType: Crypt.crypt(byte[] keyBytes, String salt)
  fullName: org.apache.commons.codec.digest.Crypt.crypt(byte[] keyBytes, String salt)
  overload: org.apache.commons.codec.digest.Crypt.crypt*
  type: Method
  package: org.apache.commons.codec.digest
  summary: >-
    Encrypts a password in a crypt(3) compatible way.


    If no salt is provided, a random salt and the default algorithm (currently SHA-512) will be used. See <xref uid="org.apache.commons.codec.digest.Crypt.crypt(java.lang.String,java.lang.String)" data-throw-if-not-resolved="false">#crypt(String, String)</xref> for details.
  syntax:
    content: public static String crypt(byte[] keyBytes, String salt)
    parameters:
    - id: keyBytes
      type: byte[]
      description: plaintext password
    - id: salt
      type: java.lang.String
      description: >-
        real salt value without prefix or "rounds=". The salt may be null,
                    in which case a salt is generated for you using <xref uid="" data-throw-if-not-resolved="false">ThreadLocalRandom</xref>;
                    for more secure salts consider using <xref uid="" data-throw-if-not-resolved="false">SecureRandom</xref> to
                    generate your own salts.
    return:
      type: java.lang.String
      description: hash value
- uid: org.apache.commons.codec.digest.Crypt.crypt(java.lang.String)
  id: crypt(java.lang.String)
  artifact: com.azure:azure-security-keyvault-jca:1.0.0-beta.2
  parent: org.apache.commons.codec.digest.Crypt
  langs:
  - java
  name: crypt(String key)
  nameWithType: Crypt.crypt(String key)
  fullName: org.apache.commons.codec.digest.Crypt.crypt(String key)
  overload: org.apache.commons.codec.digest.Crypt.crypt*
  type: Method
  package: org.apache.commons.codec.digest
  summary: >-
    Calculates the digest using the strongest crypt(3) algorithm.


    A random salt and the default algorithm (currently SHA-512) are used.


    A salt is generated for you using <xref uid="" data-throw-if-not-resolved="false">ThreadLocalRandom</xref>; for more secure salts consider using <xref uid="" data-throw-if-not-resolved="false">SecureRandom</xref> to generate your own salts and calling <xref uid="org.apache.commons.codec.digest.Crypt.crypt(java.lang.String,java.lang.String)" data-throw-if-not-resolved="false">#crypt(String, String)</xref>.
  syntax:
    content: public static String crypt(String key)
    parameters:
    - id: key
      type: java.lang.String
      description: plaintext password
    return:
      type: java.lang.String
      description: hash value
- uid: org.apache.commons.codec.digest.Crypt.crypt(java.lang.String,java.lang.String)
  id: crypt(java.lang.String,java.lang.String)
  artifact: com.azure:azure-security-keyvault-jca:1.0.0-beta.2
  parent: org.apache.commons.codec.digest.Crypt
  langs:
  - java
  name: crypt(String key, String salt)
  nameWithType: Crypt.crypt(String key, String salt)
  fullName: org.apache.commons.codec.digest.Crypt.crypt(String key, String salt)
  overload: org.apache.commons.codec.digest.Crypt.crypt*
  type: Method
  package: org.apache.commons.codec.digest
  summary: >-
    Encrypts a password in a crypt(3) compatible way.


    The exact algorithm depends on the format of the salt string:

     *  SHA-512 salts start with `$6$` and are up to 16 chars long.
     *  SHA-256 salts start with `$5$` and are up to 16 chars long
     *  MD5 salts start with `$1$` and are up to 8 chars long
     *  DES, the traditional UnixCrypt algorithm is used with only 2 chars
     *  Only the first 8 chars of the passwords are used in the DES algorithm!

    The magic strings `"$apr1$"` and `"$2a$"` are not recognized by this method as its output should be identical with that of the libc implementation.


    The rest of the salt string is drawn from the set `[a-zA-Z0-9./]` and is cut at the maximum length of if a `"$"` sign is encountered. It is therefore valid to enter a complete hash value as salt to e.g. verify a password with:


    ```java

    storedPwd.equals(crypt(enteredPwd, storedPwd))

    ```


    The resulting string starts with the marker string (`$n$`), where n is the same as the input salt. The salt is then appended, followed by a `"$"` sign. This is followed by the actual hash value. For DES the string only contains the salt and actual hash. The total length is dependent on the algorithm used:

     *  SHA-512: 106 chars
     *  SHA-256: 63 chars
     *  MD5: 34 chars
     *  DES: 13 chars

    Example:


    ```java

    crypt("secret", "$1$xxxx") => "$1$xxxx$aMkevjfEIpa35Bh3G4bAc."
          crypt("secret", "xx") => "xxWAum7tHdIUw"
    ```


    This method comes in a variation that accepts a byte\[\] array to support input strings that are not encoded in UTF-8 but e.g. in ISO-8859-1 where equal characters result in different byte values.
  syntax:
    content: public static String crypt(String key, String salt)
    parameters:
    - id: key
      type: java.lang.String
      description: plaintext password as entered by the used
    - id: salt
      type: java.lang.String
      description: >-
        real salt value without prefix or "rounds=". The salt may be null, in which case a
                    salt is generated for you using <xref uid="" data-throw-if-not-resolved="false">ThreadLocalRandom</xref>; for more secure salts
                    consider using <xref uid="" data-throw-if-not-resolved="false">SecureRandom</xref> to generate your own salts.
    return:
      type: java.lang.String
      description: hash value, i.e. encrypted password including the salt string
references:
- uid: org.apache.commons.codec.digest.Crypt.Crypt*
  name: Crypt
  nameWithType: Crypt.Crypt
  fullName: org.apache.commons.codec.digest.Crypt.Crypt
  package: org.apache.commons.codec.digest
- uid: byte[]
  spec.java:
  - uid: byte
    name: byte
    fullName: byte
  - name: '[]'
    fullName: '[]'
- uid: java.lang.String
  spec.java:
  - uid: java.lang.String
    name: String
    fullName: java.lang.String
- uid: org.apache.commons.codec.digest.Crypt.crypt*
  name: crypt
  nameWithType: Crypt.crypt
  fullName: org.apache.commons.codec.digest.Crypt.crypt
  package: org.apache.commons.codec.digest
- uid: java.lang.Object.notify()
  name: Object.notify()
  nameWithType: Object.notify()
  fullName: java.lang.Object.notify()
- uid: java.lang.Object.wait()
  name: Object.wait()
  nameWithType: Object.wait()
  fullName: java.lang.Object.wait()
- uid: java.lang.Object.finalize()
  name: Object.finalize()
  nameWithType: Object.finalize()
  fullName: java.lang.Object.finalize()
- uid: java.lang.Object.clone()
  name: Object.clone()
  nameWithType: Object.clone()
  fullName: java.lang.Object.clone()
- uid: java.lang.Object.notifyAll()
  name: Object.notifyAll()
  nameWithType: Object.notifyAll()
  fullName: java.lang.Object.notifyAll()
- uid: java.lang.Object.equals(java.lang.Object)
  name: Object.equals(Object)
  nameWithType: Object.equals(Object)
  fullName: java.lang.Object.equals(java.lang.Object)
- uid: java.lang.Object.getClass()
  name: Object.getClass()
  nameWithType: Object.getClass()
  fullName: java.lang.Object.getClass()
- uid: java.lang.Object.wait(long)
  name: Object.wait(long)
  nameWithType: Object.wait(long)
  fullName: java.lang.Object.wait(long)
- uid: java.lang.Object.hashCode()
  name: Object.hashCode()
  nameWithType: Object.hashCode()
  fullName: java.lang.Object.hashCode()
- uid: java.lang.Object.wait(long,int)
  name: Object.wait(long,int)
  nameWithType: Object.wait(long,int)
  fullName: java.lang.Object.wait(long,int)
- uid: java.lang.Object.toString()
  name: Object.toString()
  nameWithType: Object.toString()
  fullName: java.lang.Object.toString()
