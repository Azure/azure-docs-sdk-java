### YamlMime:JavaType
uid: "com.azure.core.util.FluxUtil"
fullName: "com.azure.core.util.FluxUtil"
name: "FluxUtil"
nameWithType: "FluxUtil"
summary: "Utility type exposing methods to deal with <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref>."
inheritances:
- "<xref href=\"java.lang.Object?displayProperty=fullName\" data-throw-if-not-resolved=\"False\" />"
inheritedMembers:
- "java.lang.Object.clone()"
- "java.lang.Object.equals(java.lang.Object)"
- "java.lang.Object.finalize()"
- "java.lang.Object.getClass()"
- "java.lang.Object.hashCode()"
- "java.lang.Object.notify()"
- "java.lang.Object.notifyAll()"
- "java.lang.Object.toString()"
- "java.lang.Object.wait()"
- "java.lang.Object.wait(long)"
- "java.lang.Object.wait(long,int)"
syntax: "public final class FluxUtil"
methods:
- uid: "com.azure.core.util.FluxUtil.<T>fluxContext(java.util.function.Function<com.azure.core.util.Context,reactor.core.publisher.Flux<T>>)"
  fullName: "com.azure.core.util.FluxUtil.<T>fluxContext(Function<Context,Flux<T>> serviceCall)"
  name: "<T>fluxContext(Function<Context,Flux<T>> serviceCall)"
  nameWithType: "FluxUtil.<T>fluxContext(Function<Context,Flux<T>> serviceCall)"
  summary: "This method converts the incoming `deferContextual` from <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Reactor\n Context\"></xref> to <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Azure Context\"></xref> and calls the given lambda function with this context and returns a collection of type `T`"
  modifiers:
  - "static"
  parameters:
  - description: "The lambda function that makes the service call into which the context will be passed"
    name: "serviceCall"
    type: "<xref href=\"java.util.function.Function?alt=java.util.function.Function&text=Function\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.Context?alt=com.azure.core.util.Context&text=Context\" data-throw-if-not-resolved=\"False\" />,<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  syntax: "public static Flux<T> <T>fluxContext(Function<Context,Flux<T>> serviceCall)"
  desc: "This method converts the incoming `deferContextual` from <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Reactor\n Context\"></xref> to <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Azure Context\"></xref> and calls the given lambda function with this context and returns a collection of type `T`\n\nIf the reactor context is empty, <xref uid=\"com.azure.core.util.Context.NONE\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Context#NONE\"></xref> will be used to call the lambda function\n\n**Code samples**\n\n```java\nString prefix = \"Hello, \";\n Flux<String> response = FluxUtil\n     .fluxContext(context -> serviceCallReturnsCollection(prefix, context));\n```"
  returns:
    description: "The response from service call"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.<T>fluxError(com.azure.core.util.logging.ClientLogger,java.lang.RuntimeException)"
  fullName: "com.azure.core.util.FluxUtil.<T>fluxError(ClientLogger logger, RuntimeException ex)"
  name: "<T>fluxError(ClientLogger logger, RuntimeException ex)"
  nameWithType: "FluxUtil.<T>fluxError(ClientLogger logger, RuntimeException ex)"
  summary: "Propagates a <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref> through the error channel of <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref>."
  modifiers:
  - "static"
  parameters:
  - description: "The <xref uid=\"com.azure.core.util.logging.ClientLogger\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ClientLogger\"></xref> to log the exception."
    name: "logger"
    type: "<xref href=\"com.azure.core.util.logging.ClientLogger?alt=com.azure.core.util.logging.ClientLogger&text=ClientLogger\" data-throw-if-not-resolved=\"False\" />"
  - description: "The <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref>."
    name: "ex"
    type: "<xref href=\"java.lang.RuntimeException?alt=java.lang.RuntimeException&text=RuntimeException\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Flux<T> <T>fluxError(ClientLogger logger, RuntimeException ex)"
  desc: "Propagates a <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref> through the error channel of <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref>."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> that terminates with error wrapping the <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref>."
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.<T>monoError(com.azure.core.util.logging.ClientLogger,java.lang.RuntimeException)"
  fullName: "com.azure.core.util.FluxUtil.<T>monoError(ClientLogger logger, RuntimeException ex)"
  name: "<T>monoError(ClientLogger logger, RuntimeException ex)"
  nameWithType: "FluxUtil.<T>monoError(ClientLogger logger, RuntimeException ex)"
  summary: "Propagates a <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref> through the error channel of <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref>."
  modifiers:
  - "static"
  parameters:
  - description: "The <xref uid=\"com.azure.core.util.logging.ClientLogger\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ClientLogger\"></xref> to log the exception."
    name: "logger"
    type: "<xref href=\"com.azure.core.util.logging.ClientLogger?alt=com.azure.core.util.logging.ClientLogger&text=ClientLogger\" data-throw-if-not-resolved=\"False\" />"
  - description: "The <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref>."
    name: "ex"
    type: "<xref href=\"java.lang.RuntimeException?alt=java.lang.RuntimeException&text=RuntimeException\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Mono<T> <T>monoError(ClientLogger logger, RuntimeException ex)"
  desc: "Propagates a <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref> through the error channel of <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref>."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> that terminates with error wrapping the <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref>."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.<T>pagedFluxError(com.azure.core.util.logging.ClientLogger,java.lang.RuntimeException)"
  fullName: "com.azure.core.util.FluxUtil.<T>pagedFluxError(ClientLogger logger, RuntimeException ex)"
  name: "<T>pagedFluxError(ClientLogger logger, RuntimeException ex)"
  nameWithType: "FluxUtil.<T>pagedFluxError(ClientLogger logger, RuntimeException ex)"
  summary: "Propagates a <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref> through the error channel of <xref uid=\"com.azure.core.http.rest.PagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PagedFlux\"></xref>."
  modifiers:
  - "static"
  parameters:
  - description: "The <xref uid=\"com.azure.core.util.logging.ClientLogger\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ClientLogger\"></xref> to log the exception."
    name: "logger"
    type: "<xref href=\"com.azure.core.util.logging.ClientLogger?alt=com.azure.core.util.logging.ClientLogger&text=ClientLogger\" data-throw-if-not-resolved=\"False\" />"
  - description: "The <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref>."
    name: "ex"
    type: "<xref href=\"java.lang.RuntimeException?alt=java.lang.RuntimeException&text=RuntimeException\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static PagedFlux<T> <T>pagedFluxError(ClientLogger logger, RuntimeException ex)"
  desc: "Propagates a <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref> through the error channel of <xref uid=\"com.azure.core.http.rest.PagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PagedFlux\"></xref>."
  returns:
    description: "A <xref uid=\"com.azure.core.http.rest.PagedFlux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"PagedFlux\"></xref> that terminates with error wrapping the <xref uid=\"java.lang.RuntimeException\" data-throw-if-not-resolved=\"false\" data-raw-source=\"RuntimeException\"></xref>."
    type: "<xref href=\"com.azure.core.http.rest.PagedFlux?alt=com.azure.core.http.rest.PagedFlux&text=PagedFlux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.<T>toMono(com.azure.core.http.rest.Response<T>)"
  fullName: "com.azure.core.util.FluxUtil.<T>toMono(Response<T> response)"
  name: "<T>toMono(Response<T> response)"
  nameWithType: "FluxUtil.<T>toMono(Response<T> response)"
  summary: "Converts the incoming content to Mono."
  modifiers:
  - "static"
  parameters:
  - description: "whose <xref uid=\"com.azure.core.http.rest.Response.getValue()\" data-throw-if-not-resolved=\"false\" data-raw-source=\"value\"></xref> is to be converted"
    name: "response"
    type: "<xref href=\"com.azure.core.http.rest.Response?alt=com.azure.core.http.rest.Response&text=Response\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static Mono<T> <T>toMono(Response<T> response)"
  desc: "Converts the incoming content to Mono."
  returns:
    description: "The converted <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref>"
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.<T>withContext(java.util.function.Function<com.azure.core.util.Context,reactor.core.publisher.Mono<T>>)"
  fullName: "com.azure.core.util.FluxUtil.<T>withContext(Function<Context,Mono<T>> serviceCall)"
  name: "<T>withContext(Function<Context,Mono<T>> serviceCall)"
  nameWithType: "FluxUtil.<T>withContext(Function<Context,Mono<T>> serviceCall)"
  summary: "This method converts the incoming `deferContextual` from <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Reactor\n Context\"></xref> to <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Azure Context\"></xref> and calls the given lambda function with this context and returns a single entity of type `T`"
  modifiers:
  - "static"
  parameters:
  - description: "The lambda function that makes the service call into which azure context will be passed"
    name: "serviceCall"
    type: "<xref href=\"java.util.function.Function?alt=java.util.function.Function&text=Function\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.Context?alt=com.azure.core.util.Context&text=Context\" data-throw-if-not-resolved=\"False\" />,<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  syntax: "public static Mono<T> <T>withContext(Function<Context,Mono<T>> serviceCall)"
  desc: "This method converts the incoming `deferContextual` from <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Reactor\n Context\"></xref> to <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Azure Context\"></xref> and calls the given lambda function with this context and returns a single entity of type `T`\n\nIf the reactor context is empty, <xref uid=\"com.azure.core.util.Context.NONE\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Context#NONE\"></xref> will be used to call the lambda function\n\n**Code samples**\n\n```java\nString prefix = \"Hello, \";\n Mono<String> response = FluxUtil\n     .withContext(context -> serviceCallReturnsSingle(prefix, context));\n```"
  returns:
    description: "The response from service call"
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.<T>withContext(java.util.function.Function<com.azure.core.util.Context,reactor.core.publisher.Mono<T>>,java.util.Map<java.lang.String,java.lang.String>)"
  fullName: "com.azure.core.util.FluxUtil.<T>withContext(Function<Context,Mono<T>> serviceCall, Map<String,String> contextAttributes)"
  name: "<T>withContext(Function<Context,Mono<T>> serviceCall, Map<String,String> contextAttributes)"
  nameWithType: "FluxUtil.<T>withContext(Function<Context,Mono<T>> serviceCall, Map<String,String> contextAttributes)"
  summary: "This method converts the incoming `deferContextual` from <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Reactor\n Context\"></xref> to <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Azure Context\"></xref>, adds the specified context attributes and calls the given lambda function with this context and returns a single entity of type `T`"
  modifiers:
  - "static"
  parameters:
  - description: "serviceCall The lambda function that makes the service call into which azure context will be\n passed"
    name: "serviceCall"
    type: "<xref href=\"java.util.function.Function?alt=java.util.function.Function&text=Function\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"com.azure.core.util.Context?alt=com.azure.core.util.Context&text=Context\" data-throw-if-not-resolved=\"False\" />,<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  - description: "The map of attributes sent by the calling method to be set on <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Context\"></xref>."
    name: "contextAttributes"
    type: "<xref href=\"java.util.Map?alt=java.util.Map&text=Map\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />,<xref href=\"java.lang.String?alt=java.lang.String&text=String\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static Mono<T> <T>withContext(Function<Context,Mono<T>> serviceCall, Map<String,String> contextAttributes)"
  desc: "This method converts the incoming `deferContextual` from <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Reactor\n Context\"></xref> to <xref uid=\"reactor.util.context.Context\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Azure Context\"></xref>, adds the specified context attributes and calls the given lambda function with this context and returns a single entity of type `T`\n\nIf the reactor context is empty, <xref uid=\"com.azure.core.util.Context.NONE\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Context#NONE\"></xref> will be used to call the lambda function"
  returns:
    description: "The response from service call"
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"T?alt=T&text=T\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.byteBufferToArray(java.nio.ByteBuffer)"
  fullName: "com.azure.core.util.FluxUtil.byteBufferToArray(ByteBuffer byteBuffer)"
  name: "byteBufferToArray(ByteBuffer byteBuffer)"
  nameWithType: "FluxUtil.byteBufferToArray(ByteBuffer byteBuffer)"
  summary: "Gets the content of the provided Byte<wbr>Buffer as a byte array."
  modifiers:
  - "static"
  parameters:
  - description: "the byte buffer"
    name: "byteBuffer"
    type: "<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static byte[] byteBufferToArray(ByteBuffer byteBuffer)"
  desc: "Gets the content of the provided ByteBuffer as a byte array. This method will create a new byte array even if the ByteBuffer can have optionally backing array."
  returns:
    description: "the byte array"
    type: "<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]"
- uid: "com.azure.core.util.FluxUtil.collectBytesFromNetworkResponse(reactor.core.publisher.Flux<java.nio.ByteBuffer>,com.azure.core.http.HttpHeaders)"
  fullName: "com.azure.core.util.FluxUtil.collectBytesFromNetworkResponse(Flux<ByteBuffer> stream, HttpHeaders headers)"
  name: "collectBytesFromNetworkResponse(Flux<ByteBuffer> stream, HttpHeaders headers)"
  nameWithType: "FluxUtil.collectBytesFromNetworkResponse(Flux<ByteBuffer> stream, HttpHeaders headers)"
  summary: "Collects Byte<wbr>Buffers returned in a network response into a byte array."
  modifiers:
  - "static"
  parameters:
  - description: "A network response ByteBuffer stream."
    name: "stream"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "The HTTP headers of the response."
    name: "headers"
    type: "<xref href=\"com.azure.core.http.HttpHeaders?alt=com.azure.core.http.HttpHeaders&text=HttpHeaders\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Mono<byte[]> collectBytesFromNetworkResponse(Flux<ByteBuffer> stream, HttpHeaders headers)"
  desc: "Collects ByteBuffers returned in a network response into a byte array.\n\nThe `headers` are inspected for containing an `Content-Length` which determines if a size hinted collection, <xref uid=\"com.azure.core.util.FluxUtil.collectBytesInByteBufferStream(reactor.core.publisher.Flux<java.nio.ByteBuffer>,int)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#collectBytesInByteBufferStream(Flux, int)\"></xref>, or default collection, <xref uid=\"com.azure.core.util.FluxUtil.collectBytesInByteBufferStream(reactor.core.publisher.Flux<java.nio.ByteBuffer>)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#collectBytesInByteBufferStream(Flux)\"></xref>, will be used."
  returns:
    description: "A Mono which emits the collected network response ByteBuffers."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]&gt;"
- uid: "com.azure.core.util.FluxUtil.collectBytesInByteBufferStream(reactor.core.publisher.Flux<java.nio.ByteBuffer>)"
  fullName: "com.azure.core.util.FluxUtil.collectBytesInByteBufferStream(Flux<ByteBuffer> stream)"
  name: "collectBytesInByteBufferStream(Flux<ByteBuffer> stream)"
  nameWithType: "FluxUtil.collectBytesInByteBufferStream(Flux<ByteBuffer> stream)"
  summary: "Collects Byte<wbr>Buffers emitted by a Flux into a byte array."
  modifiers:
  - "static"
  parameters:
  - description: "A stream which emits ByteBuffer instances."
    name: "stream"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static Mono<byte[]> collectBytesInByteBufferStream(Flux<ByteBuffer> stream)"
  desc: "Collects ByteBuffers emitted by a Flux into a byte array."
  returns:
    description: "A Mono which emits the concatenation of all the ByteBuffer instances given by the source Flux."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]&gt;"
- uid: "com.azure.core.util.FluxUtil.collectBytesInByteBufferStream(reactor.core.publisher.Flux<java.nio.ByteBuffer>,int)"
  fullName: "com.azure.core.util.FluxUtil.collectBytesInByteBufferStream(Flux<ByteBuffer> stream, int sizeHint)"
  name: "collectBytesInByteBufferStream(Flux<ByteBuffer> stream, int sizeHint)"
  nameWithType: "FluxUtil.collectBytesInByteBufferStream(Flux<ByteBuffer> stream, int sizeHint)"
  summary: "Collects Byte<wbr>Buffers emitted by a Flux into a byte array."
  modifiers:
  - "static"
  parameters:
  - description: "A stream which emits ByteBuffer instances."
    name: "stream"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "A hint about the expected stream size."
    name: "sizeHint"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Mono<byte[]> collectBytesInByteBufferStream(Flux<ByteBuffer> stream, int sizeHint)"
  desc: "Collects ByteBuffers emitted by a Flux into a byte array.\n\nUnlike <xref uid=\"com.azure.core.util.FluxUtil.collectBytesInByteBufferStream(reactor.core.publisher.Flux<java.nio.ByteBuffer>)\" data-throw-if-not-resolved=\"false\" data-raw-source=\"#collectBytesInByteBufferStream(Flux)\"></xref>, this method accepts a second parameter `sizeHint`. This size hint allows for optimizations when creating the initial buffer to reduce the number of times it needs to be resized while concatenating emitted ByteBuffers."
  returns:
    description: "A Mono which emits the concatenation of all the ByteBuffer instances given by the source Flux."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"byte?alt=byte&text=byte\" data-throw-if-not-resolved=\"False\" />[]&gt;"
- uid: "com.azure.core.util.FluxUtil.createRetriableDownloadFlux(java.util.function.Supplier<reactor.core.publisher.Flux<java.nio.ByteBuffer>>,java.util.function.BiFunction<java.lang.Throwable,java.lang.Long,reactor.core.publisher.Flux<java.nio.ByteBuffer>>,int)"
  fullName: "com.azure.core.util.FluxUtil.createRetriableDownloadFlux(Supplier<Flux<ByteBuffer>> downloadSupplier, BiFunction<Throwable,Long,Flux<ByteBuffer>> onDownloadErrorResume, int maxRetries)"
  name: "createRetriableDownloadFlux(Supplier<Flux<ByteBuffer>> downloadSupplier, BiFunction<Throwable,Long,Flux<ByteBuffer>> onDownloadErrorResume, int maxRetries)"
  nameWithType: "FluxUtil.createRetriableDownloadFlux(Supplier<Flux<ByteBuffer>> downloadSupplier, BiFunction<Throwable,Long,Flux<ByteBuffer>> onDownloadErrorResume, int maxRetries)"
  summary: "Creates a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> that is capable of resuming a download by applying retry logic when an error occurs."
  modifiers:
  - "static"
  parameters:
  - description: "Supplier of the initial download."
    name: "downloadSupplier"
    type: "<xref href=\"java.util.function.Supplier?alt=java.util.function.Supplier&text=Supplier\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  - description: "<xref uid=\"java.util.function.BiFunction\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BiFunction\"></xref> of <xref uid=\"java.lang.Throwable\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Throwable\"></xref> and <xref uid=\"java.lang.Long\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Long\"></xref> which is used to resume\n downloading when an error occurs."
    name: "onDownloadErrorResume"
    type: "<xref href=\"java.util.function.BiFunction?alt=java.util.function.BiFunction&text=BiFunction\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Throwable?alt=java.lang.Throwable&text=Throwable\" data-throw-if-not-resolved=\"False\" />,<xref href=\"java.lang.Long?alt=java.lang.Long&text=Long\" data-throw-if-not-resolved=\"False\" />,<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  - description: "The maximum number of times a download can be resumed when an error occurs."
    name: "maxRetries"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Flux<ByteBuffer> createRetriableDownloadFlux(Supplier<Flux<ByteBuffer>> downloadSupplier, BiFunction<Throwable,Long,Flux<ByteBuffer>> onDownloadErrorResume, int maxRetries)"
  desc: "Creates a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> that is capable of resuming a download by applying retry logic when an error occurs."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> that downloads reliably."
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.createRetriableDownloadFlux(java.util.function.Supplier<reactor.core.publisher.Flux<java.nio.ByteBuffer>>,java.util.function.BiFunction<java.lang.Throwable,java.lang.Long,reactor.core.publisher.Flux<java.nio.ByteBuffer>>,int,long)"
  fullName: "com.azure.core.util.FluxUtil.createRetriableDownloadFlux(Supplier<Flux<ByteBuffer>> downloadSupplier, BiFunction<Throwable,Long,Flux<ByteBuffer>> onDownloadErrorResume, int maxRetries, long position)"
  name: "createRetriableDownloadFlux(Supplier<Flux<ByteBuffer>> downloadSupplier, BiFunction<Throwable,Long,Flux<ByteBuffer>> onDownloadErrorResume, int maxRetries, long position)"
  nameWithType: "FluxUtil.createRetriableDownloadFlux(Supplier<Flux<ByteBuffer>> downloadSupplier, BiFunction<Throwable,Long,Flux<ByteBuffer>> onDownloadErrorResume, int maxRetries, long position)"
  summary: "Creates a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> that is capable of resuming a download by applying retry logic when an error occurs."
  modifiers:
  - "static"
  parameters:
  - description: "Supplier of the initial download."
    name: "downloadSupplier"
    type: "<xref href=\"java.util.function.Supplier?alt=java.util.function.Supplier&text=Supplier\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  - description: "<xref uid=\"java.util.function.BiFunction\" data-throw-if-not-resolved=\"false\" data-raw-source=\"BiFunction\"></xref> of <xref uid=\"java.lang.Throwable\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Throwable\"></xref> and <xref uid=\"java.lang.Long\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Long\"></xref> which is used to resume\n downloading when an error occurs."
    name: "onDownloadErrorResume"
    type: "<xref href=\"java.util.function.BiFunction?alt=java.util.function.BiFunction&text=BiFunction\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Throwable?alt=java.lang.Throwable&text=Throwable\" data-throw-if-not-resolved=\"False\" />,<xref href=\"java.lang.Long?alt=java.lang.Long&text=Long\" data-throw-if-not-resolved=\"False\" />,<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;&gt;"
  - description: "The maximum number of times a download can be resumed when an error occurs."
    name: "maxRetries"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  - description: "The initial offset for the download."
    name: "position"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Flux<ByteBuffer> createRetriableDownloadFlux(Supplier<Flux<ByteBuffer>> downloadSupplier, BiFunction<Throwable,Long,Flux<ByteBuffer>> onDownloadErrorResume, int maxRetries, long position)"
  desc: "Creates a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> that is capable of resuming a download by applying retry logic when an error occurs."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> that downloads reliably."
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.isFluxByteBuffer(java.lang.reflect.Type)"
  fullName: "com.azure.core.util.FluxUtil.isFluxByteBuffer(Type entityType)"
  name: "isFluxByteBuffer(Type entityType)"
  nameWithType: "FluxUtil.isFluxByteBuffer(Type entityType)"
  summary: "Checks if a type is Flux<Byte<wbr>Buffer>."
  modifiers:
  - "static"
  parameters:
  - description: "the type to check"
    name: "entityType"
    type: "<xref href=\"java.lang.reflect.Type?alt=java.lang.reflect.Type&text=Type\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static boolean isFluxByteBuffer(Type entityType)"
  desc: "Checks if a type is Flux<ByteBuffer>."
  returns:
    description: "whether the type represents a Flux that emits ByteBuffer"
    type: "<xref href=\"boolean?alt=boolean&text=boolean\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.core.util.FluxUtil.readFile(java.nio.channels.AsynchronousFileChannel)"
  fullName: "com.azure.core.util.FluxUtil.readFile(AsynchronousFileChannel fileChannel)"
  name: "readFile(AsynchronousFileChannel fileChannel)"
  nameWithType: "FluxUtil.readFile(AsynchronousFileChannel fileChannel)"
  summary: "Creates a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> from an <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref> which reads the entire file."
  modifiers:
  - "static"
  parameters:
  - description: "The file channel."
    name: "fileChannel"
    type: "<xref href=\"java.nio.channels.AsynchronousFileChannel?alt=java.nio.channels.AsynchronousFileChannel&text=AsynchronousFileChannel\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Flux<ByteBuffer> readFile(AsynchronousFileChannel fileChannel)"
  desc: "Creates a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> from an <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref> which reads the entire file."
  returns:
    description: "The AsyncInputStream."
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.readFile(java.nio.channels.AsynchronousFileChannel,int,long,long)"
  fullName: "com.azure.core.util.FluxUtil.readFile(AsynchronousFileChannel fileChannel, int chunkSize, long offset, long length)"
  name: "readFile(AsynchronousFileChannel fileChannel, int chunkSize, long offset, long length)"
  nameWithType: "FluxUtil.readFile(AsynchronousFileChannel fileChannel, int chunkSize, long offset, long length)"
  summary: "Creates a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> from an <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref> which reads part of a file into chunks of the given size."
  modifiers:
  - "static"
  parameters:
  - description: "The file channel."
    name: "fileChannel"
    type: "<xref href=\"java.nio.channels.AsynchronousFileChannel?alt=java.nio.channels.AsynchronousFileChannel&text=AsynchronousFileChannel\" data-throw-if-not-resolved=\"False\" />"
  - description: "the size of file chunks to read."
    name: "chunkSize"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  - description: "The offset in the file to begin reading."
    name: "offset"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  - description: "The number of bytes to read from the file."
    name: "length"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Flux<ByteBuffer> readFile(AsynchronousFileChannel fileChannel, int chunkSize, long offset, long length)"
  desc: "Creates a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> from an <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref> which reads part of a file into chunks of the given size."
  returns:
    description: "the Flux."
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.readFile(java.nio.channels.AsynchronousFileChannel,long,long)"
  fullName: "com.azure.core.util.FluxUtil.readFile(AsynchronousFileChannel fileChannel, long offset, long length)"
  name: "readFile(AsynchronousFileChannel fileChannel, long offset, long length)"
  nameWithType: "FluxUtil.readFile(AsynchronousFileChannel fileChannel, long offset, long length)"
  summary: "Creates a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> from an <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref> which reads part of a file."
  modifiers:
  - "static"
  parameters:
  - description: "The file channel."
    name: "fileChannel"
    type: "<xref href=\"java.nio.channels.AsynchronousFileChannel?alt=java.nio.channels.AsynchronousFileChannel&text=AsynchronousFileChannel\" data-throw-if-not-resolved=\"False\" />"
  - description: "The offset in the file to begin reading."
    name: "offset"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  - description: "The number of bytes to read from the file."
    name: "length"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Flux<ByteBuffer> readFile(AsynchronousFileChannel fileChannel, long offset, long length)"
  desc: "Creates a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> from an <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref> which reads part of a file."
  returns:
    description: "the Flux."
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.toFluxByteBuffer(java.io.InputStream)"
  fullName: "com.azure.core.util.FluxUtil.toFluxByteBuffer(InputStream inputStream)"
  name: "toFluxByteBuffer(InputStream inputStream)"
  nameWithType: "FluxUtil.toFluxByteBuffer(InputStream inputStream)"
  summary: "Converts an <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> into a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffer\"></xref> using a chunk size of 4096."
  modifiers:
  - "static"
  parameters:
  - description: "The <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> to convert into a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref>."
    name: "inputStream"
    type: "<xref href=\"java.io.InputStream?alt=java.io.InputStream&text=InputStream\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream)"
  desc: "Converts an <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> into a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffer\"></xref> using a chunk size of 4096.\n\nGiven that <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> is not guaranteed to be replayable the returned <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> should be considered non-replayable as well.\n\nIf the passed <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> is `null` <xref uid=\"reactor.core.publisher.Flux.empty*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux#empty()\"></xref> will be returned."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffers\"></xref> that contains the contents of the stream."
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.toFluxByteBuffer(java.io.InputStream,int)"
  fullName: "com.azure.core.util.FluxUtil.toFluxByteBuffer(InputStream inputStream, int chunkSize)"
  name: "toFluxByteBuffer(InputStream inputStream, int chunkSize)"
  nameWithType: "FluxUtil.toFluxByteBuffer(InputStream inputStream, int chunkSize)"
  summary: "Converts an <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> into a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffer\"></xref>."
  modifiers:
  - "static"
  parameters:
  - description: "The <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> to convert into a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref>."
    name: "inputStream"
    type: "<xref href=\"java.io.InputStream?alt=java.io.InputStream&text=InputStream\" data-throw-if-not-resolved=\"False\" />"
  - description: "The requested size for each <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffer\"></xref>."
    name: "chunkSize"
    type: "<xref href=\"int?alt=int&text=int\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream, int chunkSize)"
  desc: "Converts an <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> into a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffer\"></xref>.\n\nGiven that <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> is not guaranteed to be replayable the returned <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> should be considered non-replayable as well.\n\nIf the passed <xref uid=\"java.io.InputStream\" data-throw-if-not-resolved=\"false\" data-raw-source=\"InputStream\"></xref> is `null` <xref uid=\"reactor.core.publisher.Flux.empty*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux#empty()\"></xref> will be returned."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffers\"></xref> that contains the contents of the stream."
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.toReactorContext(com.azure.core.util.Context)"
  fullName: "com.azure.core.util.FluxUtil.toReactorContext(Context context)"
  name: "toReactorContext(Context context)"
  nameWithType: "FluxUtil.toReactorContext(Context context)"
  summary: "Converts an Azure context to Reactor context."
  modifiers:
  - "static"
  parameters:
  - description: "The Azure context."
    name: "context"
    type: "<xref href=\"com.azure.core.util.Context?alt=com.azure.core.util.Context&text=Context\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Context toReactorContext(Context context)"
  desc: "Converts an Azure context to Reactor context. If the Azure context is `null` or empty, <xref uid=\"reactor.util.context.Context.empty*\" data-throw-if-not-resolved=\"false\" data-raw-source=\"reactor.util.context.Context#empty()\"></xref> will be returned."
  returns:
    description: "The Reactor context."
    type: "<xref href=\"reactor.util.context.Context?alt=reactor.util.context.Context&text=Context\" data-throw-if-not-resolved=\"False\" />"
- uid: "com.azure.core.util.FluxUtil.writeFile(reactor.core.publisher.Flux<java.nio.ByteBuffer>,java.nio.channels.AsynchronousFileChannel)"
  fullName: "com.azure.core.util.FluxUtil.writeFile(Flux<ByteBuffer> content, AsynchronousFileChannel outFile)"
  name: "writeFile(Flux<ByteBuffer> content, AsynchronousFileChannel outFile)"
  nameWithType: "FluxUtil.writeFile(Flux<ByteBuffer> content, AsynchronousFileChannel outFile)"
  summary: "Writes the <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffers\"></xref> emitted by a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffer\"></xref> to an <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref>."
  modifiers:
  - "static"
  parameters:
  - description: "The <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffer\"></xref> content."
    name: "content"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "The <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref>."
    name: "outFile"
    type: "<xref href=\"java.nio.channels.AsynchronousFileChannel?alt=java.nio.channels.AsynchronousFileChannel&text=AsynchronousFileChannel\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Mono<Void> writeFile(Flux<ByteBuffer> content, AsynchronousFileChannel outFile)"
  desc: "Writes the <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffers\"></xref> emitted by a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffer\"></xref> to an <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref>.\n\nThe `outFile` is not closed by this call, closing of the `outFile` is managed by the caller.\n\nThe response <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> will emit an error if `content` or `outFile` are null. Additionally, an error will be emitted if the `outFile` wasn't opened with the proper open options, such as <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"StandardOpenOption#WRITE\"></xref>."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> which emits a completion status once the <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> has been written to the <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref>."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.core.util.FluxUtil.writeFile(reactor.core.publisher.Flux<java.nio.ByteBuffer>,java.nio.channels.AsynchronousFileChannel,long)"
  fullName: "com.azure.core.util.FluxUtil.writeFile(Flux<ByteBuffer> content, AsynchronousFileChannel outFile, long position)"
  name: "writeFile(Flux<ByteBuffer> content, AsynchronousFileChannel outFile, long position)"
  nameWithType: "FluxUtil.writeFile(Flux<ByteBuffer> content, AsynchronousFileChannel outFile, long position)"
  summary: "Writes the <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffers\"></xref> emitted by a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffer\"></xref> to an <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref> starting at the given `position` in the file."
  modifiers:
  - "static"
  parameters:
  - description: "The <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffer\"></xref> content."
    name: "content"
    type: "<xref href=\"reactor.core.publisher.Flux?alt=reactor.core.publisher.Flux&text=Flux\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.nio.ByteBuffer?alt=java.nio.ByteBuffer&text=ByteBuffer\" data-throw-if-not-resolved=\"False\" />&gt;"
  - description: "The <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref>."
    name: "outFile"
    type: "<xref href=\"java.nio.channels.AsynchronousFileChannel?alt=java.nio.channels.AsynchronousFileChannel&text=AsynchronousFileChannel\" data-throw-if-not-resolved=\"False\" />"
  - description: "The position in the file to begin writing the <code>content</code>."
    name: "position"
    type: "<xref href=\"long?alt=long&text=long\" data-throw-if-not-resolved=\"False\" />"
  syntax: "public static Mono<Void> writeFile(Flux<ByteBuffer> content, AsynchronousFileChannel outFile, long position)"
  desc: "Writes the <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffers\"></xref> emitted by a <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> of <xref uid=\"java.nio.ByteBuffer\" data-throw-if-not-resolved=\"false\" data-raw-source=\"ByteBuffer\"></xref> to an <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref> starting at the given `position` in the file.\n\nThe `outFile` is not closed by this call, closing of the `outFile` is managed by the caller.\n\nThe response <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> will emit an error if `content` or `outFile` are null or `position` is less than 0. Additionally, an error will be emitted if the `outFile` wasn't opened with the proper open options, such as <xref uid=\"\" data-throw-if-not-resolved=\"false\" data-raw-source=\"StandardOpenOption#WRITE\"></xref>."
  returns:
    description: "A <xref uid=\"reactor.core.publisher.Mono\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Mono\"></xref> which emits a completion status once the <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref> has been written to the <xref uid=\"java.nio.channels.AsynchronousFileChannel\" data-throw-if-not-resolved=\"false\" data-raw-source=\"AsynchronousFileChannel\"></xref>."
    type: "<xref href=\"reactor.core.publisher.Mono?alt=reactor.core.publisher.Mono&text=Mono\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"java.lang.Void?alt=java.lang.Void&text=Void\" data-throw-if-not-resolved=\"False\" />&gt;"
type: "class"
desc: "Utility type exposing methods to deal with <xref uid=\"reactor.core.publisher.Flux\" data-throw-if-not-resolved=\"false\" data-raw-source=\"Flux\"></xref>."
metadata: {}
package: "com.azure.core.util"
artifact: com.azure:azure-core:1.22.0-beta.1
