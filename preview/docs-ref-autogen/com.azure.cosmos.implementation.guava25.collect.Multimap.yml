### YamlMime:JavaType
uid: "com.azure.cosmos.implementation.guava25.collect.Multimap"
fullName: "com.azure.cosmos.implementation.guava25.collect.Multimap<K,V>"
name: "Multimap<K,V>"
nameWithType: "Multimap<K,V>"
summary: "A collection that maps keys to values, similar to <xref uid=\"java.util.Map\" data-throw-if-not-resolved=\"false\">Map</xref>, but in which each key may be associated with *multiple* values. You can visualize the contents of a multimap either as a map from keys to *nonempty* collections of values:\n\n *  a \\\\u2192 1, 2\n *  b \\\\u2192 3\n\n... or as a single \"flattened\" collection of key-value pairs:\n\n *  a \\\\u2192 1\n *  a \\\\u2192 2\n *  b \\\\u2192 3\n\n**Important:** although the first interpretation resembles how most multimaps are *implemented*, the design of the `Multimap` API is based on the *second* form. So, using the multimap shown above as an example, the <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.size\" data-throw-if-not-resolved=\"false\">#size</xref> is `3`, not `2`, and the <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.values\" data-throw-if-not-resolved=\"false\">#values</xref> collection is `[1, 2, 3]`, not `[[1, 2], [3]]`. For those times when the first style is more useful, use the multimap's <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.asMap\" data-throw-if-not-resolved=\"false\">#asMap</xref> view (or create a `Map>` in the first place).\n\n### Example ###\n\nThe following code:\n\n```java\nListMultimap multimap = ArrayListMultimap.create();\n for (President pres : US_PRESIDENTS_IN_ORDER) {\n   multimap.put(pres.firstName(), pres.lastName());\n }\n for (String firstName : multimap.keySet()) {\n   List lastNames = multimap.get(firstName);\n   out.println(firstName + \": \" + lastNames);\n }\n```\n\n... produces output such as:\n\n```java\nZachary: [Taylor]\n John: [Adams, Adams, Tyler, Kennedy]  // Remember, Quincy!\n George: [Washington, Bush, Bush]\n Grover: [Cleveland, Cleveland]        // Two, non-consecutive terms, rep'ing NJ!\n ...\n```\n\n### Views ###\n\nMuch of the power of the multimap API comes from the *view collections* it provides. These always reflect the latest state of the multimap itself. When they support modification, the changes are *write-through* (they automatically update the backing multimap). These view collections are:\n\n *  <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.asMap\" data-throw-if-not-resolved=\"false\">#asMap</xref>, mentioned above\n *  <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.keys\" data-throw-if-not-resolved=\"false\">#keys</xref>, <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.keySet\" data-throw-if-not-resolved=\"false\">#keySet</xref>, <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.values\" data-throw-if-not-resolved=\"false\">#values</xref>, <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.entries\" data-throw-if-not-resolved=\"false\">#entries</xref>, which are similar to the corresponding view collections of <xref uid=\"java.util.Map\" data-throw-if-not-resolved=\"false\">Map</xref>\n *  and, notably, even the collection returned by <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.get\" data-throw-if-not-resolved=\"false\">get(key)</xref> is an active view of the values corresponding to `key`\n\nThe collections returned by the <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.replaceValues\" data-throw-if-not-resolved=\"false\">replaceValues</xref> and <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.removeAll\" data-throw-if-not-resolved=\"false\">removeAll</xref> methods, which contain values that have just been removed from the multimap, are naturally *not* views.\n\n### Subinterfaces ###\n\nInstead of using the `Multimap` interface directly, prefer the subinterfaces <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ListMultimap\" data-throw-if-not-resolved=\"false\">ListMultimap</xref> and <xref uid=\"com.azure.cosmos.implementation.guava25.collect.SetMultimap\" data-throw-if-not-resolved=\"false\">SetMultimap</xref>. These take their names from the fact that the collections they return from `get` behave like (and, of course, implement) <xref uid=\"java.util.List\" data-throw-if-not-resolved=\"false\">List</xref> and <xref uid=\"java.util.Set\" data-throw-if-not-resolved=\"false\">Set</xref>, respectively.\n\nFor example, the \"presidents\" code snippet above used a `ListMultimap`; if it had used a `SetMultimap` instead, two presidents would have vanished, and last names might or might not appear in chronological order.\n\n**Warning:** instances of type `Multimap` may not implement <xref uid=\"java.lang.Object.equals\" data-throw-if-not-resolved=\"false\">Object#equals</xref> in the way you expect. Multimaps containing the same key-value pairs, even in the same order, may or may not be equal and may or may not have the same `hashCode`. The recommended subinterfaces provide much stronger guarantees.\n\n### Comparison to a map of collections ###\n\nMultimaps are commonly used in places where a `Map>` would otherwise have appeared. The differences include:\n\n *  There is no need to populate an empty collection before adding an entry with <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.put\" data-throw-if-not-resolved=\"false\">put</xref>.\n *  `get` never returns `null`, only an empty collection.\n *  A key is contained in the multimap if and only if it maps to at least one value. Any operation that causes a key to have zero associated values has the effect of *removing* that key from the multimap.\n *  The total entry count is available as <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimap.size\" data-throw-if-not-resolved=\"false\">#size</xref>.\n *  Many complex operations become easier; for example, `Collections.min(multimap.values())` finds the smallest value across all keys.\n\n### Implementations ###\n\nAs always, prefer the immutable implementations, <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableListMultimap\" data-throw-if-not-resolved=\"false\">ImmutableListMultimap</xref> and <xref uid=\"com.azure.cosmos.implementation.guava25.collect.ImmutableSetMultimap\" data-throw-if-not-resolved=\"false\">ImmutableSetMultimap</xref>. General-purpose mutable implementations are listed above under \"All Known Implementing Classes\". You can also create a *custom* multimap, backed by any `Map` and <xref uid=\"java.util.Collection\" data-throw-if-not-resolved=\"false\">Collection</xref> types, using the <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimaps.newMultimap\" data-throw-if-not-resolved=\"false\">Multimaps.newMultimap</xref> family of methods. Finally, another popular way to obtain a multimap is using <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimaps.index\" data-throw-if-not-resolved=\"false\">Multimaps.index</xref>. See the <xref uid=\"com.azure.cosmos.implementation.guava25.collect.Multimaps\" data-throw-if-not-resolved=\"false\">Multimaps</xref> class for these and other static utilities related to multimaps.\n\n### Other Notes ###\n\nAs with `Map`, the behavior of a `Multimap` is not specified if key objects already present in the multimap change in a manner that affects `equals` comparisons. Use caution if mutable objects are used as keys in a `Multimap`.\n\nAll methods that modify the multimap are optional. The view collections returned by the multimap may or may not be modifiable. Any modification method that is not supported will throw <xref uid=\"java.lang.UnsupportedOperationException\" data-throw-if-not-resolved=\"false\">UnsupportedOperationException</xref>.\n\nSee the Guava User Guide article on [ `Multimap`][_Multimap].\n\n\n[_Multimap]: https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap"
syntax: "public interface Multimap<K,V>"
methods:
- "com.azure.cosmos.implementation.guava25.collect.Multimap.asMap()"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.clear()"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.containsEntry(java.lang.Object,java.lang.Object)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.containsKey(java.lang.Object)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.containsValue(java.lang.Object)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.entries()"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.equals(java.lang.Object)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.forEach(java.util.function.BiConsumer<? super K,? super V>)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.get(K)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.hashCode()"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.isEmpty()"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.keySet()"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.keys()"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.put(K,V)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.putAll(K,java.lang.Iterable<? extends V>)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.putAll(com.azure.cosmos.implementation.guava25.collect.Multimap<? extends K,? extends V>)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.remove(java.lang.Object,java.lang.Object)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.removeAll(java.lang.Object)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.replaceValues(K,java.lang.Iterable<? extends V>)"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.size()"
- "com.azure.cosmos.implementation.guava25.collect.Multimap.values()"
type: "interface"
typeParameters:
- name: "K"
- name: "V"
metadata: {}
package: "com.azure.cosmos.implementation.guava25.collect"
artifact: com.azure:azure-cosmos:4.4.0-beta.1
