### YamlMime:JavaType
constructors:
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String hostName, AzureSasCredential azureSasCredential, IotHubServiceClientProtocol protocol)
  name: MessagingClient(String hostName, AzureSasCredential azureSasCredential, IotHubServiceClientProtocol protocol)
  nameWithType: MessagingClient.MessagingClient(String hostName, AzureSasCredential azureSasCredential, IotHubServiceClientProtocol protocol)
  parameters:
  - description: <p>The hostname of your IoT Hub instance (For instance, "your-iot-hub.azure-devices.net") </p>
    name: hostName
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The SAS token provider that will be used for authentication. </p>
    name: azureSasCredential
    type: <xref href="AzureSasCredential?alt=AzureSasCredential&text=AzureSasCredential" data-throw-if-not-resolved="False"/>
  - description: <p>The protocol that the client will communicate to IoT Hub over. </p>
    name: protocol
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol?alt=com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol&text=IotHubServiceClientProtocol" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Create a <xref uid="com.microsoft.azure.sdk.iot.service.messaging.MessagingClient" data-throw-if-not-resolved="false" data-raw-source="MessagingClient"></xref> instance with an instance of <xref uid="" data-throw-if-not-resolved="false" data-raw-source="AzureSasCredential"></xref>.</p>

    <p></p>
  syntax: public MessagingClient(String hostName, AzureSasCredential azureSasCredential, IotHubServiceClientProtocol protocol)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String,AzureSasCredential,IotHubServiceClientProtocol)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String hostName, AzureSasCredential azureSasCredential, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  name: MessagingClient(String hostName, AzureSasCredential azureSasCredential, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  nameWithType: MessagingClient.MessagingClient(String hostName, AzureSasCredential azureSasCredential, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  parameters:
  - description: <p>The hostname of your IoT Hub instance (For instance, "your-iot-hub.azure-devices.net") </p>
    name: hostName
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The SAS token provider that will be used for authentication. </p>
    name: azureSasCredential
    type: <xref href="AzureSasCredential?alt=AzureSasCredential&text=AzureSasCredential" data-throw-if-not-resolved="False"/>
  - description: <p>The protocol that the client will communicate to IoT Hub over. </p>
    name: protocol
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol?alt=com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol&text=IotHubServiceClientProtocol" data-throw-if-not-resolved="False"/>
  - description: <p>The connection options to use when connecting to the service. May not be null. </p>
    name: options
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.MessagingClientOptions?alt=com.microsoft.azure.sdk.iot.service.messaging.MessagingClientOptions&text=MessagingClientOptions" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Create a <xref uid="com.microsoft.azure.sdk.iot.service.messaging.MessagingClient" data-throw-if-not-resolved="false" data-raw-source="MessagingClient"></xref> instance with an instance of <xref uid="" data-throw-if-not-resolved="false" data-raw-source="AzureSasCredential"></xref>.</p>

    <p></p>
  syntax: public MessagingClient(String hostName, AzureSasCredential azureSasCredential, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String,AzureSasCredential,IotHubServiceClientProtocol,MessagingClientOptions)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String connectionString, IotHubServiceClientProtocol protocol)
  name: MessagingClient(String connectionString, IotHubServiceClientProtocol protocol)
  nameWithType: MessagingClient.MessagingClient(String connectionString, IotHubServiceClientProtocol protocol)
  parameters:
  - description: <p>The connection string for the IotHub </p>
    name: connectionString
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The protocol that the client will communicate to IoT Hub over. </p>
    name: protocol
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol?alt=com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol&text=IotHubServiceClientProtocol" data-throw-if-not-resolved="False"/>
  summary: <p>Construct a MessagingClient from the specified connection string </p>
  syntax: public MessagingClient(String connectionString, IotHubServiceClientProtocol protocol)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String,IotHubServiceClientProtocol)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String connectionString, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  name: MessagingClient(String connectionString, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  nameWithType: MessagingClient.MessagingClient(String connectionString, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  parameters:
  - description: <p>The connection string for the IotHub </p>
    name: connectionString
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The protocol that the client will communicate to IoT Hub over. </p>
    name: protocol
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol?alt=com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol&text=IotHubServiceClientProtocol" data-throw-if-not-resolved="False"/>
  - description: <p>The connection options to use when connecting to the service. May not be null. </p>
    name: options
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.MessagingClientOptions?alt=com.microsoft.azure.sdk.iot.service.messaging.MessagingClientOptions&text=MessagingClientOptions" data-throw-if-not-resolved="False"/>
  summary: <p>Construct a MessagingClient from the specified connection string </p>
  syntax: public MessagingClient(String connectionString, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String,IotHubServiceClientProtocol,MessagingClientOptions)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String hostName, TokenCredential credential, IotHubServiceClientProtocol protocol)
  name: MessagingClient(String hostName, TokenCredential credential, IotHubServiceClientProtocol protocol)
  nameWithType: MessagingClient.MessagingClient(String hostName, TokenCredential credential, IotHubServiceClientProtocol protocol)
  parameters:
  - description: <p>The hostname of your IoT Hub instance (For instance, "your-iot-hub.azure-devices.net") </p>
    name: hostName
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The custom <xref uid="" data-throw-if-not-resolved="false" data-raw-source="TokenCredential"></xref> that will provide authentication tokens to this library when they are needed. The provided tokens must be Json Web Tokens. </p>
    name: credential
    type: <xref href="TokenCredential?alt=TokenCredential&text=TokenCredential" data-throw-if-not-resolved="False"/>
  - description: <p>The protocol that the client will communicate to IoT Hub over. </p>
    name: protocol
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol?alt=com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol&text=IotHubServiceClientProtocol" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Create a <xref uid="com.microsoft.azure.sdk.iot.service.messaging.MessagingClient" data-throw-if-not-resolved="false" data-raw-source="MessagingClient"></xref> instance with a custom <xref uid="" data-throw-if-not-resolved="false" data-raw-source="TokenCredential"></xref> to allow for finer grain control of authentication tokens used in the underlying connection.</p>

    <p></p>
  syntax: public MessagingClient(String hostName, TokenCredential credential, IotHubServiceClientProtocol protocol)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String,TokenCredential,IotHubServiceClientProtocol)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String hostName, TokenCredential credential, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  name: MessagingClient(String hostName, TokenCredential credential, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  nameWithType: MessagingClient.MessagingClient(String hostName, TokenCredential credential, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  parameters:
  - description: <p>The hostname of your IoT Hub instance (For instance, "your-iot-hub.azure-devices.net") </p>
    name: hostName
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>The custom <xref uid="" data-throw-if-not-resolved="false" data-raw-source="TokenCredential"></xref> that will provide authentication tokens to this library when they are needed. The provided tokens must be Json Web Tokens. </p>
    name: credential
    type: <xref href="TokenCredential?alt=TokenCredential&text=TokenCredential" data-throw-if-not-resolved="False"/>
  - description: <p>The protocol that the client will communicate to IoT Hub over. </p>
    name: protocol
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol?alt=com.microsoft.azure.sdk.iot.service.messaging.IotHubServiceClientProtocol&text=IotHubServiceClientProtocol" data-throw-if-not-resolved="False"/>
  - description: <p>The connection options to use when connecting to the service. May not be null. </p>
    name: options
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.MessagingClientOptions?alt=com.microsoft.azure.sdk.iot.service.messaging.MessagingClientOptions&text=MessagingClientOptions" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Create a <xref uid="com.microsoft.azure.sdk.iot.service.messaging.MessagingClient" data-throw-if-not-resolved="false" data-raw-source="MessagingClient"></xref> instance with a custom <xref uid="" data-throw-if-not-resolved="false" data-raw-source="TokenCredential"></xref> to allow for finer grain control of authentication tokens used in the underlying connection.</p>

    <p></p>
  syntax: public MessagingClient(String hostName, TokenCredential credential, IotHubServiceClientProtocol protocol, MessagingClientOptions options)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.MessagingClient(String,TokenCredential,IotHubServiceClientProtocol,MessagingClientOptions)
inheritances:
- <xref href="java.lang.Object" data-throw-if-not-resolved="False"/>
methods:
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.close()
  name: close()
  nameWithType: MessagingClient.close()
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if this function is interrupted while waiting for the connection to close down all network resources. </p>
  returns:
    type: <xref href="synchronized+void?alt=synchronized+void&text=synchronized+void" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Close this client and release all network resources tied to it. Once closed, this client can be re-opened by calling <xref uid="com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.open()" data-throw-if-not-resolved="false" data-raw-source="open()"></xref>. If this client is already closed, this function will do nothing.</p>

    <p></p>
  syntax: public synchronized void close()
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.close()
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.close(int timeoutMilliseconds)
  name: close(int timeoutMilliseconds)
  nameWithType: MessagingClient.close(int timeoutMilliseconds)
  parameters:
  - description: <p>the maximum number of milliseconds to wait for the underlying amqp connection to close. If this value is 0, it will have an infinite timeout. If the provided timeout has passed and the connection has not closed gracefully, then the connection will be forcefully closed and no exception will be thrown. </p>
    name: timeoutMilliseconds
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>if this function is interrupted while waiting for the connection to close down all network resources. </p>
  returns:
    type: <xref href="synchronized+void?alt=synchronized+void&text=synchronized+void" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Close this client and release all network resources tied to it. Once closed, this client can be re-opened by calling <xref uid="com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.open()" data-throw-if-not-resolved="false" data-raw-source="open()"></xref>. If this client is already closed, this function will do nothing.</p>

    <p></p>
  syntax: public synchronized void close(int timeoutMilliseconds)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.close(int)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.isOpen()
  name: isOpen()
  nameWithType: MessagingClient.isOpen()
  returns:
    description: <p>true if this client is currently open and false otherwise. </p>
    type: <xref href="boolean?alt=boolean&text=boolean" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Returns true if this client is currently open and false otherwise. This client may lose connectivity due to network issues, so this value may be false even if you have not closed the client yourself. Monitoring the optional errorProcessor that can be set in <xref uid="com.microsoft.azure.sdk.iot.service.messaging.MessagingClientOptions" data-throw-if-not-resolved="false" data-raw-source="MessagingClientOptions"></xref> will provide the context on when connection loss events occur, and why they occurred.</p>

    <p></p>
  syntax: public boolean isOpen()
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.isOpen()
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.open()
  name: open()
  nameWithType: MessagingClient.open()
  exceptions:
  - type: <xref href="IotHubException?alt=IotHubException&text=IotHubException" data-throw-if-not-resolved="False"/>
    description: <p>If any IoT Hub level exceptions occur such as an <xref uid="" data-throw-if-not-resolved="false" data-raw-source="IotHubUnauthorizedException"></xref>. </p>
  - type: <xref href="IOException?alt=IOException&text=IOException" data-throw-if-not-resolved="False"/>
    description: <p>If any network level exceptions occur such as the connection timing out. </p>
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>If this thread is interrupted while waiting for the connection to the service to open. </p>
  - type: <xref href="TimeoutException?alt=TimeoutException&text=TimeoutException" data-throw-if-not-resolved="False"/>
    description: <p>If the connection is not established before the default timeout. </p>
  returns:
    type: <xref href="synchronized+void?alt=synchronized+void&text=synchronized+void" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Open this client so that it can begin sending cloud to device and/or cloud to module messages. Once opened, you should call <xref uid="com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.close()" data-throw-if-not-resolved="false" data-raw-source="close()"></xref> once no more messages will be sent in order to free up network resources. If this client is already open, then this function will do nothing.</p>

    <p></p>
  syntax: public synchronized void open()
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.open()
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.open(int timeoutMilliseconds)
  name: open(int timeoutMilliseconds)
  nameWithType: MessagingClient.open(int timeoutMilliseconds)
  parameters:
  - description: <p>the maximum number of milliseconds to wait for the underlying amqp connection to open. If this value is 0, it will have an infinite timeout. </p>
    name: timeoutMilliseconds
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IotHubException?alt=IotHubException&text=IotHubException" data-throw-if-not-resolved="False"/>
    description: <p>If any IoT Hub level exceptions occur such as an <xref uid="" data-throw-if-not-resolved="false" data-raw-source="IotHubUnauthorizedException"></xref>. </p>
  - type: <xref href="IOException?alt=IOException&text=IOException" data-throw-if-not-resolved="False"/>
    description: <p>If any network level exceptions occur such as the connection timing out. </p>
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>If this thread is interrupted while waiting for the connection to the service to open. </p>
  - type: <xref href="TimeoutException?alt=TimeoutException&text=TimeoutException" data-throw-if-not-resolved="False"/>
    description: <p>If the connection is not established before the provided timeout. </p>
  returns:
    type: <xref href="synchronized+void?alt=synchronized+void&text=synchronized+void" data-throw-if-not-resolved="False"/>
  summary: >-
    <p>Open this client so that it can begin sending cloud to device and/or cloud to module messages. Once opened, this client should call <xref uid="com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.close()" data-throw-if-not-resolved="false" data-raw-source="close()"></xref> once no more messages will be sent in order to free up network resources. If this client is already open, then this function will do nothing.</p>

    <p></p>
  syntax: public synchronized void open(int timeoutMilliseconds)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.open(int)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.send(String deviceId, Message message)
  name: send(String deviceId, Message message)
  nameWithType: MessagingClient.send(String deviceId, Message message)
  parameters:
  - description: <p>the Id of the device to send the cloud to device message to. </p>
    name: deviceId
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>the message to send to the device. </p>
    name: message
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.Message?alt=com.microsoft.azure.sdk.iot.service.messaging.Message&text=Message" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IotHubException?alt=IotHubException&text=IotHubException" data-throw-if-not-resolved="False"/>
    description: <p>If any IoT Hub level exception is thrown. For instance, if the provided message exceeds the IoT Hub message size limit, <xref uid="com.microsoft.azure.sdk.iot.service.exceptions.IotHubMessageTooLargeException" data-throw-if-not-resolved="false" data-raw-source="com.microsoft.azure.sdk.iot.service.exceptions.IotHubMessageTooLargeException"></xref> will be thrown. </p>
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>If this function is interrupted while waiting for the cloud to device message to be acknowledged by the service. </p>
  - type: <xref href="TimeoutException?alt=TimeoutException&text=TimeoutException" data-throw-if-not-resolved="False"/>
    description: <p>If the sent message isn't acknowledged by the service within the default timeout. </p>
  - type: <xref href="IllegalStateException?alt=IllegalStateException&text=IllegalStateException" data-throw-if-not-resolved="False"/>
    description: <p>if the client has not been opened yet, or is closed for any other reason such as connectivity loss. </p>
  summary: >-
    <p>Send a cloud to device message to the device with the provided device id.</p>

    <p>This method is a blocking call that will wait for the sent message to be acknowledged by the service before returning. This is provided for simplicity and for applications that aren't concerned with throughput. For applications that need to provided higher throughput of sent cloud to device messages, users should use <xref uid="" data-throw-if-not-resolved="false" data-raw-source="sendAsync(String, Message, Consumer, Object)"></xref> as demonstrated in the messaging client performance sample in this repo. </p>

    <p></p>
  syntax: public void send(String deviceId, Message message)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.send(String,Message)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.send(String deviceId, Message message, int timeoutMilliseconds)
  name: send(String deviceId, Message message, int timeoutMilliseconds)
  nameWithType: MessagingClient.send(String deviceId, Message message, int timeoutMilliseconds)
  parameters:
  - description: <p>the Id of the device to send the cloud to device message to. </p>
    name: deviceId
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>the message to send to the device. </p>
    name: message
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.Message?alt=com.microsoft.azure.sdk.iot.service.messaging.Message&text=Message" data-throw-if-not-resolved="False"/>
  - description: <p>the maximum number of milliseconds to wait for the message to be sent before timing out and throwing an <xref uid="" data-throw-if-not-resolved="false" data-raw-source="IotHubException"></xref>. </p>
    name: timeoutMilliseconds
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IotHubException?alt=IotHubException&text=IotHubException" data-throw-if-not-resolved="False"/>
    description: <p>If any IoT Hub level exception is thrown. For instance, if the provided message exceeds the IoT Hub message size limit, <xref uid="com.microsoft.azure.sdk.iot.service.exceptions.IotHubMessageTooLargeException" data-throw-if-not-resolved="false" data-raw-source="com.microsoft.azure.sdk.iot.service.exceptions.IotHubMessageTooLargeException"></xref> will be thrown. </p>
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>If this function is interrupted while waiting for the cloud to device message to be acknowledged by the service. </p>
  - type: <xref href="TimeoutException?alt=TimeoutException&text=TimeoutException" data-throw-if-not-resolved="False"/>
    description: <p>If the sent message isn't acknowledged by the service within the provided timeout. </p>
  - type: <xref href="IllegalStateException?alt=IllegalStateException&text=IllegalStateException" data-throw-if-not-resolved="False"/>
    description: <p>if the client has not been opened yet, or is closed for any other reason such as connectivity loss. </p>
  summary: >-
    <p>Send a cloud to device message to the device with the provided device id.</p>

    <p>This method is a blocking call that will wait for the sent message to be acknowledged by the service before returning. This is provided for simplicity and for applications that aren't concerned with throughput. For applications that need to provided higher throughput of sent cloud to device messages, users should use <xref uid="" data-throw-if-not-resolved="false" data-raw-source="sendAsync(String, Message, Consumer, Object)"></xref> as demonstrated in the messaging client performance sample in this repo. </p>

    <p></p>
  syntax: public void send(String deviceId, Message message, int timeoutMilliseconds)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.send(String,Message,int)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.send(String deviceId, String moduleId, Message message)
  name: send(String deviceId, String moduleId, Message message)
  nameWithType: MessagingClient.send(String deviceId, String moduleId, Message message)
  parameters:
  - description: <p>the Id of the device that contains the module that the message is being sent to. </p>
    name: deviceId
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>the Id of the module to send the cloud to device message to. </p>
    name: moduleId
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>the message to send to the device. </p>
    name: message
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.Message?alt=com.microsoft.azure.sdk.iot.service.messaging.Message&text=Message" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IotHubException?alt=IotHubException&text=IotHubException" data-throw-if-not-resolved="False"/>
    description: <p>If any IoT Hub level exception is thrown. For instance, if the provided message exceeds the IoT Hub message size limit, <xref uid="com.microsoft.azure.sdk.iot.service.exceptions.IotHubMessageTooLargeException" data-throw-if-not-resolved="false" data-raw-source="com.microsoft.azure.sdk.iot.service.exceptions.IotHubMessageTooLargeException"></xref> will be thrown. </p>
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>If this function is interrupted while waiting for the cloud to device message to be acknowledged by the service. </p>
  - type: <xref href="TimeoutException?alt=TimeoutException&text=TimeoutException" data-throw-if-not-resolved="False"/>
    description: <p>If the sent message isn't acknowledged by the service within the default timeout. </p>
  - type: <xref href="IllegalStateException?alt=IllegalStateException&text=IllegalStateException" data-throw-if-not-resolved="False"/>
    description: <p>if the client has not been opened yet, or is closed for any other reason such as connectivity loss. </p>
  summary: >-
    <p>Send a cloud to device message to the module with the provided module id on the device with the provided device Id.</p>

    <p>This method is a blocking call that will wait for the sent message to be acknowledged by the service before returning. This is provided for simplicity and for applications that aren't concerned with throughput. For applications that need to provided higher throughput of sent cloud to device messages, users should use <xref uid="" data-throw-if-not-resolved="false" data-raw-source="sendAsync(String, String, Message, Consumer, Object)"></xref> as demonstrated in the messaging client performance sample in this repo. </p>

    <p></p>
  syntax: public void send(String deviceId, String moduleId, Message message)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.send(String,String,Message)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.send(String deviceId, String moduleId, Message message, int timeoutMilliseconds)
  name: send(String deviceId, String moduleId, Message message, int timeoutMilliseconds)
  nameWithType: MessagingClient.send(String deviceId, String moduleId, Message message, int timeoutMilliseconds)
  parameters:
  - description: <p>the Id of the device that contains the module that the message is being sent to. </p>
    name: deviceId
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>the Id of the module to send the cloud to device message to. </p>
    name: moduleId
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>the message to send to the device. </p>
    name: message
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.Message?alt=com.microsoft.azure.sdk.iot.service.messaging.Message&text=Message" data-throw-if-not-resolved="False"/>
  - description: <p>the maximum number of milliseconds to wait for the message to be sent before timing out and throwing an <xref uid="" data-throw-if-not-resolved="false" data-raw-source="IotHubException"></xref>. </p>
    name: timeoutMilliseconds
    type: <xref href="int?alt=int&text=int" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IotHubException?alt=IotHubException&text=IotHubException" data-throw-if-not-resolved="False"/>
    description: <p>If any IoT Hub level exception is thrown. For instance, if the provided message exceeds the IoT Hub message size limit, <xref uid="com.microsoft.azure.sdk.iot.service.exceptions.IotHubMessageTooLargeException" data-throw-if-not-resolved="false" data-raw-source="com.microsoft.azure.sdk.iot.service.exceptions.IotHubMessageTooLargeException"></xref> will be thrown. </p>
  - type: <xref href="InterruptedException?alt=InterruptedException&text=InterruptedException" data-throw-if-not-resolved="False"/>
    description: <p>If this function is interrupted while waiting for the cloud to device message to be acknowledged by the service. </p>
  - type: <xref href="TimeoutException?alt=TimeoutException&text=TimeoutException" data-throw-if-not-resolved="False"/>
    description: <p>If the sent message isn't acknowledged by the service within the provided timeout. </p>
  - type: <xref href="IllegalStateException?alt=IllegalStateException&text=IllegalStateException" data-throw-if-not-resolved="False"/>
    description: <p>if the client has not been opened yet, or is closed for any other reason such as connectivity loss. </p>
  summary: >-
    <p>Send a cloud to device message to the module with the provided module id on the device with the provided device Id.</p>

    <p>This method is a blocking call that will wait for the sent message to be acknowledged by the service before returning. This is provided for simplicity and for applications that aren't concerned with throughput. For applications that need to provided higher throughput of sent cloud to device messages, users should use <xref uid="" data-throw-if-not-resolved="false" data-raw-source="sendAsync(String, String, Message, Consumer, Object)"></xref> as demonstrated in the messaging client performance sample in this repo. </p>

    <p></p>
  syntax: public void send(String deviceId, String moduleId, Message message, int timeoutMilliseconds)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.send(String,String,Message,int)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.sendAsync(String deviceId, Message message, Consumer<SendResult> onMessageSentCallback, Object context)
  name: sendAsync(String deviceId, Message message, Consumer<SendResult> onMessageSentCallback, Object context)
  nameWithType: MessagingClient.sendAsync(String deviceId, Message message, Consumer<SendResult> onMessageSentCallback, Object context)
  parameters:
  - description: <p>the Id of the device to send the cloud to device message to. </p>
    name: deviceId
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>the message to send to the device. </p>
    name: message
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.Message?alt=com.microsoft.azure.sdk.iot.service.messaging.Message&text=Message" data-throw-if-not-resolved="False"/>
  - description: <p>the callback that will be executed when the message has either successfully been sent, or has failed to send. May be null if you don't care if the sent message is acknowledged by the service. </p>
    name: onMessageSentCallback
    type: Consumer&lt;<xref href="com.microsoft.azure.sdk.iot.service.messaging.SendResult?alt=com.microsoft.azure.sdk.iot.service.messaging.SendResult&text=SendResult" data-throw-if-not-resolved="False"/>&gt;
  - description: <p>user defined context that will be provided in the onMessageSentCallback callback when it executes. May be null. </p>
    name: context
    type: <xref href="Object?alt=Object&text=Object" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IllegalStateException?alt=IllegalStateException&text=IllegalStateException" data-throw-if-not-resolved="False"/>
    description: <p>if the client has not been opened yet, or is closed for any other reason such as connectivity loss. </p>
  summary: >-
    <p>Asynchronously send a cloud to device message to the device with the provided device Id. </p>

    <p>Unlike the synchronous version of this function, this function does not throw any exceptions. Instead, any exception encountered while sending the message will be provided in the <xref uid="com.microsoft.azure.sdk.iot.service.messaging.SendResult" data-throw-if-not-resolved="false" data-raw-source="SendResult"></xref> provided in the onMessageSentCallback. To see an example of how this looks, see the messaging client performance sample in this repo. </p>

    <p></p>
  syntax: public void sendAsync(String deviceId, Message message, Consumer<SendResult> onMessageSentCallback, Object context)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.sendAsync(String,Message,Consumer<SendResult>,Object)
- fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.sendAsync(String deviceId, String moduleId, Message message, Consumer<SendResult> onMessageSentCallback, Object context)
  name: sendAsync(String deviceId, String moduleId, Message message, Consumer<SendResult> onMessageSentCallback, Object context)
  nameWithType: MessagingClient.sendAsync(String deviceId, String moduleId, Message message, Consumer<SendResult> onMessageSentCallback, Object context)
  parameters:
  - description: <p>the Id of the device that contains the module that the message is being sent to. </p>
    name: deviceId
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>the Id of the module to send the cloud to device message to. </p>
    name: moduleId
    type: <xref href="String?alt=String&text=String" data-throw-if-not-resolved="False"/>
  - description: <p>the message to send to the device. </p>
    name: message
    type: <xref href="com.microsoft.azure.sdk.iot.service.messaging.Message?alt=com.microsoft.azure.sdk.iot.service.messaging.Message&text=Message" data-throw-if-not-resolved="False"/>
  - description: <p>the callback that will be executed when the message has either successfully been sent, or has failed to send. May be null if you don't care if the sent message is acknowledged by the service. </p>
    name: onMessageSentCallback
    type: Consumer&lt;<xref href="com.microsoft.azure.sdk.iot.service.messaging.SendResult?alt=com.microsoft.azure.sdk.iot.service.messaging.SendResult&text=SendResult" data-throw-if-not-resolved="False"/>&gt;
  - description: <p>user defined context that will be provided in the onMessageSentCallback callback when it executes. May be null. </p>
    name: context
    type: <xref href="Object?alt=Object&text=Object" data-throw-if-not-resolved="False"/>
  exceptions:
  - type: <xref href="IllegalStateException?alt=IllegalStateException&text=IllegalStateException" data-throw-if-not-resolved="False"/>
    description: <p>if the client has not been opened yet, or is closed for any other reason such as connectivity loss. </p>
  summary: >-
    <p>Asynchronously send a cloud to device message to the module with the provided module id on the device with the provided device Id. </p>

    <p>Unlike the synchronous version of this function, this function does not throw any exceptions. Instead, any exception encountered while sending the message will be provided in the <xref uid="com.microsoft.azure.sdk.iot.service.messaging.SendResult" data-throw-if-not-resolved="false" data-raw-source="SendResult"></xref> provided in the onMessageSentCallback. To see an example of how this looks, see the messaging client performance sample in this repo. </p>

    <p></p>
  syntax: public void sendAsync(String deviceId, String moduleId, Message message, Consumer<SendResult> onMessageSentCallback, Object context)
  uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient.sendAsync(String,String,Message,Consumer<SendResult>,Object)
nameWithType: MessagingClient
syntax: public class MessagingClient
type: class
uid: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient
fullName: com.microsoft.azure.sdk.iot.service.messaging.MessagingClient
name: MessagingClient
package: com.microsoft.azure.sdk.iot.service.messaging
summary: >-
  <p>A client for sending cloud to device and cloud to module messages. For more details on what cloud to device messages are, see <a href="https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messages-c2d#message-feedback">this document</a>.</p>

  <p>This client relies on a persistent amqp/amqp_ws connection to IoT Hub that may break due to network instability. While optional to monitor, users are highly encouraged to utilize the errorProcessorHandler defined in the <xref uid="com.microsoft.azure.sdk.iot.service.messaging.MessagingClientOptions" data-throw-if-not-resolved="false" data-raw-source="MessagingClientOptions"></xref> when constructing this client in order to monitor the connection state and to re-open the connection when needed. See the messaging client sample in this repo for best practices for monitoring and handling disconnection events. </p>
metadata: {}
